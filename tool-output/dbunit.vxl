<?xml version="1.0" encoding="UTF-8"?>
<java-project id="default" name="dbunit" revision="dbunit">
	<pkg name="/:org.dbunit">
		<class name="/:org.dbunit.PropertiesBasedJdbcDatabaseTester" intfc="n" abs="n" inn="n" sloc="17" jdoc="DatabaseTester that configures a DriverManager from environment properties.&amp;lt;br&amp;gt; This class defines a set of keys for system properties that need to be present in the environment before using it. Example: &amp;lt;xmp&amp;gt; System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, &amp;quot;com.mycompany.myDriver&amp;quot; ); System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, &amp;quot;jdbc:mydb: host dbname&amp;quot; ); System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, &amp;quot;myuser&amp;quot; ); System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, &amp;quot;mypasswd&amp;quot; ); System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_SCHEMA, &amp;quot;myschema&amp;quot; ); &amp;lt; xmp&amp;gt; @author Andres Almiray(aalmiray@users.sourceforge.net) @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 928 $ $Date: 2008-12-28 18:24:41 -0200 (Dom, 28 Dez 2008) $ @since 2.2.0">
			<const name="DBUNIT_CONNECTION_URL" access="pub" jdoc="A key for property that defines the connection url"/>
			<const name="DBUNIT_DRIVER_CLASS" access="pub" jdoc="A key for property that defines the driver classname"/>
			<const name="DBUNIT_PASSWORD" access="pub" jdoc="A key for property that defines the user&amp;apos;s password"/>
			<const name="DBUNIT_USERNAME" access="pub" jdoc="A key for property that defines the username"/>
			<const name="DBUNIT_SCHEMA" access="pub" jdoc="A key for property that defines the database schema"/>
			<mth name="/:org.dbunit.PropertiesBasedJdbcDatabaseTester.PropertiesBasedJdbcDatabaseTester()" access="pub" jdoc="Creates a new {@link JdbcDatabaseTester} using specific {@link System#getProperty(String)}values as initialization parameters @throws Exception">
			</mth>
		</class>
		<class name="/:org.dbunit.AbstractDatabaseTester" intfc="n" abs="y" inn="n" sloc="117" jdoc="Basic implementation of IDatabaseTester.&amp;lt;br&amp;gt; Implementations of IDatabaseTester may use this class as a starting point. @author Andres Almiray (aalmiray@users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 978 $ $Date: 2009-02-27 17:20:23 -0300 (Sex, 27 Fev 2009) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="dataSet" access="priv" jdoc=""/>
			<field name="schema" access="priv" jdoc=""/>
			<field name="setUpOperation" access="priv" jdoc=""/>
			<field name="tearDownOperation" access="priv" jdoc=""/>
			<field name="operationListener" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.AbstractDatabaseTester.AbstractDatabaseTester()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.AbstractDatabaseTester(String)" access="pub" jdoc="@param schema The schema to be tested. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @since 2.4.3">
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.closeConnection(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.getDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.onSetup()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.onTearDown()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.setDataSet(IDataSet)" access="pub" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.setSchema(String)" access="pub" jdoc="">
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.setSetUpOperation(DatabaseOperation)" access="pub" jdoc="">
				<param name="setUpOperation"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.setTearDownOperation(DatabaseOperation)" access="pub" jdoc="">
				<param name="tearDownOperation"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.getSchema()" access="prot" jdoc="Returns the schema value.">
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.getSetUpOperation()" access="prot" jdoc="Returns the DatabaseOperation to call when starting the test.">
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.getTearDownOperation()" access="prot" jdoc="Returns the DatabaseOperation to call when ending the test.">
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.executeOperation(DatabaseOperation, OperationType)" access="priv" jdoc="Executes a DatabaseOperation with a IDatabaseConnection supplied by{@link getConnection()} and the test dataset.">
				<comm cntt="Ensure that the operationListener is set"/>
				<comm cntt="Since 2.4.4 the OperationListener is responsible for closing the connection at the right time"/>
				<param name="operation"/>
				<param name="type"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.setOperationListener(IOperationListener)" access="pub" jdoc="">
				<param name="operationListener"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester.toString()" access="pub" jdoc="">
			</mth>
		<class name="/:org.dbunit.AbstractDatabaseTester$OperationType" intfc="n" abs="n" inn="y" sloc="11" jdoc="Enumeration of the valid {@link OperationType}s">
			<const name="SET_UP" access="pub" jdoc=""/>
			<const name="TEAR_DOWN" access="pub" jdoc=""/>
			<field name="key" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.AbstractDatabaseTester$OperationType.OperationType(String)" access="priv" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/:org.dbunit.AbstractDatabaseTester$OperationType.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.PrepAndExpectedTestCase" intfc="y" abs="n" inn="n" sloc="12" jdoc="Test case supporting prep data and expected data. @author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.configureTest(VerifyTableDefinition[], String[], String[])" access="pub" jdoc="Configure the test. Call this method before performing the test steps. @param tablesTable definitions to verify after test execution. @param prepDataFilesThe prep data files to load as seed data. @param expectedDataFilesThe expected data files to load as expected data. @throws Exception">
				<param name="tables"/>
				<param name="prepDataFiles"/>
				<param name="expectedDataFiles"/>
			</mth>
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.preTest()" access="pub" jdoc="Execute pre-test steps. Call this method before performing the test steps. @throws Exception">
			</mth>
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.preTest(VerifyTableDefinition[], String[], String[])" access="pub" jdoc="Convenience method to call configureTest() and preTest(). @param tablesTable definitions to verify after test execution. @param prepDataFilesThe prep data files to load as seed data. @param expectedDataFilesThe expected data files to load as expected data. @throws Exception">
				<param name="tables"/>
				<param name="prepDataFiles"/>
				<param name="expectedDataFiles"/>
			</mth>
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.postTest()" access="pub" jdoc="Execute all post-test steps. Call this method after performing the test steps. @throws Exception">
			</mth>
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.postTest(boolean)" access="pub" jdoc="Execute post-test steps. Call this method after performing the test steps. @param verifyDataSpecify true to perform verify data steps, false to not. Useful to specify false when test has failure in progress (e.g. an exception) and verifying data would fail, masking original test failure. @throws Exception">
				<param name="verifyData"/>
			</mth>
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.cleanupData()" access="pub" jdoc="Cleanup tables specified in prep and expected datasets, using the provided databaseTester. See{@link org.dbunit.IDatabaseTester#onTearDown()}. @throws Exception">
			</mth>
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.getPrepDataset()" access="pub" jdoc="Get the prep dataset, created from the prepDataFiles. @return The prep dataset.">
			</mth>
			<mth name="/:org.dbunit.PrepAndExpectedTestCase.getExpectedDataset()" access="pub" jdoc="Get the expected dataset, created from the expectedDataFiles. @return The expected dataset.">
			</mth>
		</class>
		<class name="/:org.dbunit.DataSourceBasedDBTestCase" intfc="n" abs="y" inn="n" sloc="17" jdoc="TestCase that uses a DataSourceDatabaseTester. @author Andres Almiray (aalmiray@users.sourceforge.net) @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.DataSourceBasedDBTestCase.DataSourceBasedDBTestCase()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.DataSourceBasedDBTestCase.DataSourceBasedDBTestCase(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.DataSourceBasedDBTestCase.newDatabaseTester()" access="prot" jdoc="Creates a new IDatabaseTester.&amp;lt;br&amp;gt; Default implementation returns a {@link DataSourceDatabaseTester}configured with the value returned from {@link #getDataSource()}.">
			</mth>
			<mth name="/:org.dbunit.DataSourceBasedDBTestCase.getDataSource()" access="prot" jdoc="Returns the test DataSource.">
			</mth>
		</class>
		<class name="/:org.dbunit.IOperationListener" intfc="y" abs="n" inn="n" sloc="18" jdoc="Listener for {@link IDatabaseConnection} events. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 978 $ $Date: 2009-02-27 17:20:23 -0300 (Sex, 27 Fev 2009) $ @since 2.4.4">
			<const name="NO_OP_OPERATION_LISTENER" access="pub" jdoc="Simple implementation of the {@link IOperationListener} that does &amp;lt;b&amp;gt;not&amp;lt; b&amp;gt; close the database connection after setUp and tearDown. Can be used via {@link IDatabaseTester#setOperationListener(IOperationListener)} to avoid that connections are closed. @since 2.4.5"/>
			<mth name="/:org.dbunit.IOperationListener.connectionRetrieved(IDatabaseConnection)" access="pub" jdoc="Is invoked immediately after a connection was newly created or an existing connection is retrieved to do some work on it. It should be used to initialize the {@link DatabaseConfig} of the connection with user defined parameters. @param connection The database connection @since 2.4.4">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.IOperationListener.operationSetUpFinished(IDatabaseConnection)" access="pub" jdoc="Notification of the completion of the {@link IDatabaseTester#onSetup()} method. Should close the given connection if desired. @param connection The database connection @since 2.4.4">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.IOperationListener.operationTearDownFinished(IDatabaseConnection)" access="pub" jdoc="Notification of the completion of the {@link IDatabaseTester#onTearDown()} method Should close the given connection if desired. @param connection The database connection @since 2.4.4">
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.DefaultDatabaseTester" intfc="n" abs="n" inn="n" sloc="9" jdoc="Default implementation of AbstractDatabaseTester, which does not know how to get a connection by itself. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 766 $ @since 2.2">
			<const name="connection" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.DefaultDatabaseTester.DefaultDatabaseTester(IDatabaseConnection)" access="pub" jdoc="Creates a new DefaultDatabaseTester with the supplied connection.">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.DefaultDatabaseTester.getConnection()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.DatabaseUnitException" intfc="n" abs="n" inn="n" sloc="24" jdoc="@author Manuel Laflamme @version $Revision: 716 $">
			<const name="serialVersionUID" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.DatabaseUnitException.DatabaseUnitException()" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitException&amp;lt; code&amp;gt; with no detail message and no encapsulated exception.">
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitException.DatabaseUnitException(String)" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitException&amp;lt; code&amp;gt; with the specified detail message and no encapsulated exception.">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitException.DatabaseUnitException(String, Throwable)" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitException&amp;lt; code&amp;gt; with the specified detail message and encapsulated exception.">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitException.DatabaseUnitException(Throwable)" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitException&amp;lt; code&amp;gt; with the encapsulated exception and use string representation as detail message.">
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitException.getException()" access="pub" jdoc="Returns the nested exception or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if none. @deprecated Use {@link #getCause()} to retrieve the nested exception">
			</mth>
		</class>
		<class name="/:org.dbunit.JdbcBasedDBTestCase" intfc="n" abs="y" inn="n" sloc="32" jdoc="TestCase that uses a JdbcDatabaseTester. @author Andres Almiray (aalmiray@users.sourceforge.net) @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 928 $ $Date: 2008-12-28 18:24:41 -0200 (Dom, 28 Dez 2008) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.JdbcBasedDBTestCase.JdbcBasedDBTestCase()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.JdbcBasedDBTestCase.JdbcBasedDBTestCase(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.JdbcBasedDBTestCase.newDatabaseTester()" access="prot" jdoc="Creates a new IDatabaseTester.&amp;lt;br&amp;gt; Default implementation returns a {@link JdbcDatabaseTester} configured with the values returned from {@link #getDriverClass},{@link #getConnectionUrl}, {@link #getUsername} and {@link #getPassword()}. @throws ClassNotFoundException when the driverClass was not found">
			</mth>
			<mth name="/:org.dbunit.JdbcBasedDBTestCase.getConnectionUrl()" access="prot" jdoc="Returns the test connection url.">
			</mth>
			<mth name="/:org.dbunit.JdbcBasedDBTestCase.getDriverClass()" access="prot" jdoc="Returns the JDBC driver classname.">
			</mth>
			<mth name="/:org.dbunit.JdbcBasedDBTestCase.getPassword()" access="prot" jdoc="Returns the password for the connection.&amp;lt;br&amp;gt; Subclasses may override this method to provide a custom password.&amp;lt;br&amp;gt; Default implementations returns null.">
			</mth>
			<mth name="/:org.dbunit.JdbcBasedDBTestCase.getUsername()" access="prot" jdoc="Returns the username for the connection.&amp;lt;br&amp;gt; Subclasses may override this method to provide a custom username.&amp;lt;br&amp;gt; Default implementations returns null.">
			</mth>
		</class>
		<class name="/:org.dbunit.VerifyTableDefinition" intfc="n" abs="n" inn="n" sloc="46" jdoc="Defines a database table to verify (assert on data), specifying include and exclude column filters. @author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<const name="tableName" access="priv" jdoc="The name of the table."/>
			<const name="columnExclusionFilters" access="priv" jdoc="The columns to exclude in table comparisons."/>
			<const name="columnInclusionFilters" access="priv" jdoc="The columns to include in table comparisons."/>
			<mth name="/:org.dbunit.VerifyTableDefinition.VerifyTableDefinition(String, String[])" access="pub" jdoc="Create a valid instance with no include columns specified (meaning include all columns). @param tableThe name of the table - required. @param excludeColumnsThe columns in the table to ignore (filter out) in expected vs actual comparisons; null or empty array to exclude no columns.">
				<param name="table"/>
				<param name="excludeColumns"/>
			</mth>
			<mth name="/:org.dbunit.VerifyTableDefinition.VerifyTableDefinition(String, String[], String[])" access="pub" jdoc="Create a valid instance specifying exclude and include columns. @param tableThe name of the table. @param excludeColumnsThe columns in the table to ignore (filter out) in expected vs actual comparisons; null or empty array to exclude no columns. @param includeColumnsThe columns in the table to include in expected vs actual comparisons; null to include all columns, empty array to include no columns.">
				<param name="table"/>
				<param name="excludeColumns"/>
				<param name="includeColumns"/>
			</mth>
			<mth name="/:org.dbunit.VerifyTableDefinition.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.VerifyTableDefinition.getColumnExclusionFilters()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.VerifyTableDefinition.getColumnInclusionFilters()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.VerifyTableDefinition.toString()" access="pub" jdoc="{@inheritDoc}">
			</mth>
			<mth name="/:org.dbunit.VerifyTableDefinition.arrayToString(String[])" access="prot" jdoc="">
				<param name="array"/>
			</mth>
		</class>
		<class name="/:org.dbunit.DBTestCase" intfc="n" abs="y" inn="n" sloc="20" jdoc="Base testCase for database testing.&amp;lt;br&amp;gt; Subclasses may override {@link #newDatabaseTester()} to plug-in a different implementation of IDatabaseTester.&amp;lt;br&amp;gt; Default implementation uses a {@link PropertiesBasedJdbcDatabaseTester}. @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 928 $ $Date: 2008-12-28 18:24:41 -0200 (Dom, 28 Dez 2008) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.DBTestCase.DBTestCase()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.DBTestCase.DBTestCase(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.DBTestCase.getConnection()" access="prot" jdoc="">
				<comm cntt="Ensure that users have the possibility to configure the connection&amp;apos;s configuration"/>
			</mth>
			<mth name="/:org.dbunit.DBTestCase.newDatabaseTester()" access="prot" jdoc="Creates a new IDatabaseTester. Default implementation returns a {@link PropertiesBasedJdbcDatabaseTester}.">
			</mth>
		</class>
		<class name="/:org.dbunit.JndiDatabaseTester" intfc="n" abs="n" inn="n" sloc="59" jdoc="DatabaseTester that pulls a DataSource from a JNDI location. @author Andres Almiray (aalmiray@users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 983 $ $Date: 2009-03-14 09:01:03 -0300 (SÃ¡b, 14 Mar 2009) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="dataSource" access="priv" jdoc=""/>
			<field name="environment" access="priv" jdoc=""/>
			<field name="initialized" access="priv" jdoc=""/>
			<field name="lookupName" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.JndiDatabaseTester.JndiDatabaseTester(String)" access="pub" jdoc="Creates a JndiDatabaseTester with default JNDI properties. @param lookupName the name of the resource in the JNDI context">
				<param name="lookupName"/>
			</mth>
			<mth name="/:org.dbunit.JndiDatabaseTester.JndiDatabaseTester(Properties, String)" access="pub" jdoc="Creates a JndiDatabaseTester with specific JNDI properties. @param environment A Properties object with JNDI properties. Can be null @param lookupName the name of the resource in the JNDI context">
				<param name="environment"/>
				<param name="lookupName"/>
			</mth>
			<mth name="/:org.dbunit.JndiDatabaseTester.JndiDatabaseTester(Properties, String, String)" access="pub" jdoc="Creates a JndiDatabaseTester with specific JNDI properties. @param environment A Properties object with JNDI properties. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @param lookupName the name of the resource in the JNDI context @param schema The schema name to be used for new dbunit connections. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @since 2.4.5">
				<param name="environment"/>
				<param name="lookupName"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.JndiDatabaseTester.getConnection()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.JndiDatabaseTester.initialize()" access="priv" jdoc="Verifies the configured properties and locates the Datasource through JNDI.&amp;lt;br&amp;gt; This method is called by {@link getConnection} if the tester has not been initialized yet.">
			</mth>
			<mth name="/:org.dbunit.JndiDatabaseTester.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.JdbcDatabaseTester" intfc="n" abs="n" inn="n" sloc="55" jdoc="DatabaseTester that uses JDBC&amp;apos;s Driver Manager to create connections.&amp;lt;br&amp;gt; @author Andres Almiray (aalmiray@users.sourceforge.net) @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 928 $ @since 2.2">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="connectionUrl" access="priv" jdoc=""/>
			<field name="driverClass" access="priv" jdoc=""/>
			<field name="password" access="priv" jdoc=""/>
			<field name="username" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.JdbcDatabaseTester.JdbcDatabaseTester(String, String)" access="pub" jdoc="Creates a new JdbcDatabaseTester with the specified properties.&amp;lt;br&amp;gt; Username and Password are set to null. @param driverClass the classname of the JDBC driver to use @param connectionUrl the connection url @throws ClassNotFoundException If the given &amp;lt;code&amp;gt;driverClass&amp;lt; code&amp;gt; was not found">
				<param name="driverClass"/>
				<param name="connectionUrl"/>
			</mth>
			<mth name="/:org.dbunit.JdbcDatabaseTester.JdbcDatabaseTester(String, String, String, String)" access="pub" jdoc="Creates a new JdbcDatabaseTester with the specified properties. @param driverClass the classname of the JDBC driver to use @param connectionUrl the connection url @param username a username that can has access to the database @param password the user&amp;apos;s password @throws ClassNotFoundException If the given &amp;lt;code&amp;gt;driverClass&amp;lt; code&amp;gt; was not found">
				<param name="driverClass"/>
				<param name="connectionUrl"/>
				<param name="username"/>
				<param name="password"/>
			</mth>
			<mth name="/:org.dbunit.JdbcDatabaseTester.JdbcDatabaseTester(String, String, String, String, String)" access="pub" jdoc="Creates a new JdbcDatabaseTester with the specified properties. @param driverClass the classname of the JDBC driver to use @param connectionUrl the connection url @param username a username that can has access to the database - can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @param password the user&amp;apos;s password - can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @param schema the database schema to be tested - can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @throws ClassNotFoundException If the given &amp;lt;code&amp;gt;driverClass&amp;lt; code&amp;gt; was not found @since 2.4.3">
				<param name="driverClass"/>
				<param name="connectionUrl"/>
				<param name="username"/>
				<param name="password"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.JdbcDatabaseTester.getConnection()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.JdbcDatabaseTester.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.Assertion" intfc="n" abs="n" inn="n" sloc="53" jdoc="Provides static methods for the most common DbUnit assertion needs. Although the methods are static, they rely on a {@link DbUnitAssert} instance to do the work. So, if you need to customize this class behavior, you can create your own {@link DbUnitAssert} extension. @author Manuel Laflamme @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 885 $ $Date: 2008-11-23 09:49:32 -0200 (Dom, 23 Nov 2008) $ @since 1.3 (Mar 22, 2002)">
			<const name="INSTANCE" access="priv" jdoc="Object that will effectively do the assertions."/>
			<mth name="/:org.dbunit.Assertion.Assertion()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEqualsIgnoreCols(IDataSet, IDataSet, String, String[])" access="pub" jdoc="@see DbUnitAssert#assertEqualsIgnoreCols(IDataSet,IDataSet,String,String[])">
				<param name="expectedDataset"/>
				<param name="actualDataset"/>
				<param name="tableName"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEqualsIgnoreCols(ITable, ITable, String[])" access="pub" jdoc="@see DbUnitAssert#assertEqualsIgnoreCols(ITable,ITable,String[])">
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEqualsByQuery(IDataSet, IDatabaseConnection, String, String, String[])" access="pub" jdoc="@see DbUnitAssert#assertEqualsByQuery(IDataSet,IDatabaseConnection,String,String,String[])">
				<param name="expectedDataset"/>
				<param name="connection"/>
				<param name="sqlQuery"/>
				<param name="tableName"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEqualsByQuery(ITable, IDatabaseConnection, String, String, String[])" access="pub" jdoc="@see DbUnitAssert#assertEqualsByQuery(ITable,IDatabaseConnection,String,String,String[])">
				<param name="expectedTable"/>
				<param name="connection"/>
				<param name="tableName"/>
				<param name="sqlQuery"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEquals(IDataSet, IDataSet)" access="pub" jdoc="@see DbUnitAssert#assertEquals(IDataSet,IDataSet)">
				<param name="expectedDataSet"/>
				<param name="actualDataSet"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEquals(IDataSet, IDataSet, FailureHandler)" access="pub" jdoc="@see DbUnitAssert#assertEquals(IDataSet,IDataSet,FailureHandler) @since 2.4">
				<param name="expectedDataSet"/>
				<param name="actualDataSet"/>
				<param name="failureHandler"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEquals(ITable, ITable)" access="pub" jdoc="@see DbUnitAssert#assertEquals(ITable,ITable)">
				<param name="expectedTable"/>
				<param name="actualTable"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEquals(ITable, ITable, Column[])" access="pub" jdoc="@see DbUnitAssert#assertEquals(ITable,ITable,Column[])">
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="additionalColumnInfo"/>
			</mth>
			<mth name="/:org.dbunit.Assertion.assertEquals(ITable, ITable, FailureHandler)" access="pub" jdoc="@see DbUnitAssert#assertEquals(ITable,ITable,FailureHandler) @since 2.4">
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="failureHandler"/>
			</mth>
		</class>
		<class name="/:org.dbunit.JndiBasedDBTestCase" intfc="n" abs="y" inn="n" sloc="21" jdoc="TestCase that uses a JndiDatabaseTester. @author Andres Almiray (aalmiray@users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.JndiBasedDBTestCase.JndiBasedDBTestCase()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.JndiBasedDBTestCase.JndiBasedDBTestCase(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.JndiBasedDBTestCase.newDatabaseTester()" access="prot" jdoc="Creates a new IDatabaseTester.&amp;lt;br&amp;gt; Default implementation returns a {@link JndiDatabaseTester} configured with the values returned from {@link #getJNDIProperties()} and{@link #getLookupName()}.">
			</mth>
			<mth name="/:org.dbunit.JndiBasedDBTestCase.getLookupName()" access="prot" jdoc="Returns the JNDI lookup name for the test DataSource.">
			</mth>
			<mth name="/:org.dbunit.JndiBasedDBTestCase.getJNDIProperties()" access="prot" jdoc="Returns the JNDI properties to use.&amp;lt;br&amp;gt; Subclasses must override this method to provide customized JNDI properties. Default implementation returns an empty Properties object.">
			</mth>
		</class>
		<class name="/:org.dbunit.IDatabaseTester" intfc="y" abs="n" inn="n" sloc="13" jdoc="This interface defines the behavior of a DatabaseTester, which is responsible for adding DBUnit features as composition on existing test cases (instead of extending DBTestCase directly). @author Andres Almiray (aalmiray@users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 954 $ $Date: 2009-02-06 21:11:31 -0200 (Sex, 06 Fev 2009) $ @since 2.2.0">
			<mth name="/:org.dbunit.IDatabaseTester.closeConnection(IDatabaseConnection)" access="pub" jdoc="Close the specified connection. @deprecated since 2.4.4 define a user defined {@link #setOperationListener(IOperationListener)} in advance">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.getConnection()" access="pub" jdoc="Returns the test database connection.">
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.getDataSet()" access="pub" jdoc="Returns the test dataset.">
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.setDataSet(IDataSet)" access="pub" jdoc="Sets the test dataset to use.">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.setSchema(String)" access="pub" jdoc="Sets the schema value. @deprecated since 2.4.3 Should not be used anymore. Every concrete {@link IDatabaseTester} implementation that needs a schema has the possibility to set it somehow in the constructor">
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.setSetUpOperation(DatabaseOperation)" access="pub" jdoc="Sets the DatabaseOperation to call when starting the test.">
				<param name="setUpOperation"/>
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.setTearDownOperation(DatabaseOperation)" access="pub" jdoc="Sets the DatabaseOperation to call when ending the test.">
				<param name="tearDownOperation"/>
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.onSetup()" access="pub" jdoc="TestCases must call this method inside setUp()">
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.onTearDown()" access="pub" jdoc="TestCases must call this method inside tearDown()">
			</mth>
			<mth name="/:org.dbunit.IDatabaseTester.setOperationListener(IOperationListener)" access="pub" jdoc="@param operationListener The operation listener that is invoked on specific events in the {@link IDatabaseTester}. @since 2.4.4">
				<param name="operationListener"/>
			</mth>
		</class>
		<class name="/:org.dbunit.DefaultPrepAndExpectedTestCase" intfc="n" abs="n" inn="n" sloc="223" jdoc="Test case base class supporting prep data and expected data. Prep data is the data needed for the test to run. Expected data is the data needed to compare if the test ran successfully. Use this class in two ways: &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;Dependency inject it as its interface into a test class.&amp;lt; li&amp;gt; &amp;lt;p&amp;gt; Configure a bean of its interface, injecting a IDatabaseTester and a DataFileLoader using the databaseTester and a dataFileLoader properties. &amp;lt; p&amp;gt; &amp;lt;li&amp;gt;Extend it in a test class.&amp;lt; li&amp;gt; &amp;lt;p&amp;gt; Obtain IDatabaseTester and DataFileLoader instances (possibly dependency injecting them into the test class) and set them accordingly, probably in a setup type of method, such as: &amp;lt;pre&amp;gt; &amp;#064;Before public void setDbunitTestDependencies() { setDatabaseTester(databaseTester); setDataFileLoader(dataFileLoader); } &amp;lt; pre&amp;gt; &amp;lt; p&amp;gt; &amp;lt; ol&amp;gt; To setup, execute, and clean up tests, call the configureTest(), preTest(), and postTest() methods. Note there is a preTest() convenience method that takes the same parameters as the configureTest() method; use it instead of using both configureTest() and preTest(). Where the test case calls them depends on data needs: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;For the whole test case, i.e. in setUp() and tearDown() or &amp;#064;Before and &amp;#064;After.&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;In each test method.&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;Or some combination of both test case setup teardown and test methods.&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; &amp;lt;h4&amp;gt;When each test method requires different prep and expected data&amp;lt; h4&amp;gt; If each test method requires its own prep and expected data, then the test methods will look something like the following: &amp;lt;pre&amp;gt; &amp;#064;Autowired private PrepAndExpectedTestCase tc; &amp;#064;Test public void testExample() throws Exception { String[] prepDataFiles = {}; define prep files String[] expectedDataFiles = {}; define expected files VerifyTableDefinition[] tables = {}; define tables to verify tc.preTest(tables, prepDataFiles, expectedDataFiles); execute test tc.postTest(); } &amp;lt; pre&amp;gt; &amp;lt;h4&amp;gt;When all test methods share the same prep and or expected data&amp;lt; h4&amp;gt; If each test method can share all of the prep and or expected data, then use setUp() for the configureTest() and preTest() calls and tearDown() for the postTest() call. The methods will look something like the following: &amp;lt;pre&amp;gt; &amp;#064;Override protected void setUp() throws Exception { setDatabaseTester(databaseTester); setDataFileLoader(dataFileLoader); String[] prepDataFiles = {}; define prep files String[] expectedDataFiles = {}; define expected files VerifyTableDefinition[] tables = {}; define tables to verify preTest(tables, prepDataFiles, expectedDataFiles); call this if overriding setUp() and databaseTester &amp;amp; dataFileLoader are already set. super.setUp(); } &amp;#064;Override protected void tearDown() throws Exception { postTest(); super.tearDown(); } &amp;#064;Test public void testExample() throws Exception { execute test } &amp;lt; pre&amp;gt; Note that it is unlikely that all test methods can share the same expected data. &amp;lt;h4&amp;gt;Sharing common (but not all) prep or expected data among test methods.&amp;lt; h4&amp;gt; Put common data in one or more files and pass the needed ones in the correct data file array. &amp;lt;h4&amp;gt;Notes&amp;lt; h4&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;For additional examples, refer to the ITs (listed in the See Also section).&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;To change the setup or teardown operation (e.g. change the teardown to org.dbunit.operation.DatabaseOperation.DELETE_ALL), set the setUpOperation or tearDownOperation property on the databaseTester.&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;To set DatabaseConfig features properties, one way is to extend this class and override the setUpDatabaseConfig(DatabaseConfig config) method from DatabaseTestCase.&amp;lt; li&amp;gt; &amp;lt; ol&amp;gt; @see org.dbunit.DefaultPrepAndExpectedTestCaseDiIT @see org.dbunit.DefaultPrepAndExpectedTestCaseExtIT @author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<const name="LOG" access="priv" jdoc=""/>
			<field name="databaseTester" access="priv" jdoc=""/>
			<field name="dataFileLoader" access="priv" jdoc=""/>
			<field name="prepDs" access="priv" jdoc=""/>
			<field name="expectedDs" access="priv" jdoc=""/>
			<field name="tableDefs" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.DefaultPrepAndExpectedTestCase()" access="pub" jdoc="Create new instance.">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.DefaultPrepAndExpectedTestCase(DataFileLoader, IDatabaseTester)" access="pub" jdoc="Create new instance with specified dataFileLoader and databasetester. @param dataFileLoaderLoad to use for loading the data files. @param databaseTesterTester to use for database manipulation.">
				<param name="dataFileLoader"/>
				<param name="databaseTester"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.DefaultPrepAndExpectedTestCase(String)" access="pub" jdoc="Create new instance with specified test case name. @param nameThe test case name.">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.newDatabaseTester()" access="pub" jdoc="{@inheritDoc} This implementation returns the databaseTester set by the test.">
				<comm cntt="questionable, but there is not a &amp;quot;setter&amp;quot; for any parent..."/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.getDataSet()" access="pub" jdoc="{@inheritDoc} Returns the prep dataset.">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.configureTest(VerifyTableDefinition[], String[], String[])" access="pub" jdoc="{@inheritDoc}">
				<param name="tables"/>
				<param name="prepDataFiles"/>
				<param name="expectedDataFiles"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.preTest()" access="pub" jdoc="{@inheritDoc}">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.preTest(VerifyTableDefinition[], String[], String[])" access="pub" jdoc="{@inheritDoc}">
				<param name="tables"/>
				<param name="prepDataFiles"/>
				<param name="expectedDataFiles"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.postTest()" access="pub" jdoc="{@inheritDoc}">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.postTest(boolean)" access="pub" jdoc="{@inheritDoc}">
				<comm cntt="it is deliberate to have cleanup exceptions shadow verify"/>
				<comm cntt="failures so user knows db is probably in unknown state (for"/>
				<comm cntt="those not using an in-memory db or transaction rollback),"/>
				<comm cntt="otherwise would mask probable cause of subsequent test failures"/>
				<param name="verifyData"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.cleanupData()" access="pub" jdoc="{@inheritDoc}">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.setupData()" access="pub" jdoc="Use the provided databaseTester to prep the database with the provided prep dataset. See {@link org.dbunit.IDatabaseTester#onSetup()}. @throws Exception">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.verifyData()" access="pub" jdoc="For the provided VerifyTableDefinitions, verify each table&amp;apos;s actual results are as expected. Uses the connection from the provided databaseTester. @throws Exception">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.verifyData(ITable, ITable, String[], String[])" access="pub" jdoc="For the specified expected and actual tables (and excluding and including the specified columns), verify the actual data is as expected. @param expectedTableThe expected table to compare the actual table to. @param actualTableThe actual table to compare to the expected table. @param excludeColumnsThe column names to exclude from comparison. See{@link org.dbunit.dataset.filter.DefaultColumnFilter#excludeColumn(String)}. @param includeColumnsThe column names to only include in comparison. See{@link org.dbunit.dataset.filter.DefaultColumnFilter#includeColumn(String)}. @throws DatabaseUnitException">
				<comm cntt="Filter out the columns from the expected and actual results"/>
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="excludeColumns"/>
				<param name="includeColumns"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.makeCompositeDataSet(String[])" access="pub" jdoc="Make a &amp;lt;code&amp;gt;IDataSet&amp;lt; code&amp;gt; from the specified files. @param dataFilesRepresents the array of dbUnit data files. @return The composite dataset. @throws DataSetExceptionOn dbUnit errors.">
				<param name="dataFiles"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.applyColumnFilters(ITable, String[], String[])" access="pub" jdoc="Apply the specified exclude and include column filters to the specified table. @param tableThe table to apply the filters to. @param excludeColumnsThe exclude filters; use null or empty array to mean exclude none. @param includeColumnsThe include filters; use null to mean include all. @return The filtered table. @throws DataSetException">
				<comm cntt="note: dbunit interprets an empty inclusion filter array as one"/>
				<comm cntt="not wanting to compare anything!"/>
				<param name="table"/>
				<param name="excludeColumns"/>
				<param name="includeColumns"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.getPrepDataset()" access="pub" jdoc="{@inheritDoc}">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.getExpectedDataset()" access="pub" jdoc="{@inheritDoc}">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.getDatabaseTester()" access="pub" jdoc="Get the databaseTester. @see {@link databaseTester}. @return The databaseTester.">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.setDatabaseTester(IDatabaseTester)" access="pub" jdoc="Set the databaseTester. @see {@link databaseTester}. @param databaseTesterThe databaseTester to set.">
				<param name="databaseTester"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.getDataFileLoader()" access="pub" jdoc="Get the dataFileLoader. @see {@link dataFileLoader}. @return The dataFileLoader.">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.setDataFileLoader(DataFileLoader)" access="pub" jdoc="Set the dataFileLoader. @see {@link dataFileLoader}. @param dataFileLoaderThe dataFileLoader to set.">
				<param name="dataFileLoader"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.setPrepDs(IDataSet)" access="pub" jdoc="Set the prepDs. @see {@link prepDs}. @param prepDsThe prepDs to set.">
				<param name="prepDs"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.setExpectedDs(IDataSet)" access="pub" jdoc="Set the expectedDs. @see {@link expectedDs}. @param expectedDsThe expectedDs to set.">
				<param name="expectedDs"/>
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.getTableDefs()" access="pub" jdoc="Get the tableDefs. @see {@link tableDefs}. @return The tableDefs.">
			</mth>
			<mth name="/:org.dbunit.DefaultPrepAndExpectedTestCase.setTableDefs(VerifyTableDefinition[])" access="pub" jdoc="Set the tableDefs. @see {@link tableDefs}. @param tableDefsThe tableDefs to set.">
				<param name="tableDefs"/>
			</mth>
		</class>
		<class name="/:org.dbunit.DefaultOperationListener" intfc="n" abs="n" inn="n" sloc="23" jdoc="Default implementation of the {@link IOperationListener}. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: jeffjensen $ @version $Revision: 1155 $ $Date: 2010-02-07 22:52:07 -0200 (Dom, 07 Fev 2010) $ @since 2.4.4">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.DefaultOperationListener.connectionRetrieved(IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="Is by default a no-op"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.DefaultOperationListener.operationSetUpFinished(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.DefaultOperationListener.operationTearDownFinished(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.DefaultOperationListener.closeConnection(IDatabaseConnection)" access="priv" jdoc="">
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.DatabaseUnitRuntimeException" intfc="n" abs="n" inn="n" sloc="24" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 795 $ $Date: 2008-08-19 17:52:47 -0300 (Ter, 19 Ago 2008) $ @since 1.0">
			<const name="serialVersionUID" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.DatabaseUnitRuntimeException.DatabaseUnitRuntimeException()" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitRuntimeException&amp;lt; code&amp;gt; with no specified detail message and no encapsulated exception.">
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitRuntimeException.DatabaseUnitRuntimeException(String)" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitRuntimeException&amp;lt; code&amp;gt; with the specified detail message and no encapsulated exception. @param msg Exception message">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitRuntimeException.DatabaseUnitRuntimeException(String, Throwable)" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitRuntimeException&amp;lt; code&amp;gt; with the specified detail message and encapsulated exception. @param msg @param cause The cause of this exception">
				<param name="msg"/>
				<param name="cause"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitRuntimeException.DatabaseUnitRuntimeException(Throwable)" access="pub" jdoc="Constructs an &amp;lt;code&amp;gt;DatabaseUnitRuntimeException&amp;lt; code&amp;gt; with the encapsulated exception and use its message as detail message. @param cause The cause of this exception">
				<param name="cause"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseUnitRuntimeException.getException()" access="pub" jdoc="Returns the encapsulated exception or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if none. @deprecated Use {@link Exception#getCause()} instead">
			</mth>
		</class>
		<class name="/:org.dbunit.DatabaseTestCase" intfc="n" abs="y" inn="n" sloc="84" jdoc="Convenience class for writing JUnit tests with dbunit easily. &amp;lt;br &amp;gt; Note that there are some even more convenient classes available such as {@link DBTestCase}. @author Manuel Laflamme @version $Revision: 954 $ @since 1.0 (Feb 17, 2002)">
			<comm cntt=""/>
			<comm cntt="TestCase class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="tester" access="priv" jdoc=""/>
			<field name="operationListener" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.DatabaseTestCase.DatabaseTestCase()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.DatabaseTestCase(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.getConnection()" access="prot" jdoc="Returns the test database connection.">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.getDataSet()" access="prot" jdoc="Returns the test dataset.">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.newDatabaseTester()" access="prot" jdoc="Creates a IDatabaseTester for this testCase.&amp;lt;br&amp;gt; A {@link DefaultDatabaseTester} is used by default. @throws Exception">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.setUpDatabaseConfig(DatabaseConfig)" access="prot" jdoc="Designed to be overridden by subclasses in order to set additional configuration parameters for the {@link IDatabaseConnection}. @param config The settings of the current {@link IDatabaseConnection} to be configured">
				<comm cntt="Designed to be overridden."/>
				<param name="config"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.getDatabaseTester()" access="prot" jdoc="Gets the IDatabaseTester for this testCase.&amp;lt;br&amp;gt; If the IDatabaseTester is not set yet, this method calls newDatabaseTester() to obtain a new instance. @throws Exception">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.closeConnection(IDatabaseConnection)" access="prot" jdoc="Close the specified connection. Override this method of you want to keep your connection alive between tests. @deprecated since 2.4.4 define a user defined {@link #getOperationListener()} in advance">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.getSetUpOperation()" access="prot" jdoc="Returns the database operation executed in test setup.">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.getTearDownOperation()" access="prot" jdoc="Returns the database operation executed in test cleanup.">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.setUp()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.tearDown()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.DatabaseTestCase.getOperationListener()" access="prot" jdoc="@return The {@link IOperationListener} to be used by the {@link IDatabaseTester}. @since 2.4.4">
				<comm cntt="When a new connection has been created then invoke the setUp method"/>
				<comm cntt="so that user defined DatabaseConfig parameters can be set."/>
			</mth>
		</class>
		<class name="/:org.dbunit.DataSourceDatabaseTester" intfc="n" abs="n" inn="n" sloc="29" jdoc="DatabaseTester that uses a {@link DataSource} to create connections. @author Andres Almiray (aalmiray@users.sourceforge.net) @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 983 $ $Date: 2009-03-14 09:01:03 -0300 (SÃ¡b, 14 Mar 2009) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="dataSource" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.DataSourceDatabaseTester.DataSourceDatabaseTester(DataSource)" access="pub" jdoc="Creates a new DataSourceDatabaseTester with the specified DataSource. @param dataSource the DataSource to pull connections from">
				<param name="dataSource"/>
			</mth>
			<mth name="/:org.dbunit.DataSourceDatabaseTester.DataSourceDatabaseTester(DataSource, String)" access="pub" jdoc="Creates a new DataSourceDatabaseTester with the specified DataSource and schema name. @param dataSource the DataSource to pull connections from @param schema The schema name to be used for new dbunit connections @since 2.4.5">
				<param name="dataSource"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.DataSourceDatabaseTester.getConnection()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ant">
		<class name="/:org.dbunit.ant.Table" intfc="n" abs="n" inn="n" sloc="24" jdoc="The &amp;lt;code&amp;gt;Table&amp;lt; code&amp;gt; class is just a step placeholder for a table name within an &amp;lt;code&amp;gt;Export&amp;lt; code&amp;gt;. @author Timothy Ruppert @author Ben Cox @version $Revision: 672 $ @since Jun 10, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="name" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.Table.Table()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Table.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Table.setName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.ant.Table.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ant.DbUnitTaskStep" intfc="y" abs="n" inn="n" sloc="5" jdoc="The &amp;lt;code&amp;gt;DbUnitTaskStep&amp;lt; code&amp;gt; interface allows the execute method to be called on all elements nested under &amp;lt;code&amp;gt;DbUnitTask&amp;lt; code&amp;gt;. @author Timothy Ruppert @author Ben Cox @version $Revision: 766 $ @since Jun 10, 2002">
			<mth name="/:org.dbunit.ant.DbUnitTaskStep.execute(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTaskStep.getLogMessage()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ant.DbConfig" intfc="n" abs="n" inn="n" sloc="42" jdoc="The database configuration for the ant task. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1107 $ $Date: 2009-11-14 12:13:54 -0200 (SÃ¡b, 14 Nov 2009) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="properties" access="priv" jdoc=""/>
			<field name="features" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.DbConfig.DbConfig()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.DbConfig.addProperty(Property)" access="pub" jdoc="">
				<param name="property"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbConfig.addFeature(Feature)" access="pub" jdoc="">
				<param name="feature"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbConfig.copyTo(DatabaseConfig)" access="pub" jdoc="Copies the parameters set in this configuration via ant into the given{@link DatabaseConfig} that is used by the dbunit connection. @param config The configuration object to be initialized updated @throws DatabaseUnitException">
				<comm cntt="Copy the properties into java.util.Properties"/>
				<param name="config"/>
			</mth>
		<class name="/:org.dbunit.ant.DbConfig$Feature" intfc="n" abs="n" inn="y" sloc="17" jdoc="@author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1107 $ $Date: 2009-11-14 12:13:54 -0200 (SÃ¡b, 14 Nov 2009) $ @since 2.4.0">
			<field name="name" access="priv" jdoc=""/>
			<field name="value" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.DbConfig$Feature.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.DbConfig$Feature.setName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbConfig$Feature.isValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.DbConfig$Feature.setValue(boolean)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.ant.Compare" intfc="n" abs="n" inn="n" sloc="107" jdoc="The &amp;lt;code&amp;gt;Compare&amp;lt; code&amp;gt; class is the step that compare the content of the database against the specified dataset. @author Manuel Laflamme @version $Revision: 838 $ @since Apr 3, 2004 @see DbUnitTaskStep">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DEFAULT_FORMAT" access="priv" jdoc=""/>
			<field name="_format" access="priv" jdoc=""/>
			<field name="_src" access="priv" jdoc=""/>
			<field name="_tables" access="priv" jdoc=""/>
			<field name="_sort" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.Compare.getSrc()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Compare.setSrc(File)" access="pub" jdoc="">
				<param name="src"/>
			</mth>
			<mth name="/:org.dbunit.ant.Compare.setSort(boolean)" access="pub" jdoc="">
				<param name="sort"/>
			</mth>
			<mth name="/:org.dbunit.ant.Compare.getFormat()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Compare.setFormat(String)" access="pub" jdoc="">
				<comm cntt="Check if the given format is accepted"/>
				<comm cntt="If we get here the given format is a valid data format"/>
				<param name="format"/>
			</mth>
			<mth name="/:org.dbunit.ant.Compare.getTables()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Compare.addTable(Table)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.ant.Compare.addQuery(Query)" access="pub" jdoc="">
				<param name="query"/>
			</mth>
			<mth name="/:org.dbunit.ant.Compare.execute(IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="No tables specified, assume must compare all tables from"/>
				<comm cntt="expected dataset"/>
				<comm cntt="Only compare columns present in expected table. Extra columns"/>
				<comm cntt="are filtered out from actual database table."/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ant.Compare.getLogMessage()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Compare.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ant.Export" intfc="n" abs="n" inn="n" sloc="166" jdoc="The &amp;lt;code&amp;gt;Export&amp;lt; code&amp;gt; class is the step that facilitates exporting the contents of the database and or it&amp;apos;s corresponding DTD to a file. The export can be performed on a full dataset or a partial one if specific table names are identified. @author Timothy Ruppert @author Ben Cox @version $Revision: 1084 $ @since Jun 10, 2002 @see DbUnitTaskStep">
			<comm cntt="if no encoding set by script than the default encoding (UTF-8) of the wrietr is used"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_dest" access="priv" jdoc=""/>
			<field name="_format" access="priv" jdoc=""/>
			<field name="_doctype" access="priv" jdoc=""/>
			<field name="_encoding" access="priv" jdoc=""/>
			<field name="_tables" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.Export.Export()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Export.getAbsolutePath(File)" access="priv" jdoc="">
				<param name="filename"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.getDest()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Export.getFormat()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Export.getTables()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Export.setDest(File)" access="pub" jdoc="">
				<param name="dest"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.setFormat(String)" access="pub" jdoc="">
				<param name="format"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.getEncoding()" access="pub" jdoc="Encoding for XML-Output @return Returns the encoding.">
			</mth>
			<mth name="/:org.dbunit.ant.Export.setEncoding(String)" access="pub" jdoc="">
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.addTable(Table)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.addQuery(Query)" access="pub" jdoc="">
				<param name="query"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.addQuerySet(QuerySet)" access="pub" jdoc="">
				<param name="querySet"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.getDoctype()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Export.setDoctype(String)" access="pub" jdoc="">
				<param name="doctype"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.execute(IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="Write the dataset"/>
				<comm cntt="TODO Should DTD also support encoding? It is basically an XML file..."/>
				<comm cntt=", getEncoding());"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.getExportDataSet(IDatabaseConnection)" access="prot" jdoc="Creates the dataset that is finally used for the export @param connection @return The final dataset used for the export @throws DatabaseUnitException @throws SQLException">
				<comm cntt="Use topologically sorted database"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ant.Export.getLogMessage()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Export.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ant.Query" intfc="n" abs="n" inn="n" sloc="35" jdoc="The &amp;lt;code&amp;gt;Query&amp;lt; code&amp;gt; class is just a step placeholder for a table name within an &amp;lt;code&amp;gt;Export&amp;lt; code&amp;gt;. @author Eric Pugh @version $Revision: 672 $ @since Dec 10, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="name" access="priv" jdoc=""/>
			<field name="sql" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.Query.Query()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Query.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Query.setName(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.ant.Query.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Query.getSql()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Query.setSql(String)" access="pub" jdoc="">
				<param name="sql"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ant.AbstractStep" intfc="n" abs="y" inn="n" sloc="170" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1084 $ $Date: 2009-10-25 08:35:42 -0200 (Dom, 25 Out 2009) $ @since 2.1 (Apr 3, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="FORMAT_FLAT" access="pub" jdoc=""/>
			<const name="FORMAT_XML" access="pub" jdoc=""/>
			<const name="FORMAT_DTD" access="pub" jdoc=""/>
			<const name="FORMAT_CSV" access="pub" jdoc=""/>
			<const name="FORMAT_XLS" access="pub" jdoc=""/>
			<field name="ordered" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.AbstractStep.getDatabaseDataSet(IDatabaseConnection, List, boolean)" access="prot" jdoc="">
				<comm cntt="Setup the ResultSet table factory"/>
				<comm cntt="Retrieve the complete database if no tables or queries specified."/>
				<param name="connection"/>
				<param name="tables"/>
				<param name="forwardonly"/>
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.createQueryDataSet(List, IDatabaseConnection)" access="priv" jdoc="">
				<param name="tables"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.getSrcDataSet(File, String, boolean)" access="prot" jdoc="">
				<param name="src"/>
				<param name="format"/>
				<param name="forwardonly"/>
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.isDataFormat(String)" access="pub" jdoc="Checks if the given format is a format which contains tabular data. @param format The format to check @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the given format is a data format. A data format is a format which holds tabular data that can be loaded via dbunit. An example for a data format is &amp;quot;xml&amp;quot; or &amp;quot;flat&amp;quot;. A non-data format is &amp;quot;dtd&amp;quot; which holds only metadata information. @since 2.4">
				<param name="format"/>
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.checkDataFormat(String)" access="prot" jdoc="Checks if the given data format is a valid one according to the method {@link #isDataFormat(String)}. If it is not an{@link IllegalArgumentException} is thrown. @param format The format to check @throws IllegalArgumentException If the given format is not a valid data format @since 2.4">
				<param name="format"/>
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.getInputSource(File)" access="pub" jdoc="Creates and returns an {@link InputSource} @param file The file for which an {@link InputSource} should be created @return The input source for the given file @throws MalformedURLException">
				<param name="file"/>
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.isOrdered()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.setOrdered(boolean)" access="pub" jdoc="">
				<param name="ordered"/>
			</mth>
			<mth name="/:org.dbunit.ant.AbstractStep.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ant.DbUnitTask" intfc="n" abs="n" inn="n" sloc="327" jdoc="&amp;lt;code&amp;gt;DbUnitTask&amp;lt; code&amp;gt; is the task definition for an Ant interface to &amp;lt;code&amp;gt;DbUnit&amp;lt; code&amp;gt;. DbUnit is a JUnit extension which sets your database to a known state before executing your tasks. @author Timothy Ruppert @author Ben Cox @version $Revision: 1107 $ @since Jun 10, 2002 @see org.apache.tools.ant.Task">
			<comm cntt="public void setDbConfig(DbConfig dbConfig)"/>
			<comm cntt="{"/>
			<comm cntt="logger.debug(&amp;quot;setDbConfig(dbConfig={}) - start&amp;quot;, dbConfig);"/>
			<comm cntt="this.dbConfig = dbConfig;"/>
			<comm cntt="}"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="conn" access="priv" jdoc="Database connection"/>
			<field name="driver" access="priv" jdoc="DB driver."/>
			<field name="url" access="priv" jdoc="DB url."/>
			<field name="userId" access="priv" jdoc="User name."/>
			<field name="password" access="priv" jdoc="Password"/>
			<field name="schema" access="priv" jdoc="DB schema."/>
			<field name="steps" access="priv" jdoc="Steps"/>
			<field name="classpath" access="priv" jdoc=""/>
			<field name="loader" access="priv" jdoc=""/>
			<field name="dbConfig" access="priv" jdoc="DB configuration child element to configure {@link DatabaseConfig} properties in a generic way."/>
			<field name="useQualifiedTableNames" access="priv" jdoc="Flag for using the qualified table names. @deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<field name="supportBatchStatement" access="priv" jdoc="Flag for using batched statements. @deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<field name="datatypeWarning" access="priv" jdoc="Flag for datatype warning. @deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<field name="escapePattern" access="priv" jdoc="@deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<field name="dataTypeFactory" access="priv" jdoc="@deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<field name="batchSize" access="priv" jdoc="@deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<field name="fetchSize" access="priv" jdoc="@deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<field name="skipOracleRecycleBinTables" access="priv" jdoc="@deprecated since 2.4. Use {@link #dbConfig} instead. Only here because of backwards compatibility should be removed in the next major release."/>
			<mth name="/:org.dbunit.ant.DbUnitTask.setDriver(String)" access="pub" jdoc="Set the JDBC driver to be used.">
				<param name="driver"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setUrl(String)" access="pub" jdoc="Set the DB connection url.">
				<param name="url"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setUserid(String)" access="pub" jdoc="Set the user name for the DB connection.">
				<param name="userId"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setPassword(String)" access="pub" jdoc="Set the password for the DB connection.">
				<param name="password"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setSchema(String)" access="pub" jdoc="Set the schema for the DB connection.">
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setUseQualifiedTableNames(Boolean)" access="pub" jdoc="Set the flag for using the qualified table names.">
				<param name="useQualifiedTableNames"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setSupportBatchStatement(Boolean)" access="pub" jdoc="Set the flag for supporting batch statements. NOTE: This property cannot be used to force the usage of batch statement if your database does not support it.">
				<param name="supportBatchStatement"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setDatatypeWarning(Boolean)" access="pub" jdoc="">
				<param name="datatypeWarning"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setDatatypeFactory(String)" access="pub" jdoc="">
				<param name="datatypeFactory"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setEscapePattern(String)" access="pub" jdoc="">
				<param name="escapePattern"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.getDbConfig()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.addDbConfig(DbConfig)" access="pub" jdoc="">
				<param name="dbConfig"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setClasspath(Path)" access="pub" jdoc="Set the classpath for loading the driver.">
				<param name="classpath"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.createClasspath()" access="pub" jdoc="Create the classpath for loading the driver.">
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setClasspathRef(Reference)" access="pub" jdoc="Set the classpath for loading the driver using the classpath reference.">
				<param name="r"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.getSteps()" access="pub" jdoc="Gets the Steps.">
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.addOperation(Operation)" access="pub" jdoc="Adds an Operation.">
				<param name="operation"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.addCompare(Compare)" access="pub" jdoc="Adds a Compare to the steps List.">
				<param name="compare"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.addExport(Export)" access="pub" jdoc="Adds an Export to the steps List.">
				<param name="export"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.getBatchSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setBatchSize(String)" access="pub" jdoc="sets the size of batch inserts. @param batchSize">
				<param name="batchSize"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.getFetchSize()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setFetchSize(String)" access="pub" jdoc="">
				<param name="fetchSize"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.setSkipOracleRecycleBinTables(Boolean)" access="pub" jdoc="">
				<param name="skipOracleRecycleBinTables"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.execute()" access="pub" jdoc="Load the step and then execute it">
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.createConnection()" access="prot" jdoc="">
				<comm cntt="Instantiate JDBC driver"/>
				<comm cntt="Driver doesn&amp;apos;t understand the URL"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.createDatabaseConnection(Connection, String)" access="prot" jdoc="Creates the dbunit connection using the two given arguments. The configuration properties of the dbunit connection are initialized using the fields of this class. @param jdbcConnection @param dbSchema @return The dbunit connection">
				<comm cntt="Override the default resultset table factory"/>
				<comm cntt="For backwards compatibility (old mode overrides the new one) copy the other attributes to the config"/>
				<param name="jdbcConnection"/>
				<param name="dbSchema"/>
			</mth>
			<mth name="/:org.dbunit.ant.DbUnitTask.copyAttributes(DatabaseConfig)" access="priv" jdoc="@param config @deprecated since 2.4. Only here because of backwards compatibility should be removed in the next major release.">
				<comm cntt="Setup data type factory"/>
				<param name="config"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ant.QuerySet" intfc="n" abs="n" inn="n" sloc="78" jdoc="This element is a container for Queries. It facilitates reuse through references. Using Ant 1.6 and greater, references can be defined in a single build file and &amp;lt;i&amp;gt;import&amp;lt; i&amp;gt;ed into many others. An example of where this is useful follows: &amp;lt;p&amp;gt; In our database we have INDIVIDUALS which must have an associated NAME_INFO and at least one IND_ADDRESS. The developer creating a dataset for his her tests probably won&amp;apos;t know all the details of what relationships are expected, and if he did, its an error prone and repetitive task to create the correct SQL for entities in each dataset. Missing a related table, not only creates invalid data for your tests, but also is likely to cause DBUnit setUp() failures from foreign key constraint violation errors. (example: If a previous test had inserted INDIVIDUALS and NAME_INFO and my test tries to delete only the INDIVIDUALS, the NAME_INFO.IND_ID constraint would be violated) &amp;lt;p&amp;gt; &amp;lt;p&amp;gt; Each queryset is internally converted to a &amp;lt;code&amp;gt;QueryDataSet&amp;lt; code&amp;gt; and then combined using a &amp;lt;code&amp;gt;CompositeDataSet&amp;lt; code&amp;gt;. This means that you can use more than one &amp;lt;code&amp;gt;query&amp;lt; code&amp;gt; element for any given table provided they are nested within separate &amp;lt;code&amp;gt;queryset&amp;lt; code&amp;gt;s. &amp;lt;p&amp;gt; Usage: &amp;lt;pre&amp;gt; &amp;lt;!-- ======== Define the reusable reference ========== --&amp;gt; &amp;lt;queryset id=&amp;quot;individuals&amp;quot;&amp;gt; &amp;lt;query name=&amp;quot;INDIVIDUALS&amp;quot; sql=&amp;quot; SELECT FROM INDIVIDUALS WHERE IND_ID IN (@subQuery@)&amp;quot; &amp;gt; &amp;lt;query name=&amp;quot;NAME_INFO&amp;quot; sql=&amp;quot; SELECT B. FROM INDIVIDUALS A, NAME_INFO B WHERE A.IND_ID IN (@subQuery@) AND B.IND_ID = A.IND_ID&amp;quot; &amp;gt; &amp;lt;query name=&amp;quot;IND_ADDRESSES&amp;quot; sql=&amp;quot; SELECT B. FROM INDIVIDUALS A, IND_ADDRESSES B WHERE A.IND_ID IN (@subQuery@) AND B.IND_ID = A.IND_ID&amp;quot; &amp;gt; &amp;lt; queryset&amp;gt; &amp;lt;!-- ========= Use the reference ====================== --&amp;gt; &amp;lt;dbunit driver=&amp;quot;${jdbcDriver}&amp;quot; url=&amp;quot;${jdbcURL}&amp;quot; userid=&amp;quot;${jdbcUser}&amp;quot; password=&amp;quot;${jdbcPassword}&amp;quot;&amp;gt; &amp;lt;export dest=&amp;quot;${dest}&amp;quot;&amp;gt; &amp;lt;queryset refid=&amp;quot;individuals&amp;quot;&amp;gt; &amp;lt;filterset&amp;gt; &amp;lt;filter token=&amp;quot;subQuery&amp;quot; value=&amp;quot; SELECT IND_ID FROM INDIVIDUALS WHERE USER_NAME = &amp;apos;UNKNOWN&amp;apos;&amp;quot; &amp;gt; &amp;lt; filterset&amp;gt; &amp;lt; queryset&amp;gt; &amp;lt; export&amp;gt; &amp;lt; dbunit&amp;gt; &amp;lt; pre&amp;gt; @author Lenny Marks lenny@aps.org @author Last changed by: $Author: gommma $ @version $Revision: 852 $ $Date: 2008-11-01 08:38:03 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2.0 (Sep. 13 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="id" access="priv" jdoc=""/>
			<field name="refid" access="priv" jdoc=""/>
			<field name="queries" access="priv" jdoc=""/>
			<field name="filterSets" access="priv" jdoc=""/>
			<field name="ERR_MSG" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.QuerySet.QuerySet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.addQuery(Query)" access="pub" jdoc="">
				<param name="query"/>
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.addFilterSet(FilterSet)" access="pub" jdoc="">
				<param name="filterSet"/>
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.getId()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.getRefid()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.setId(String)" access="pub" jdoc="">
				<param name="string"/>
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.setRefid(String)" access="pub" jdoc="">
				<param name="string"/>
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.getQueries()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.replaceTokens(Query)" access="priv" jdoc="">
				<param name="query"/>
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.copyQueriesFrom(QuerySet)" access="pub" jdoc="">
				<param name="referenced"/>
			</mth>
			<mth name="/:org.dbunit.ant.QuerySet.getQueryDataSet(IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="incorporate queries from referenced query-set"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ant.Operation" intfc="n" abs="n" inn="n" sloc="143" jdoc="The &amp;lt;code&amp;gt;Operation&amp;lt; code&amp;gt; class is the step that defines which operation will be performed in the execution of the &amp;lt;code&amp;gt;DbUnitTask&amp;lt; code&amp;gt; task. @author Timothy Ruppert @author Ben Cox @version $Revision: 1088 $ @since Jun 10, 2002 @see org.dbunit.ant.DbUnitTaskStep">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DEFAULT_FORMAT" access="priv" jdoc=""/>
			<field name="_type" access="prot" jdoc=""/>
			<field name="_format" access="priv" jdoc=""/>
			<field name="_src" access="priv" jdoc=""/>
			<field name="_transaction" access="priv" jdoc=""/>
			<field name="_operation" access="priv" jdoc=""/>
			<field name="_forwardOperation" access="priv" jdoc=""/>
			<field name="_nullToken" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ant.Operation.getSrc()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Operation.setSrc(File)" access="pub" jdoc="">
				<param name="src"/>
			</mth>
			<mth name="/:org.dbunit.ant.Operation.getFormat()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Operation.setFormat(String)" access="pub" jdoc="">
				<comm cntt="Check if the given format is accepted"/>
				<comm cntt="If we get here the given format is a valid data format"/>
				<param name="format"/>
			</mth>
			<mth name="/:org.dbunit.ant.Operation.isTransaction()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Operation.setTransaction(boolean)" access="pub" jdoc="">
				<param name="transaction"/>
			</mth>
			<mth name="/:org.dbunit.ant.Operation.getNullToken()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Operation.setNullToken(String)" access="pub" jdoc="">
				<param name="nullToken"/>
			</mth>
			<mth name="/:org.dbunit.ant.Operation.getDbOperation()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Operation.getType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Operation.setType(String)" access="pub" jdoc="">
				<param name="type"/>
			</mth>
			<mth name="/:org.dbunit.ant.Operation.execute(IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="TODO This is not very nice and the design should be reviewed but it works for now (gommma)"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ant.Operation.getLogMessage()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ant.Operation.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.assertion">
		<class name="/:org.dbunit.assertion.DbAssertionFailedError" intfc="n" abs="n" inn="n" sloc="8" jdoc="Exception signaling a DbUnit assertion failure. Is used to avoid the direct dependency to any other testing framework. @author Felipe Leme @author Last changed by: $Author: gommma $ @version $Revision: 879 $ $Date: 2008-11-16 11:09:08 -0200 (Dom, 16 Nov 2008) $ @since 2.2.0">
			<const name="serialVersionUID" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.DbAssertionFailedError.DbAssertionFailedError()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.DbAssertionFailedError.DbAssertionFailedError(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.DifferenceListener" intfc="y" abs="n" inn="n" sloc="4" jdoc="Callback for {@link DbUnitAssert} to notify about the differences found during an assertion. &amp;lt;p&amp;gt; Inspired by the XMLUnit framework. &amp;lt; p&amp;gt; @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 877 $ $Date: 2008-11-15 08:03:44 -0200 (SÃ¡b, 15 Nov 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.assertion.DifferenceListener.handle(Difference)" access="pub" jdoc="Is invoked by the {@link DbUnitAssert} when a data cell difference has been found. @param diff The difference that has been found">
				<param name="diff"/>
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.DbComparisonFailure" intfc="n" abs="n" inn="n" sloc="48" jdoc="Exception signaling a DbUnit assertion failure while comparing values. Is used to avoid the direct dependency to any other testing framework. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 879 $ $Date: 2008-11-16 11:09:08 -0200 (Dom, 16 Nov 2008) $ @since 2.4.0">
			<const name="serialVersionUID" access="priv" jdoc=""/>
			<field name="reason" access="priv" jdoc=""/>
			<field name="expected" access="priv" jdoc=""/>
			<field name="actual" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.DbComparisonFailure.DbComparisonFailure(String, String, String)" access="pub" jdoc="@param reason The reason for the comparison failure @param expected The expected value @param actual The actual value">
				<param name="reason"/>
				<param name="expected"/>
				<param name="actual"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbComparisonFailure.getMessage()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.DbComparisonFailure.getReason()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.DbComparisonFailure.getExpected()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.DbComparisonFailure.getActual()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.DbComparisonFailure.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.DbComparisonFailure.buildMessage(String, String, String)" access="pub" jdoc="Creates a formatted message string from the given parameters @param reason The reason for an assertion or comparison failure @param expected The expected result @param actual The actual result @return The formatted message">
				<param name="reason"/>
				<param name="expected"/>
				<param name="actual"/>
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.FailureHandler" intfc="y" abs="n" inn="n" sloc="5" jdoc="Handles the failure of an assertion. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 872 $ $Date: 2008-11-08 13:45:52 -0200 (SÃ¡b, 08 Nov 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.assertion.FailureHandler.getAdditionalInfo(ITable, ITable, int, String)" access="pub" jdoc="Returns a string to be appended to the assertion failure message. Is used to provide some more information about a failure (for example to print out some PK columns for identifying the failed rows in the DB). @param expectedTable @param actualTable @param row The row for which the assertion failed @param columnName The column for which the assertion failed @return A string that is appended to the assertion failure message">
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="row"/>
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.DbUnitAssert" intfc="n" abs="n" inn="n" sloc="274" jdoc="Default implementation of DbUnit assertions, based on the original methods present at {@link Assertion} @author Felipe Leme (dbunit@felipeal.net) @author gommma (gommma AT users.sourceforge.net) @version $Revision$ $Date$ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="junitFailureFactory" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.DbUnitAssert()" access="pub" jdoc="Default constructor">
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEqualsIgnoreCols(IDataSet, IDataSet, String, String[])" access="pub" jdoc="Compare one table present in two datasets ignoring specified columns. @param expectedDatasetFirst dataset. @param actualDatasetSecond dataset. @param tableNameTable name of the table to be compared. @param ignoreColsColumns to be ignored in comparison. @throws org.dbunit.DatabaseUnitExceptionIf an error occurs.">
				<param name="expectedDataset"/>
				<param name="actualDataset"/>
				<param name="tableName"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEqualsIgnoreCols(ITable, ITable, String[])" access="pub" jdoc="Compare the given tables ignoring specified columns. @param expectedTableFirst table. @param actualTableSecond table. @param ignoreColsColumns to be ignored in comparison. @throws org.dbunit.DatabaseUnitExceptionIf an error occurs.">
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEqualsByQuery(IDataSet, IDatabaseConnection, String, String, String[])" access="pub" jdoc="Compare a table from a dataset with a table generated from an sql query. @param expectedDatasetDataset to retrieve the first table from. @param connectionConnection to use for the SQL statement. @param sqlQuerySQL query that will build the data in returned second table rows. @param tableNameTable name of the table to compare @param ignoreColsColumns to be ignored in comparison. @throws DatabaseUnitExceptionIf an error occurs while performing the comparison. @throws java.sql.SQLExceptionIf an SQL error occurs.">
				<param name="expectedDataset"/>
				<param name="connection"/>
				<param name="sqlQuery"/>
				<param name="tableName"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEqualsByQuery(ITable, IDatabaseConnection, String, String, String[])" access="pub" jdoc="Compare a table with a table generated from an sql query. @param expectedTableTable containing all expected results. @param connectionConnection to use for the SQL statement. @param tableNameThe name of the table to query from the database @param sqlQuerySQL query that will build the data in returned second table rows. @param ignoreColsColumns to be ignored in comparison. @throws DatabaseUnitExceptionIf an error occurs while performing the comparison. @throws java.sql.SQLExceptionIf an SQL error occurs.">
				<param name="expectedTable"/>
				<param name="connection"/>
				<param name="tableName"/>
				<param name="sqlQuery"/>
				<param name="ignoreCols"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEquals(IDataSet, IDataSet)" access="pub" jdoc="Asserts that the two specified dataset are equals. This method ignore the tables order.">
				<param name="expectedDataSet"/>
				<param name="actualDataSet"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEquals(IDataSet, IDataSet, FailureHandler)" access="pub" jdoc="Asserts that the two specified dataset are equals. This method ignore the tables order. @since 2.4">
				<comm cntt="do not continue if same instance"/>
				<comm cntt="tables count"/>
				<comm cntt="table names in no specific order"/>
				<comm cntt="tables"/>
				<param name="expectedDataSet"/>
				<param name="actualDataSet"/>
				<param name="failureHandler"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEquals(ITable, ITable)" access="pub" jdoc="Asserts that the two specified tables are equals. This method ignores the table names, the columns order, the columns data type and which columns are composing the primary keys. @param expectedTableTable containing all expected results. @param actualTableTable containing all actual results. @throws DatabaseUnitException">
				<param name="expectedTable"/>
				<param name="actualTable"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEquals(ITable, ITable, Column[])" access="pub" jdoc="Asserts that the two specified tables are equals. This method ignores the table names, the columns order, the columns data type and which columns are composing the primary keys. &amp;lt;br &amp;gt; Example: &amp;lt;code&amp;gt;&amp;lt;pre&amp;gt; ITable actualTable = ...; ITable expectedTable = ...; ITableMetaData metaData = actualTable.getTableMetaData(); Column[] additionalInfoCols = Columns.getColumns(new String[] {&amp;quot;MY_PK_COLUMN&amp;quot;}, metaData.getColumns()); assertEquals(expectedTable, actualTable, additionalInfoCols); &amp;lt; pre&amp;gt;&amp;lt; code&amp;gt; @param expectedTableTable containing all expected results. @param actualTableTable containing all actual results. @param additionalColumnInfoThe columns to be printed out if the assert fails because of a data mismatch. Provides some additional column values that may be useful to quickly identify the columns for which the mismatch occurred (for example a primary key column). Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @throws DatabaseUnitException">
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="additionalColumnInfo"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.assertEquals(ITable, ITable, FailureHandler)" access="pub" jdoc="Asserts that the two specified tables are equals. This method ignores the table names, the columns order, the columns data type and which columns are composing the primary keys. &amp;lt;br &amp;gt; Example: &amp;lt;code&amp;gt;&amp;lt;pre&amp;gt; ITable actualTable = ...; ITable expectedTable = ...; ITableMetaData metaData = actualTable.getTableMetaData(); FailureHandler failureHandler = new DefaultFailureHandler(); assertEquals(expectedTable, actualTable, failureHandler); &amp;lt; pre&amp;gt;&amp;lt; code&amp;gt; @param expectedTableTable containing all expected results. @param actualTableTable containing all actual results. @param failureHandlerThe failure handler used if the assert fails because of a data mismatch. Provides some additional information that may be useful to quickly identify the rows for which the mismatch occurred (for example by printing an additional primary key column). Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; @throws DatabaseUnitException @since 2.4">
				<comm cntt="Do not continue if same instance"/>
				<comm cntt="Verify row count"/>
				<comm cntt="if both tables are empty, it is not necessary to compare columns, as"/>
				<comm cntt="such"/>
				<comm cntt="comparison"/>
				<comm cntt="can fail if column metadata is different (which could occurs when"/>
				<comm cntt="comparing empty tables)"/>
				<comm cntt="Put the columns into the same order"/>
				<comm cntt="Verify columns"/>
				<comm cntt="Get the datatypes to be used for comparing the sorted columns"/>
				<comm cntt="Finally compare the data"/>
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="failureHandler"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.getDefaultFailureHandler()" access="prot" jdoc="@return The default failure handler @since 2.4">
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.getDefaultFailureHandler(Column[])" access="prot" jdoc="@return The default failure handler @since 2.4">
				<param name="additionalColumnInfo"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.getJUnitFailureFactory()" access="priv" jdoc="@return the JUnitFailureFactory if JUnit is on the classpath or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if JUnit is not on the classpath.">
				<comm cntt="JUnit available"/>
				<comm cntt="JUnit not available on the classpath return null"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.compareData(ITable, ITable, ComparisonColumn[], FailureHandler)" access="prot" jdoc="@param expectedTableTable containing all expected results. @param actualTableTable containing all actual results. @param comparisonColsThe columns to be compared, also including the correct{@link DataType}s for comparison @param failureHandlerThe failure handler used if the assert fails because of a data mismatch. Provides some additional information that may be useful to quickly identify the rows for which the mismatch occurred (for example by printing an additional primary key column). Must not be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; at this stage @throws DataSetException @since 2.4">
				<comm cntt="iterate over all rows"/>
				<comm cntt="iterate over all columns of the current row"/>
				<comm cntt="Compare the values"/>
				<comm cntt="Handle the difference (throw error immediately or something else)"/>
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="comparisonCols"/>
				<param name="failureHandler"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.skipCompare(String, Object, Object)" access="prot" jdoc="Method to last-minute intercept the comparison of a single expected and actual value. Designed to be overridden in order to skip cell comparison by specific cell values. @param columnName The column being compared @param expectedValue The expected value to be compared @param actualValue The actual value to be compared @return &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; always so that the comparison is never skipped @since 2.4">
				<param name="columnName"/>
				<param name="expectedValue"/>
				<param name="actualValue"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.getComparisonColumns(String, Column[], Column[], FailureHandler)" access="prot" jdoc="@param expectedTableName @param expectedColumns @param actualColumns @param failureHandlerThe {@link FailureHandler} to be used when no datatype can be determined @return The columns to be used for the assertion, including the correct datatype @since 2.4">
				<param name="expectedTableName"/>
				<param name="expectedColumns"/>
				<param name="actualColumns"/>
				<param name="failureHandler"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert.getSortedUpperTableNames(IDataSet)" access="prot" jdoc="">
				<param name="dataSet"/>
			</mth>
		<class name="/:org.dbunit.assertion.DbUnitAssert$ComparisonColumn" intfc="n" abs="n" inn="y" sloc="44" jdoc="Represents a single column to be used for the comparison of table data. It contains the {@link DataType} to be used for comparing the given column. This {@link DataType} matches the expected and actual column&amp;apos;s datatype. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 864 $ $Date: 2008-11-07 06:27:26 -0800 (Fri, 07 Nov 2008) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="columnName" access="priv" jdoc=""/>
			<field name="dataType" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.DbUnitAssert$ComparisonColumn.ComparisonColumn(String, Column, Column, FailureHandler)" access="pub" jdoc="@param tableNameThe table name which is only needed for debugging output @param expectedColumnThe expected column needed to resolve the {@link DataType} to use for the actual comparison @param actualColumnThe actual column needed to resolve the {@link DataType} to use for the actual comparison @param failureHandlerThe {@link FailureHandler} to be used when no datatype can be determined">
				<param name="tableName"/>
				<param name="expectedColumn"/>
				<param name="actualColumn"/>
				<param name="failureHandler"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert$ComparisonColumn.getColumnName()" access="pub" jdoc="@return The column actually being compared">
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert$ComparisonColumn.getDataType()" access="pub" jdoc="@return The {@link DataType} to use for the actual comparison">
			</mth>
			<mth name="/:org.dbunit.assertion.DbUnitAssert$ComparisonColumn.getComparisonDataType(String, Column, Column, FailureHandler)" access="priv" jdoc="@param tableNameThe table name which is only needed for debugging output @param expectedColumn @param actualColumn @param failureHandlerThe {@link FailureHandler} to be used when no datatype can be determined @return The dbunit {@link DataType} to use for comparing the given column.">
				<comm cntt="The two columns have different data type"/>
				<comm cntt="Expected column data type is unknown, use actual column data type"/>
				<comm cntt="Actual column data type is unknown, use expected column data type"/>
				<comm cntt="Impossible to determine which data type to use"/>
				<comm cntt="Both columns have same data type, return any one of them"/>
				<param name="tableName"/>
				<param name="expectedColumn"/>
				<param name="actualColumn"/>
				<param name="failureHandler"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.assertion.DefaultFailureHandler" intfc="n" abs="n" inn="n" sloc="133" jdoc="Default implementation of the {@link FailureHandler}. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 872 $ $Date: 2008-11-08 13:45:52 -0200 (SÃ¡b, 08 Nov 2008) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_additionalColumnInfo" access="priv" jdoc=""/>
			<field name="failureFactory" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.DefaultFailureHandler()" access="pub" jdoc="Default constructor which does not provide any additional column information.">
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.DefaultFailureHandler(Column[])" access="pub" jdoc="Create a default failure handler @param additionalColumnInfo the column names of the columns for which additional information should be printed when an assertion failed.">
				<comm cntt="Null-safe access"/>
				<param name="additionalColumnInfo"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.DefaultFailureHandler(String[])" access="pub" jdoc="Create a default failure handler @param additionalColumnInfo the column names of the columns for which additional information should be printed when an assertion failed.">
				<param name="additionalColumnInfo"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.setFailureFactory(FailureFactory)" access="pub" jdoc="@param failureFactory The {@link FailureFactory} to be used for creating assertion errors.">
				<param name="failureFactory"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.createFailure(String, String, String)" access="pub" jdoc="">
				<param name="message"/>
				<param name="expected"/>
				<param name="actual"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.createFailure(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.getAdditionalInfo(ITable, ITable, int, String)" access="pub" jdoc="">
				<comm cntt="add custom column values information for better identification of mismatching rows"/>
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="row"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.buildAdditionalColumnInfo(ITable, ITable, int)" access="priv" jdoc="">
				<comm cntt="No columns specified"/>
				<comm cntt="Get the ITable objects to be used for showing the column values (needed in case"/>
				<comm cntt="of Filtered tables)"/>
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="rowIndex"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.getTableForColumn(ITable, String)" access="priv" jdoc="@param table The table which might be a decorated table @param columnName The column name for which a table is searched @return The table that as a column with the given name @throws DataSetException If no table could be found having a column with the given name">
				<comm cntt="if the column index was resolved the table contains the given column."/>
				<comm cntt="So just use this table"/>
				<comm cntt="If the column was not found check for filtered table"/>
				<comm cntt="If we get here the column exists - return the table since it is not filtered"/>
				<comm cntt="in the CompositeTable."/>
				<comm cntt="Column not available in the table - rethrow the exception"/>
				<param name="table"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.handle(Difference)" access="pub" jdoc="">
				<comm cntt="Throw the assertion error"/>
				<param name="diff"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.buildMessage(Difference)" access="prot" jdoc="">
				<comm cntt="example message:"/>
				<comm cntt="&amp;quot;value (table=MYTAB, row=232, column=MYCOL, Additional row info: (column=MyIdCol, expected=444, actual=555)): expected:&amp;lt;123&amp;gt; but was:&amp;lt;1234&amp;gt;&amp;quot;"/>
				<param name="diff"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler.toString()" access="pub" jdoc="">
			</mth>
		<class name="/:org.dbunit.assertion.DefaultFailureHandler$DefaultFailureFactory" intfc="n" abs="n" inn="y" sloc="11" jdoc="Default failure factory which returns DBUnits own assertion error instances. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 872 $ $Date: 2008-11-08 13:45:52 -0200 (SÃ¡b, 08 Nov 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler$DefaultFailureFactory.createFailure(String, String, String)" access="pub" jdoc="">
				<comm cntt="Return dbunit&amp;apos;s own comparison failure object"/>
				<param name="message"/>
				<param name="expected"/>
				<param name="actual"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DefaultFailureHandler$DefaultFailureFactory.createFailure(String)" access="pub" jdoc="">
				<comm cntt="Return dbunit&amp;apos;s own failure object"/>
				<param name="message"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.assertion.JUnitFailureFactory" intfc="n" abs="n" inn="n" sloc="11" jdoc="Adapter that lets dbunit create JUnit failure objects. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 872 $ $Date: 2008-11-08 13:45:52 -0200 (SÃ¡b, 08 Nov 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.assertion.JUnitFailureFactory.createFailure(String, String, String)" access="pub" jdoc="">
				<comm cntt="Return the junit.framework.ComparisonFailure object"/>
				<param name="message"/>
				<param name="expected"/>
				<param name="actual"/>
			</mth>
			<mth name="/:org.dbunit.assertion.JUnitFailureFactory.createFailure(String)" access="pub" jdoc="">
				<comm cntt="Return the junit.framework.AssertionFailedError object"/>
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.SimpleAssert" intfc="n" abs="n" inn="n" sloc="37" jdoc="Dbunit&amp;apos;s own small assertion utility, independent from the testing framework that is used. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 879 $ $Date: 2008-11-16 11:09:08 -0200 (Dom, 16 Nov 2008) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="failureHandler" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.SimpleAssert.SimpleAssert(FailureHandler)" access="pub" jdoc="">
				<param name="failureHandler"/>
			</mth>
			<mth name="/:org.dbunit.assertion.SimpleAssert.assertNotNullNorEmpty(String, String)" access="prot" jdoc="Asserts that propertyName is not a null String and has a length greater than zero.">
				<param name="propertyName"/>
				<param name="property"/>
			</mth>
			<mth name="/:org.dbunit.assertion.SimpleAssert.assertTrue(boolean)" access="pub" jdoc="">
				<param name="condition"/>
			</mth>
			<mth name="/:org.dbunit.assertion.SimpleAssert.assertTrue(String, boolean)" access="pub" jdoc="Evaluate if the given condition is &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; or not. @param message message displayed if assertion is false @param condition condition to be tested">
				<param name="message"/>
				<param name="condition"/>
			</mth>
			<mth name="/:org.dbunit.assertion.SimpleAssert.assertNotNull(Object)" access="pub" jdoc="">
				<param name="object"/>
			</mth>
			<mth name="/:org.dbunit.assertion.SimpleAssert.assertNotNull(String, Object)" access="pub" jdoc="">
				<param name="message"/>
				<param name="object"/>
			</mth>
			<mth name="/:org.dbunit.assertion.SimpleAssert.fail(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.FailureFactory" intfc="y" abs="n" inn="n" sloc="5" jdoc="Factory to create exceptions for the testing framework to be used, for example JUnit, TestNG or dbunit exceptions. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 872 $ $Date: 2008-11-08 13:45:52 -0200 (SÃ¡b, 08 Nov 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.assertion.FailureFactory.createFailure(String, String, String)" access="pub" jdoc="Creates a new failure object which can have different types, depending on the testing framework you are currently using (e.g. JUnit, TestNG, ...) @param message The reason for the failure @param expected The expected result @param actual The actual result @return The comparison failure object for this handler (can be JUnit or some other) which can be thrown on an assertion failure">
				<param name="message"/>
				<param name="expected"/>
				<param name="actual"/>
			</mth>
			<mth name="/:org.dbunit.assertion.FailureFactory.createFailure(String)" access="pub" jdoc="@param message The reason for the failure @return The assertion failure object for this handler (can be JUnit or some other) which can be thrown on an assertion failure">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.DiffCollectingFailureHandler" intfc="n" abs="n" inn="n" sloc="21" jdoc="A {@link FailureHandler} that collects the {@link Difference}s that were found without throwing an exception. &amp;lt;p&amp;gt; You can use it as follows: &amp;lt;code&amp;gt;&amp;lt;pre&amp;gt; IDataSet dataSet = getDataSet(); DiffCollectingFailureHandler myHandler = new DiffCollectingFailureHandler(); invoke the assertion with the custom handler assertion.assertEquals(dataSet.getTable(&amp;quot;TEST_TABLE&amp;quot;), dataSet.getTable(&amp;quot;TEST_TABLE_WITH_WRONG_VALUE&amp;quot;), myHandler); Evaluate the results List diffList = myHandler.getDiffList(); Difference diff = (Difference)diffList.get(0); ... &amp;lt; pre&amp;gt;&amp;lt; code&amp;gt; @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 872 $ $Date: 2008-11-08 13:45:52 -0200 (SÃ¡b, 08 Nov 2008) $ @since 2.4.0">
			<const name="diffList" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.DiffCollectingFailureHandler.handle(Difference)" access="pub" jdoc="">
				<comm cntt="Simply collect the difference without throwing an exception"/>
				<param name="diff"/>
			</mth>
			<mth name="/:org.dbunit.assertion.DiffCollectingFailureHandler.getDiffList()" access="pub" jdoc="@return The list of collected {@link Difference}s">
			</mth>
			<mth name="/:org.dbunit.assertion.DiffCollectingFailureHandler.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.assertion.Difference" intfc="n" abs="n" inn="n" sloc="52" jdoc="Value object to hold the difference of a single data cell found while comparing data. &amp;lt;p&amp;gt; Inspired by the XMLUnit framework. &amp;lt; p&amp;gt; @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 872 $ $Date: 2008-11-08 13:45:52 -0200 (SÃ¡b, 08 Nov 2008) $ @since 2.4.0">
			<field name="expectedTable" access="priv" jdoc=""/>
			<field name="actualTable" access="priv" jdoc=""/>
			<field name="rowIndex" access="priv" jdoc=""/>
			<field name="columnName" access="priv" jdoc=""/>
			<field name="expectedValue" access="priv" jdoc=""/>
			<field name="actualValue" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.assertion.Difference.Difference(ITable, ITable, int, String, Object, Object)" access="pub" jdoc="">
				<param name="expectedTable"/>
				<param name="actualTable"/>
				<param name="rowIndex"/>
				<param name="columnName"/>
				<param name="expectedValue"/>
				<param name="actualValue"/>
			</mth>
			<mth name="/:org.dbunit.assertion.Difference.getExpectedTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.Difference.getActualTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.Difference.getRowIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.Difference.getColumnName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.Difference.getExpectedValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.Difference.getActualValue()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.assertion.Difference.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.database">
		<class name="/:org.dbunit.database.DatabaseConnection" intfc="n" abs="n" inn="n" sloc="95" jdoc="This class adapts a JDBC &amp;lt;code&amp;gt;Connection&amp;lt; code&amp;gt; to a{@link IDatabaseConnection}. @author Manuel Laflamme @version $Revision: 961 $ @since Feb 21, 2002">
			<comm cntt=""/>
			<comm cntt="IDatabaseConnection interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_connection" access="priv" jdoc=""/>
			<const name="_schema" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseConnection.DatabaseConnection(Connection)" access="pub" jdoc="Creates a new &amp;lt;code&amp;gt;DatabaseConnection&amp;lt; code&amp;gt;. @param connection the adapted JDBC connection @throws DatabaseUnitException">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.DatabaseConnection(Connection, String)" access="pub" jdoc="Creates a new &amp;lt;code&amp;gt;DatabaseConnection&amp;lt; code&amp;gt; using a specific schema. @param connection the adapted JDBC connection @param schema the database schema. Note that the schema name is case sensitive. This is necessary because schemas with the same name but different case can coexist on one database. &amp;lt;br&amp;gt; Here an example that creates two users schemas for oracle where only the case is different:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt; create user dbunittest identified by dbunittest; create user &amp;quot;dbunittest&amp;quot; identified by &amp;quot;dbunittest&amp;quot;; &amp;lt; code&amp;gt; The first one creates the &amp;quot;default&amp;quot; user where everything is interpreted by oracle in uppercase. The second one is completely lowercase because of the quotes. @throws DatabaseUnitException">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.DatabaseConnection(Connection, String, boolean)" access="pub" jdoc="Creates a new &amp;lt;code&amp;gt;DatabaseConnection&amp;lt; code&amp;gt; using a specific schema. @param connection the adapted JDBC connection @param schema the database schema. Note that the schema name is case sensitive. This is necessary because schemas with the same name but different case can coexist on one database. &amp;lt;br&amp;gt; Here an example that creates two users schemas for oracle where only the case is different:&amp;lt;br&amp;gt; &amp;lt;code&amp;gt; create user dbunittest identified by dbunittest; create user &amp;quot;dbunittest&amp;quot; identified by &amp;quot;dbunittest&amp;quot;; &amp;lt; code&amp;gt; The first one creates the &amp;quot;default&amp;quot; user where everything is interpreted by oracle in uppercase. The second one is completely lowercase because of the quotes. @param validate If &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; an exception is thrown when the given schema does not exist according to the DatabaseMetaData. If &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; the validation will only print a warning if the schema was not found. @since 2.3.0 @throws DatabaseUnitException If the &amp;lt;code&amp;gt;validate&amp;lt; code&amp;gt; parameter is &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; and the validation of the given connection schema was not successful (added with 2.3.0). This can happen if the given schema does not exist or if the jdbc driver does not implement the metaData.getSchemas() method properly.">
				<param name="connection"/>
				<param name="schema"/>
				<param name="validate"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.getConnection()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.getSchema()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.close()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.printConnectionInfo()" access="priv" jdoc="Prints debugging information about the current JDBC connection">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.validateSchema(boolean)" access="priv" jdoc="Validates if the database schema exists for this connection. @param validateStrict If &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; an exception is thrown when the given schema does not exist according to the DatabaseMetaData. If &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; the validation will only print a warning if the schema was not found. @throws DatabaseUnitException">
				<comm cntt="Under certain circumstances the cause might be that the JDBC driver"/>
				<comm cntt="implementation of &amp;apos;DatabaseMetaData.getSchemas()&amp;apos; is not correct"/>
				<comm cntt="(known issue of MySQL driver)."/>
				<comm cntt="If strict validation is wished throw an exception"/>
				<param name="validateStrict"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConnection.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.AmbiguousTableNameException" intfc="n" abs="n" inn="n" sloc="18" jdoc="This exception is thrown by {@link org.dbunit.dataset.IDataSet} when multiple tables having the same name are accessible. This usually occurs when the database connection have access to multiple schemas containing identical table names. &amp;lt;p&amp;gt; Possible solutions: 1) Use a database connection credential that has access to only one database schema. 2) Specify a schema name to the {@link DatabaseConnection} or{@link DatabaseDataSourceConnection} constructor. 3) Enable the qualified table name support (see How-to documentation). &amp;lt; p&amp;gt; &amp;lt;p&amp;gt; Another common reason for this exception to be thrown is when an XML file contains the same table multiple times whereas a different table is between the definition of the duplicate table. &amp;lt; p&amp;gt; @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 820 $ $Date: 2008-09-29 18:12:02 -0300 (Seg, 29 Set 2008) $ @since 1.0 May 1, 2002">
			<mth name="/:org.dbunit.database.AmbiguousTableNameException.AmbiguousTableNameException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.AmbiguousTableNameException.AmbiguousTableNameException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.database.AmbiguousTableNameException.AmbiguousTableNameException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.database.AmbiguousTableNameException.AmbiguousTableNameException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.AbstractResultSetTable" intfc="n" abs="y" inn="n" sloc="97" jdoc="@author Manuel Laflamme @since Apr 10, 2003 @version $Revision: 965 $">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<comm cntt=""/>
			<comm cntt="IResultSetTable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_metaData" access="prot" jdoc=""/>
			<field name="_statement" access="priv" jdoc=""/>
			<field name="_resultSet" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.AbstractResultSetTable(ITableMetaData, ResultSet)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.AbstractResultSetTable(String, String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="selectStatement"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.AbstractResultSetTable(String, String, IDatabaseConnection, boolean)" access="pub" jdoc="@param tableName @param selectStatement @param connection @param caseSensitiveTableNames @throws DataSetException @throws SQLException @since 2.4.1">
				<param name="tableName"/>
				<param name="selectStatement"/>
				<param name="connection"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.AbstractResultSetTable(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.createStatement(IDatabaseConnection)" access="priv" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.getSelectStatement(String, ITableMetaData, String)" access="pub" jdoc="">
				<param name="schema"/>
				<param name="metaData"/>
				<param name="escapePattern"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.AbstractResultSetTable.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.ResultSetTableMetaData" intfc="n" abs="n" inn="n" sloc="173" jdoc="{@link ResultSet} based {@link org.dbunit.dataset.ITableMetaData} implementation. &amp;lt;p&amp;gt; The lookup for the information needed to create the {@link Column} objects is retrieved in two phases: &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;Try to find the information from the given {@link ResultSet} via a {@link DatabaseMetaData}object. Therefore the {@link ResultSetMetaData} is used to get the catalog schema table column names which in turn are used to get column information via{@link DatabaseMetaData#getColumns(String,String,String,String)}. The reason for this is that the {@link DatabaseMetaData} is more precise and contains more information about columns than the {@link ResultSetMetaData} does. Another reason is that some JDBC drivers (currently known from MYSQL driver) provide an inconsistent implementation of those two MetaData objects and the {@link DatabaseMetaData} is hence considered to be the master by dbunit. &amp;lt; li&amp;gt; &amp;lt;li&amp;gt; Since some JDBC drivers (one of them being Oracle) cannot (or just do not) provide the catalog schema table column values on a {@link ResultSetMetaData} instance the second step will create the dbunit {@link Column} using the {@link ResultSetMetaData} methods directly (for example {@link ResultSetMetaData#getColumnType(int)}. (This is also the way dbunit worked until the 2.4 release) &amp;lt; li&amp;gt; &amp;lt; ol&amp;gt; &amp;lt; p&amp;gt; @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1026 $ $Date: 2009-08-17 16:58:24 -0300 (Seg, 17 Ago 2009) $ @since 2.3.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="wrappedTableMetaData" access="priv" jdoc="The actual table metadata"/>
			<field name="_caseSensitiveMetaData" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.ResultSetTableMetaData(String, ResultSet, IDatabaseConnection, boolean)" access="pub" jdoc="@param tableName The name of the database table @param resultSet The JDBC result set that is used to retrieve the columns @param connection The connection which is needed to retrieve some configuration values @param caseSensitiveMetaData Whether or not the metadata is case sensitive @throws DataSetException @throws SQLException">
				<param name="tableName"/>
				<param name="resultSet"/>
				<param name="connection"/>
				<param name="caseSensitiveMetaData"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.ResultSetTableMetaData(String, ResultSet, IDataTypeFactory, boolean)" access="pub" jdoc="@param tableName The name of the database table @param resultSet The JDBC result set that is used to retrieve the columns @param dataTypeFactory @param caseSensitiveMetaData Whether or not the metadata is case sensitive @throws DataSetException @throws SQLException @deprecated since 2.4.4. use {@link ResultSetTableMetaData#ResultSetTableMetaData(String,ResultSet,IDatabaseConnection,boolean)}">
				<param name="tableName"/>
				<param name="resultSet"/>
				<param name="dataTypeFactory"/>
				<param name="caseSensitiveMetaData"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.createMetaData(String, ResultSet, IDatabaseConnection)" access="priv" jdoc="">
				<param name="tableName"/>
				<param name="resultSet"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.createMetaData(String, ResultSet, IDataTypeFactory, IMetadataHandler)" access="priv" jdoc="">
				<comm cntt="1. try to create the column from the DatabaseMetaData object. The DatabaseMetaData"/>
				<comm cntt="provides more information and is more precise so that it should always be used in"/>
				<comm cntt="preference to the ResultSetMetaData object."/>
				<comm cntt="2. If we could not create the Column from a DatabaseMetaData object, try to create it"/>
				<comm cntt="from the ResultSetMetaData object directly"/>
				<param name="tableName"/>
				<param name="resultSet"/>
				<param name="dataTypeFactory"/>
				<param name="columnFactory"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.createColumnFromRsMetaData(ResultSetMetaData, int, String, IDataTypeFactory)" access="priv" jdoc="">
				<param name="rsMetaData"/>
				<param name="rsIndex"/>
				<param name="tableName"/>
				<param name="dataTypeFactory"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.createColumnFromDbMetaData(ResultSetMetaData, int, DatabaseMetaData, IDataTypeFactory, IMetadataHandler)" access="priv" jdoc="Try to create the Column using information from the given {@link ResultSetMetaData}to search the column via the given {@link DatabaseMetaData}. If the{@link ResultSetMetaData} does not provide the required information (one of catalog schema table is &amp;quot;&amp;quot;) the search for the Column via {@link DatabaseMetaData} is not executed and &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; is returned immediately. @param rsMetaData The {@link ResultSetMetaData} from which to retrieve the {@link DatabaseMetaData} @param rsIndex The current index in the {@link ResultSetMetaData} @param databaseMetaData The {@link DatabaseMetaData} which is used to lookup detailed information about the column if possible @param dataTypeFactory dbunit {@link IDataTypeFactory} needed to create the Column @param metadataHandler the handler to be used for {@link DatabaseMetaData} handling @return The column or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if it can be not created using a {@link DatabaseMetaData} object because of missing information in the {@link ResultSetMetaData} object @throws SQLException @throws DataTypeException">
				<comm cntt="use DatabaseMetaData to retrieve the actual column definition"/>
				<comm cntt="Due to a bug in the DB2 JDBC driver we have to trim the names"/>
				<comm cntt="Check if at least one of catalog schema table attributes is"/>
				<comm cntt="not applicable (i.e. &amp;quot;&amp;quot; is returned). If so do not try"/>
				<comm cntt="to get the column metadata from the DatabaseMetaData object."/>
				<comm cntt="This is the case for all oracle JDBC drivers"/>
				<comm cntt="Catalog name is not required"/>
				<comm cntt="All of the retrieved attributes are valid,"/>
				<comm cntt="so lookup the column via DatabaseMetaData"/>
				<comm cntt="Scroll resultset forward - must have one result which exactly matches the required parameters"/>
				<param name="rsMetaData"/>
				<param name="rsIndex"/>
				<param name="databaseMetaData"/>
				<param name="dataTypeFactory"/>
				<param name="metadataHandler"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.trim(String)" access="priv" jdoc="Trims the given string in a null-safe way @param value @return @since 2.4.6">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.scrollTo(ResultSet, IMetadataHandler, String, String, String, String)" access="priv" jdoc="">
				<comm cntt="All right. Return immediately because the resultSet is positioned on the correct row"/>
				<comm cntt="If we get here the column could not be found"/>
				<param name="columnsResultSet"/>
				<param name="metadataHandler"/>
				<param name="catalog"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.getColumns()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.getPrimaryKeys()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.ResultSetTableMetaData.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.PrimaryKeyFilter" intfc="n" abs="n" inn="n" sloc="278" jdoc="Filter a table given a map of the allowed rows based on primary key values.&amp;lt;br&amp;gt; It uses a depth-first algorithm (although not recursive - it might be refactored in the future) to define which rows are allowed, as well which rows are necessary (and hence allowed) because of dependencies with the allowed rows.&amp;lt;br&amp;gt; &amp;lt;strong&amp;gt;NOTE:&amp;lt; strong&amp;gt; multi-column primary keys are not supported at the moment. TODO: test cases @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 806 $ $Date: 2008-09-16 07:14:06 -0300 (Ter, 16 Set 2008) $ @since Sep 9, 2005">
			<comm cntt="cache the primary keys"/>
			<comm cntt="name of the tables, in reverse order of dependency"/>
			<comm cntt="TODO: support PKs with multiple values"/>
			<const name="connection" access="priv" jdoc=""/>
			<const name="allowedPKsPerTable" access="priv" jdoc=""/>
			<const name="allowedPKsInput" access="priv" jdoc=""/>
			<const name="pksToScanPerTable" access="priv" jdoc=""/>
			<const name="reverseScan" access="priv" jdoc=""/>
			<const name="logger" access="prot" jdoc=""/>
			<const name="pkColumnPerTable" access="priv" jdoc=""/>
			<const name="fkEdgesPerTable" access="priv" jdoc=""/>
			<const name="fkReverseEdgesPerTable" access="priv" jdoc=""/>
			<const name="tableNames" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.PrimaryKeyFilter(IDatabaseConnection, PkTableMap, boolean)" access="pub" jdoc="Default constructor, it takes as input a map with desired rows in a final dataset; the filter will ensure that the rows necessary by these initial rows are also allowed (and so on...). @param connection database connection @param allowedPKs map of allowed rows, based on the primary keys (key is the name of a table; value is a Set with allowed primary keys for that table) @param reverseDependency flag indicating if the rows that depend on a row should also be allowed by the filter">
				<comm cntt="we need a deep copy here"/>
				<param name="connection"/>
				<param name="allowedPKs"/>
				<param name="reverseDependency"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.nodeAdded(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.edgeAdded(ForeignKeyRelationshipEdge)" access="pub" jdoc="">
				<comm cntt="first add it to the &amp;quot;direct edges&amp;quot;"/>
				<comm cntt="then add it to the &amp;quot;reverse edges&amp;quot;"/>
				<comm cntt="finally, update the PKs cache"/>
				<param name="edge"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.isValidName(String)" access="pub" jdoc="@see AbstractTableFilter">
				<comm cntt="boolean isValid = this.allowedIds.containsKey(tableName);"/>
				<comm cntt="return isValid;"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.iterator(IDataSet, boolean)" access="pub" jdoc="">
				<param name="dataSet"/>
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.searchPKs(IDataSet)" access="priv" jdoc="">
				<comm cntt="TODO: support multi-column PKs"/>
				<comm cntt="if"/>
				<comm cntt="for"/>
				<comm cntt="while"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.removeScannedTables()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.allowPKs(String, Set)" access="priv" jdoc="">
				<comm cntt="then, add the new IDs, but checking if it should be allowed to add them"/>
				<param name="table"/>
				<param name="newAllowedPKs"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.scanPKs(String, String, Set)" access="priv" jdoc="">
				<comm cntt="we need a temporary list as there is no warranty about the set order..."/>
				<comm cntt="NOTE: make sure the query below is compatible standard SQL"/>
				<param name="table"/>
				<param name="pkColumn"/>
				<param name="allowedIds"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.scanPKs(String, String, Set, List)" access="priv" jdoc="">
				<comm cntt="id being scanned"/>
				<comm cntt="new in the finally block. has been in the catch only before"/>
				<param name="table"/>
				<param name="sql"/>
				<param name="allowedIds"/>
				<param name="fkTables"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.scanReversePKs(String, Set)" access="priv" jdoc="">
				<param name="table"/>
				<param name="pksToScan"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.addReverseEdge(ForeignKeyRelationshipEdge, Set)" access="priv" jdoc="">
				<comm cntt="NOTE: make sure the query below is compatible standard SQL"/>
				<param name="edge"/>
				<param name="idsToScan"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.updatePkCache(String, ForeignKeyRelationshipEdge)" access="priv" jdoc="">
				<param name="table"/>
				<param name="edge"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.getPKColumn(String)" access="priv" jdoc="">
				<comm cntt="Try to get the cached column"/>
				<comm cntt="If the column has not been cached until now retrieve it from the database connection"/>
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.removePKsToScan(String, Set)" access="priv" jdoc="">
				<param name="table"/>
				<param name="ids"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.addPKToScan(String, Object)" access="priv" jdoc="">
				<comm cntt="first, check if it wasn&amp;apos;t added yet"/>
				<param name="table"/>
				<param name="pk"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter.toString()" access="pub" jdoc="">
			</mth>
		<class name="/:org.dbunit.database.PrimaryKeyFilter$FilterIterator" intfc="n" abs="n" inn="y" sloc="35" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="_iterator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$FilterIterator.FilterIterator(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$FilterIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$FilterIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$FilterIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap" intfc="n" abs="n" inn="y" sloc="85" jdoc="Map that associates a table with a set of primary key objects. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 806 $ $Date: 2008-09-16 07:14:06 -0300 (Ter, 16 Set 2008) $ @since 2.3.0">
			<const name="pksPerTable" access="priv" jdoc=""/>
			<const name="logger" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.PkTableMap()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.PkTableMap(PkTableMap)" access="pub" jdoc="Copy constructor @param allowedPKs">
				<param name="allowedPKs"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.size()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.isEmpty()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.contains(String, Object)" access="pub" jdoc="">
				<param name="table"/>
				<param name="pkObject"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.remove(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.put(String, SortedSet)" access="pub" jdoc="">
				<param name="table"/>
				<param name="pkObjects"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.add(String, Object)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="pkObject"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.addAll(String, Set)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="pkObjectsToAdd"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.get(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.getCreateIfNeeded(String)" access="priv" jdoc="">
				<comm cntt="Lazily create the set if it did not exist yet"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.retainOnly(List)" access="pub" jdoc="">
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilter$PkTableMap.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.database.IDatabaseConnection" intfc="y" abs="n" inn="n" sloc="19" jdoc="This interface represents a connection to a specific database. @author Manuel Laflamme @version $Revision: 965 $ @since Mar 6, 2002">
			<mth name="/:org.dbunit.database.IDatabaseConnection.getConnection()" access="pub" jdoc="Returns a JDBC database connection.">
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.getSchema()" access="pub" jdoc="Returns the database schema name.">
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.close()" access="pub" jdoc="Close this connection.">
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.createDataSet()" access="pub" jdoc="Creates a dataset corresponding to the entire database.">
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.createDataSet(String[])" access="pub" jdoc="Creates a dataset containing only the specified tables from the database. @param tableNames The tables for which a dataset shall be created @return The new dataset @throws SQLException @throws DataSetException">
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.createQueryTable(String, String)" access="pub" jdoc="Creates a table with the result of the specified SQL statement. The table can be the result of a join statement. @param tableName The name to be returned by {@link org.dbunit.dataset.ITableMetaData#getTableName}. @param sql The SQL &amp;lt;code&amp;gt;SELECT&amp;lt; code&amp;gt; statement @return The new table @throws DataSetException @throws SQLException">
				<param name="tableName"/>
				<param name="sql"/>
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.createTable(String, PreparedStatement)" access="pub" jdoc="Creates a table using the given PreparedStatement to retrieve a ResultSet. @param tableName The name to be returned by {@link org.dbunit.dataset.ITableMetaData#getTableName}. @param preparedStatement The statement to be executed as query @return The new table @throws DataSetException @throws SQLException @since 2.4.4">
				<param name="tableName"/>
				<param name="preparedStatement"/>
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.createTable(String)" access="pub" jdoc="Creates a table with the result of a &amp;lt;code&amp;gt;select from &amp;lt;i&amp;gt;tableName&amp;lt; i&amp;gt;&amp;lt; code&amp;gt; SQL statement. @param tableName The name of the database table to be queried which is also returned by {@link org.dbunit.dataset.ITableMetaData#getTableName}.">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.getRowCount(String)" access="pub" jdoc="Returns the specified table row count. @param tableName the table name @return the row count">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.getRowCount(String, String)" access="pub" jdoc="Returns the specified table row count according specified where clause. @param tableName the table name @param whereClause the where clause @return the row count">
				<param name="tableName"/>
				<param name="whereClause"/>
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.getConfig()" access="pub" jdoc="Returns this connection database configuration">
			</mth>
			<mth name="/:org.dbunit.database.IDatabaseConnection.getStatementFactory()" access="pub" jdoc="@deprecated Use {@link #getConfig}">
			</mth>
		</class>
		<class name="/:org.dbunit.database.DatabaseTableIterator" intfc="n" abs="n" inn="n" sloc="39" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 815 $ $Date: 2008-09-27 09:33:56 -0300 (SÃ¡b, 27 Set 2008) $ @since 1.x (Apr 12, 2003)">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tableNames" access="priv" jdoc=""/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<field name="_currentTable" access="priv" jdoc=""/>
			<field name="_index" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseTableIterator.DatabaseTableIterator(String[], IDataSet)" access="pub" jdoc="">
				<param name="tableNames"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableIterator.next()" access="pub" jdoc="">
				<comm cntt="Ensure previous table is closed"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.DefaultMetadataHandler" intfc="n" abs="n" inn="n" sloc="94" jdoc="Default implementation of {@link IMetadataHandler} which works for the most databases. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 979 $ $Date: 2009-03-03 14:39:37 -0300 (Ter, 03 Mar 2009) $ @since 2.4.4">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.getColumns(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<param name="databaseMetaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.matches(ResultSet, String, String, boolean)" access="pub" jdoc="">
				<param name="resultSet"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.matches(ResultSet, String, String, String, String, boolean)" access="pub" jdoc="">
				<param name="columnsResultSet"/>
				<param name="catalog"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="column"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.areEqualIgnoreNull(String, String, boolean)" access="priv" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.getSchema(ResultSet)" access="pub" jdoc="">
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.tableExists(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.getTables(DatabaseMetaData, String, String[])" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schemaName"/>
				<param name="tableType"/>
			</mth>
			<mth name="/:org.dbunit.database.DefaultMetadataHandler.getPrimaryKeys(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.ForwardOnlyResultSetTableFactory" intfc="n" abs="n" inn="n" sloc="41" jdoc="@author manuel.laflamme @author Last changed by: $Author: gommma $ @version $Revision: 965 $ $Date: 2009-02-22 17:19:26 -0300 (Dom, 22 Fev 2009) $ @since 2.0 (Jul 31, 2003)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTableFactory.createTable(String, String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="selectStatement"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTableFactory.createTable(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTableFactory.createTable(String, PreparedStatement, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="preparedStatement"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTableFactory.createForwardOnlyResultSetTable(String, PreparedStatement, IDatabaseConnection)" access="pub" jdoc="Creates a new {@link ForwardOnlyResultSetTable} using the given {@link PreparedStatement} to retrieve the data. @param tableName The name the {@link ITable} will have @param preparedStatement The statement which provides the data @param connection The database connection which also holds dbunit configuration information @return The new table object @throws SQLException @throws DataSetException">
				<param name="tableName"/>
				<param name="preparedStatement"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.DatabaseSequenceFilter" intfc="n" abs="n" inn="n" sloc="105" jdoc="This filter orders tables using dependency information provided by{@link java.sql.DatabaseMetaData#getExportedKeys}. Note that this class name is a bit misleading since it is not at all related to database sequences. It just brings database tables in a specific order. @author Manuel Laflamme @author Erik Price @author Last changed by: $Author: gommma $ @version $Revision: 1086 $ $Date: 2009-10-30 08:50:38 -0200 (Sex, 30 Out 2009) $ @since 1.5.1 (Mar 23, 2003)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter.DatabaseSequenceFilter(IDatabaseConnection, String[])" access="pub" jdoc="Create a DatabaseSequenceFilter that only exposes specified table names.">
				<param name="connection"/>
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter.DatabaseSequenceFilter(IDatabaseConnection)" access="pub" jdoc="Create a DatabaseSequenceFilter that exposes all the database tables.">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter.sortTableNames(IDatabaseConnection, String[])" access="pub" jdoc="Re-orders a string array of table names, placing dependent (&amp;quot;parent&amp;quot;) tables after their dependencies (&amp;quot;children&amp;quot;). @param tableNames A string array of table names to be ordered. @return The re-ordered array of table names. @throws DataSetException @throws SQLException If an exception is encountered in accessing the database.">
				<comm cntt="not sure why this throws DataSetException ? - ENP"/>
				<comm cntt="Get dependencies for each table"/>
				<comm cntt="Check whether the table dependency info contains cycles"/>
				<param name="connection"/>
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter.sort(String[], Map)" access="priv" jdoc="">
				<comm cntt="re-order &amp;apos;tmpTableNames&amp;apos; into &amp;apos;sortedTableNames&amp;apos;"/>
				<comm cntt="end for loop; we know the index"/>
				<comm cntt="add &amp;apos;tmpTable&amp;apos; to &amp;apos;sortedTableNames&amp;apos;."/>
				<comm cntt="Insert it before its first dependent if there are any,"/>
				<comm cntt="otherwise append it to the end of &amp;apos;sortedTableNames&amp;apos;"/>
				<comm cntt="don&amp;apos;t stop processing until we have a perfect run (no re-ordering)"/>
				<comm cntt="end &amp;apos;while (reprocess)&amp;apos;"/>
				<param name="tableNames"/>
				<param name="dependencies"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter.getDependencyInfo(IDatabaseConnection, String)" access="priv" jdoc="Creates the dependency information for the given table @param connection @param tableName @return The dependency information for the given table @throws SearchException">
				<comm cntt="The tables dependency helpers makes a depth search for dependencies and returns the whole"/>
				<comm cntt="tree of dependent objects, not only the direct FK-PK related tables."/>
				<comm cntt="Remove the table itself which is automatically included by the TablesDependencyHelper"/>
				<param name="connection"/>
				<param name="tableName"/>
			</mth>
		<class name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo" intfc="n" abs="n" inn="y" sloc="62" jdoc="Container of dependency information for one single table. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1086 $ $Date: 2009-10-30 08:50:38 -0200 (Sex, 30 Out 2009) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="tableName" access="priv" jdoc=""/>
			<field name="allTableDependsOn" access="priv" jdoc=""/>
			<field name="allTableDependent" access="priv" jdoc=""/>
			<field name="directDependsOnTablesSet" access="priv" jdoc=""/>
			<field name="directDependentTablesSet" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.DependencyInfo(String, Set, Set, Set, Set)" access="pub" jdoc="@param tableName @param allTableDependsOn Tables that are required as prerequisite so that this one can exist @param allTableDependent Tables that need this one in order to be able to exist">
				<param name="tableName"/>
				<param name="directDependsOnTablesSet"/>
				<param name="directDependentTablesSet"/>
				<param name="allTableDependsOn"/>
				<param name="allTableDependent"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.containsDirectDependent(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.containsDirectDependsOn(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.getAllTableDependsOn()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.getAllTableDependent()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.getDirectDependsOnTablesSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.getDirectDependentTablesSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.checkCycles()" access="pub" jdoc="Checks this table&amp;apos;s information for cycles by intersecting the two sets. When the result set has at least one element we do have cycles. @throws CyclicTablesDependencyException">
				<comm cntt="Intersect the &amp;quot;tableDependsOn&amp;quot; and &amp;quot;otherTablesDependOn&amp;quot; to check for cycles"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseSequenceFilter$DependencyInfo.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.database.ForwardOnlyResultSetTable" intfc="n" abs="n" inn="n" sloc="54" jdoc="@author Manuel Laflamme @since Apr 10, 2003 @version $Revision: 679 $">
			<comm cntt="End of table flag"/>
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_lastRow" access="priv" jdoc=""/>
			<field name="_eot" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTable.ForwardOnlyResultSetTable(ITableMetaData, ResultSet)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTable.ForwardOnlyResultSetTable(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTable.ForwardOnlyResultSetTable(String, String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="selectStatement"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.ForwardOnlyResultSetTable.getValue(int, String)" access="pub" jdoc="">
				<comm cntt="Move cursor forward up to specified row"/>
				<comm cntt="Proactively close the resultset"/>
				<param name="row"/>
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.CachedResultSetTableFactory" intfc="n" abs="n" inn="n" sloc="31" jdoc="@author manuel.laflamme @author Last changed by: $Author: gommma $ @version $Revision: 965 $ $Date: 2009-02-22 17:19:26 -0300 (Dom, 22 Fev 2009) $ @since 2.0 (Jul 31, 2003)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.CachedResultSetTableFactory.createTable(String, String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="selectStatement"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.CachedResultSetTableFactory.createTable(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.CachedResultSetTableFactory.createTable(String, PreparedStatement, IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="Reuse method from ForwardOnly factory"/>
				<param name="tableName"/>
				<param name="preparedStatement"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.IResultSetTableFactory" intfc="y" abs="n" inn="n" sloc="9" jdoc="@author manuel.laflamme @since Jul 17, 2003 @version $Revision: 965 $">
			<mth name="/:org.dbunit.database.IResultSetTableFactory.createTable(String, String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="selectStatement"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.IResultSetTableFactory.createTable(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.IResultSetTableFactory.createTable(String, PreparedStatement, IDatabaseConnection)" access="pub" jdoc="Creates a table from a preparedStatement @param tableName @param preparedStatement @param connection @return The table based on a SQL result set @since 2.4.4">
				<param name="tableName"/>
				<param name="preparedStatement"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.DatabaseTableMetaData" intfc="n" abs="n" inn="n" sloc="228" jdoc="Container for the metadata for one database table. The metadata is initialized using a {@link IDatabaseConnection}. @author Manuel Laflamme @author Last changed by: $Author: jbhurst $ @version $Revision: 1134 $ $Date: 2010-01-07 18:32:54 -0200 (Qui, 07 Jan 2010) $ @since Mar 8, 2002 @see ITableMetaData">
			<comm cntt="added by hzhan032"/>
			<comm cntt=""/>
			<comm cntt="ITableMetaData interface"/>
			<comm cntt=""/>
			<comm cntt="Object class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_qualifiedTableNameSupport" access="priv" jdoc="Table name, potentially qualified"/>
			<const name="_originalTableName" access="priv" jdoc=""/>
			<const name="_connection" access="priv" jdoc=""/>
			<field name="_columns" access="priv" jdoc=""/>
			<field name="_primaryKeys" access="priv" jdoc=""/>
			<field name="_caseSensitiveMetaData" access="priv" jdoc=""/>
			<field name="lastKeyFilter" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.DatabaseTableMetaData(String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.DatabaseTableMetaData(String, IDatabaseConnection, boolean)" access="pub" jdoc="Creates a new database table metadata @param tableName The name of the table - can be fully qualified @param connection The database connection @param validate Whether or not to validate the given input data. It is not recommended to set the validation to &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; because it is then possible to create an instance of this object for a db table that does not exist. @throws DataSetException">
				<param name="tableName"/>
				<param name="connection"/>
				<param name="validate"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.DatabaseTableMetaData(String, IDatabaseConnection, boolean, boolean)" access="pub" jdoc="Creates a new database table metadata @param tableName The name of the table - can be fully qualified @param connection The database connection @param validate Whether or not to validate the given input data. It is not recommended to set the validation to &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; because it is then possible to create an instance of this object for a db table that does not exist. @param caseSensitiveMetaData Whether or not the metadata looked up in a case sensitive way @throws DataSetException @since 2.4.1">
				<comm cntt="qualified names support - table name and schema is stored here"/>
				<param name="tableName"/>
				<param name="connection"/>
				<param name="validate"/>
				<param name="caseSensitiveMetaData"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.createMetaData(String, ResultSet, IDataTypeFactory)" access="pub" jdoc="@param tableName @param resultSet @param dataTypeFactory @return The table metadata created for the given parameters @throws DataSetException @throws SQLException @deprecated since 2.3.0. use {@link ResultSetTableMetaData#ResultSetTableMetaData(String,ResultSet,IDataTypeFactory,boolean)}">
				<param name="tableName"/>
				<param name="resultSet"/>
				<param name="dataTypeFactory"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.createMetaData(String, ResultSet, IDatabaseConnection)" access="pub" jdoc="@param tableName @param resultSet @param connection @return The table metadata created for the given parameters @throws SQLException @throws DataSetException @deprecated since 2.3.0. use {@link org.dbunit.database.ResultSetTableMetaData#ResultSetTableMetaData(String,ResultSet,IDatabaseConnection,boolean)}">
				<param name="tableName"/>
				<param name="resultSet"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.getPrimaryKeyNames()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.getTableName()" access="pub" jdoc="">
				<comm cntt="Ensure that the same table name is returned as specified in the input."/>
				<comm cntt="This is necessary to support fully qualified XML dataset imports."/>
				<comm cntt="&amp;quot;&amp;lt;dataset&amp;gt;&amp;quot;"/>
				<comm cntt="&amp;quot;&amp;lt;FREJA.SALES SALES_ID=\&amp;quot;8756\&amp;quot; DEALER_ID=\&amp;quot;4467\&amp;quot; &amp;gt;&amp;quot;"/>
				<comm cntt="&amp;quot;&amp;lt;CAS.ORDERS ORDER_ID=\&amp;quot;1000\&amp;quot; DEALER_CODE=\&amp;quot;4468\&amp;quot; &amp;gt;&amp;quot;"/>
				<comm cntt="&amp;quot;&amp;lt; dataset&amp;gt;&amp;quot;;"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.getColumns()" access="pub" jdoc="">
				<comm cntt="qualified names support"/>
				<comm cntt="Check for exact table schema name match because"/>
				<comm cntt="databaseMetaData.getColumns() uses patterns for the lookup"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.primaryKeyFilterChanged(IColumnFilter)" access="priv" jdoc="">
				<param name="keyFilter"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.getPrimaryKeys()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData.toString()" access="pub" jdoc="">
			</mth>
		<class name="/:org.dbunit.database.DatabaseTableMetaData$PrimaryKeyData" intfc="n" abs="n" inn="y" sloc="24" jdoc="">
			<comm cntt=""/>
			<comm cntt="Comparable interface"/>
			<const name="_name" access="priv" jdoc=""/>
			<const name="_index" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData$PrimaryKeyData.PrimaryKeyData(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="index"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData$PrimaryKeyData.getName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData$PrimaryKeyData.getIndex()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseTableMetaData$PrimaryKeyData.compareTo(Object)" access="pub" jdoc="">
				<param name="o"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.database.DatabaseConfig" intfc="n" abs="n" inn="n" sloc="288" jdoc="Configuration used by the {@link DatabaseConnection}. @author manuel.laflamme @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1193 $ $Date: 2010-06-29 18:01:46 -0300 (Ter, 29 Jun 2010) $ @since 2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="PROPERTY_STATEMENT_FACTORY" access="pub" jdoc=""/>
			<const name="PROPERTY_RESULTSET_TABLE_FACTORY" access="pub" jdoc=""/>
			<const name="PROPERTY_DATATYPE_FACTORY" access="pub" jdoc=""/>
			<const name="PROPERTY_ESCAPE_PATTERN" access="pub" jdoc=""/>
			<const name="PROPERTY_TABLE_TYPE" access="pub" jdoc=""/>
			<const name="PROPERTY_PRIMARY_KEY_FILTER" access="pub" jdoc=""/>
			<const name="PROPERTY_BATCH_SIZE" access="pub" jdoc=""/>
			<const name="PROPERTY_FETCH_SIZE" access="pub" jdoc=""/>
			<const name="PROPERTY_METADATA_HANDLER" access="pub" jdoc=""/>
			<const name="FEATURE_CASE_SENSITIVE_TABLE_NAMES" access="pub" jdoc=""/>
			<const name="FEATURE_QUALIFIED_TABLE_NAMES" access="pub" jdoc=""/>
			<const name="FEATURE_BATCHED_STATEMENTS" access="pub" jdoc=""/>
			<const name="FEATURE_DATATYPE_WARNING" access="pub" jdoc=""/>
			<const name="FEATURE_SKIP_ORACLE_RECYCLEBIN_TABLES" access="pub" jdoc=""/>
			<const name="ALL_PROPERTIES" access="pub" jdoc="A list of all properties as {@link ConfigProperty} objects. The objects contain the allowed java type and whether or not a property is nullable."/>
			<const name="ALL_FEATURES" access="pub" jdoc="A list of all features as strings @deprecated since 2.4.7 Use the {@link #ALL_PROPERTIES} where features are listed now as well"/>
			<const name="DEFAULT_DATA_TYPE_FACTORY" access="priv" jdoc=""/>
			<const name="PREPARED_STATEMENT_FACTORY" access="priv" jdoc=""/>
			<const name="RESULT_SET_TABLE_FACTORY" access="priv" jdoc=""/>
			<const name="DEFAULT_ESCAPE_PATTERN" access="priv" jdoc=""/>
			<const name="DEFAULT_TABLE_TYPE" access="priv" jdoc=""/>
			<const name="DEFAULT_BATCH_SIZE" access="priv" jdoc=""/>
			<const name="DEFAULT_FETCH_SIZE" access="priv" jdoc=""/>
			<field name="_propertyMap" access="priv" jdoc=""/>
			<const name="configurator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseConfig.DatabaseConfig()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.getConfigurator()" access="prot" jdoc="@return The configurator of this database config">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.setFeature(String, boolean)" access="pub" jdoc="Set the value of a feature flag. @param name the feature id @param value the feature status @deprecated since 2.4.7 Use the {@link #setProperty(String,Object)} also for features">
				<param name="name"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.getFeature(String)" access="pub" jdoc="Look up the value of a feature flag. @param name the feature id @return the feature status @deprecated since 2.4.7 Use the {@link #getProperty(String)} where features are listed now as well">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.setProperty(String, Object)" access="pub" jdoc="Set the value of a property. @param name the property id @param value the property value">
				<comm cntt="Validate if the type of the given object is correct"/>
				<comm cntt="If we get here the type is allowed (no exception was thrown)"/>
				<param name="name"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.getProperty(String)" access="pub" jdoc="Look up the value of a property. @param name the property id @return the property value">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.convertIfNeeded(String, Object)" access="priv" jdoc="">
				<comm cntt="String -&amp;gt; Boolean is a special mapping which is allowed"/>
				<param name="property"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.checkObjectAllowed(String, Object)" access="prot" jdoc="Checks whether the given value has the correct java type for the given property. If the value is not allowed for the given property an {@link IllegalArgumentException} is thrown. @param property The property to be set @param value The value to which the property should be set">
				<comm cntt="First check for null"/>
				<comm cntt="All right. No class check is needed"/>
				<param name="property"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.setPropertiesByString(Properties)" access="pub" jdoc="Sets the given properties on the {@link DatabaseConfig} instance using the given String values. This is useful to set properties configured as strings by a build tool like ant or maven. If the required property type is an object it uses reflection to create an instance of the class specified as string. @param stringProperties The properties as strings. The key of the properties can be either the long or the short name. @throws DatabaseUnitException">
				<param name="stringProperties"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.createObjectFromString(ConfigProperty, String)" access="priv" jdoc="">
				<comm cntt="Null must not be casted"/>
				<comm cntt="Try via reflection"/>
				<param name="dbunitProp"/>
				<param name="propValue"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.createInstance(String)" access="priv" jdoc="">
				<comm cntt="Setup data type factory for example."/>
				<param name="className"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.findByName(String)" access="pub" jdoc="Searches the {@link ConfigProperty} object for the property with the given name @param property The property for which the enumerated object should be resolved @return The property object or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if it was not found.">
				<comm cntt="property not found."/>
				<param name="property"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.findByShortName(String)" access="pub" jdoc="Searches the {@link ConfigProperty} object for the property with the given name @param propShortName The property short name for which the enumerated object should be resolved. Example: the short name of {@value #PROPERTY_FETCH_SIZE} is &amp;lt;code&amp;gt;fetchSize&amp;lt; code&amp;gt; which is the last part of the fully qualified URL. @return The property object or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if it was not found.">
				<comm cntt="Property not found"/>
				<param name="propShortName"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig.toString()" access="pub" jdoc="">
			</mth>
		<class name="/:org.dbunit.database.DatabaseConfig$ConfigProperty" intfc="n" abs="n" inn="y" sloc="61" jdoc="@author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1193 $ $Date: 2010-06-29 18:01:46 -0300 (Ter, 29 Jun 2010) $ @since 2.4.0">
			<field name="property" access="priv" jdoc=""/>
			<field name="propertyType" access="priv" jdoc=""/>
			<field name="nullable" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseConfig$ConfigProperty.ConfigProperty(String, Class, boolean)" access="pub" jdoc="">
				<param name="property"/>
				<param name="propertyType"/>
				<param name="nullable"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig$ConfigProperty.getProperty()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig$ConfigProperty.getPropertyType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig$ConfigProperty.isNullable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig$ConfigProperty.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig$ConfigProperty.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig$ConfigProperty.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.DatabaseConfig$Configurator" intfc="n" abs="n" inn="y" sloc="20" jdoc="Sets parameters stored in the {@link DatabaseConfig} on specific java objects like {@link Statement}. Is mainly there to avoid code duplication where {@link DatabaseConfig} parameters are used. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1193 $ $Date: 2010-06-29 18:01:46 -0300 (Ter, 29 Jun 2010) $ @since 2.4.4">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="config" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseConfig$Configurator.Configurator(DatabaseConfig)" access="pub" jdoc="@param config The configuration to be used by this configurator @since 2.4.4">
				<param name="config"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseConfig$Configurator.configureStatement(Statement)" access="pub" jdoc="Configures the given statement so that it has the properties that are configured in this {@link DatabaseConfig}. @param stmt The statement to be configured. @throws SQLException @since 2.4.4">
				<param name="stmt"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.database.CyclicTablesDependencyException" intfc="n" abs="n" inn="n" sloc="14" jdoc="@author Manuel Laflamme @since Mar 23, 2003 @version $Revision: 918 $">
			<mth name="/:org.dbunit.database.CyclicTablesDependencyException.CyclicTablesDependencyException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
			<mth name="/:org.dbunit.database.CyclicTablesDependencyException.CyclicTablesDependencyException(String, Set)" access="pub" jdoc="@param tableName @param cyclicTableNames @since 2.4.2">
				<param name="tableName"/>
				<param name="cyclicTableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.CyclicTablesDependencyException.buildMessage(String, Set)" access="priv" jdoc="">
				<param name="tableName"/>
				<param name="cyclicTableNames"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.CachedResultSetTable" intfc="n" abs="n" inn="n" sloc="28" jdoc="@author Manuel Laflamme @version $Revision: 965 $ @since Feb 20, 2002">
			<comm cntt=""/>
			<comm cntt="IResultSetTable interface"/>
			<mth name="/:org.dbunit.database.CachedResultSetTable.CachedResultSetTable(ITableMetaData, ResultSet)" access="pub" jdoc="@param metaData @param resultSet @throws SQLException @throws DataSetException @deprecated since 2.3.0 prefer direct usage of {@link ForwardOnlyResultSetTable#ForwardOnlyResultSetTable(ITableMetaData,ResultSet)} and then invoke {@link CachedResultSetTable#CachedResultSetTable(IResultSetTable)}">
				<param name="metaData"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.database.CachedResultSetTable.CachedResultSetTable(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="@param metaData @param connection @throws SQLException @throws DataSetException @deprecated since 2.4.4 prefer direct usage of {@link ForwardOnlyResultSetTable#ForwardOnlyResultSetTable(ITableMetaData,IDatabaseConnection)} and then invoke {@link CachedResultSetTable#CachedResultSetTable(IResultSetTable)}">
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.CachedResultSetTable.CachedResultSetTable(IResultSetTable)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.database.CachedResultSetTable.close()" access="pub" jdoc="">
				<comm cntt="nothing to do, resultset already been closed"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.QueryDataSet" intfc="n" abs="n" inn="n" sloc="45" jdoc="Holds collection of tables resulting from database query. @author Eric Pugh @author gommma @author Last changed by: $Author: gommma $ @version $Revision: 912 $ $Date: 2008-12-06 14:01:42 -0200 (SÃ¡b, 06 Dez 2008) $ @since Dec 4, 2002">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_connection" access="priv" jdoc=""/>
			<const name="_tables" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.QueryDataSet.QueryDataSet(IDatabaseConnection)" access="pub" jdoc="Create a QueryDataSet by passing in the connection to the database to use. @param connection The connection object to the database.">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryDataSet.QueryDataSet(IDatabaseConnection, boolean)" access="pub" jdoc="Create a QueryDataSet by passing in the connection to the database to use. @param connection The connection object to the database. @param caseSensitiveTableNames Whether or not this dataset should use case sensitive table names @since 2.4.2">
				<param name="connection"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryDataSet.addTable(String, String)" access="pub" jdoc="Adds a table and it&amp;apos;s associated query to this dataset. @param tableName The name of the table @param query The query to retrieve data with for this table. Can be null which will select all data (see {@link #addTable(String)} for details) @throws AmbiguousTableNameException">
				<param name="tableName"/>
				<param name="query"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryDataSet.addTable(String)" access="pub" jdoc="Adds a table with using &amp;apos;SELECT FROM &amp;lt;code&amp;gt;tableName&amp;lt; code&amp;gt;&amp;apos; as query. @param tableName The name of the table @throws AmbiguousTableNameException">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
		<class name="/:org.dbunit.database.QueryDataSet$TableEntry" intfc="n" abs="n" inn="y" sloc="18" jdoc="Represents a table and a SQL query that should be used to retrieve the data for this table.">
			<const name="_tableName" access="priv" jdoc=""/>
			<const name="_query" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.QueryDataSet$TableEntry.TableEntry(String, String)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="query"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryDataSet$TableEntry.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.QueryDataSet$TableEntry.getQuery()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.database.IResultSetTable" intfc="y" abs="n" inn="n" sloc="4" jdoc="@author Manuel Laflamme @since Apr 10, 2003 @version $Revision: 398 $">
			<mth name="/:org.dbunit.database.IResultSetTable.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.IMetadataHandler" intfc="y" abs="n" inn="n" sloc="16" jdoc="Handler to specify the behavior for a lookup of column metadata using database metadata. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 979 $ $Date: 2009-03-03 14:39:37 -0300 (Ter, 03 Mar 2009) $ @since 2.4.4">
			<mth name="/:org.dbunit.database.IMetadataHandler.getColumns(DatabaseMetaData, String, String)" access="pub" jdoc="Returns the result set for an invocation of {@link DatabaseMetaData#getColumns(String,String,String,String)}. @param databaseMetaData The database metadata to be used for retrieving the columns @param schemaName The schema name @param tableName The table name @return The result set containing all columns @throws SQLException @since 2.4.4">
				<param name="databaseMetaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.IMetadataHandler.matches(ResultSet, String, String, boolean)" access="pub" jdoc="Checks if the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table name. The comparison is &amp;lt;b&amp;gt;case sensitive&amp;lt; b&amp;gt;. @param resultSet A result set produced via {@link DatabaseMetaData#getColumns(String,String,String,String)} @param schema @param table @param caseSensitive Whether or not the comparison should be case sensitive @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the column metadata of the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table parameters. @throws SQLException @see #matches(ResultSet,String,String,String,String,boolean) @since 2.4.4">
				<param name="resultSet"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.database.IMetadataHandler.matches(ResultSet, String, String, String, String, boolean)" access="pub" jdoc="Checks if the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table name. The comparison is &amp;lt;b&amp;gt;case sensitive&amp;lt; b&amp;gt;. @param resultSet A result set produced via {@link DatabaseMetaData#getColumns(String,String,String,String)} @param catalog The name of the catalog to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param schema The name of the schema to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param table The name of the table to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param column The name of the column to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param caseSensitive Whether or not the comparison should be case sensitive @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the column metadata of the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table parameters. @throws SQLException @since 2.4.4">
				<param name="resultSet"/>
				<param name="catalog"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="column"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.database.IMetadataHandler.getSchema(ResultSet)" access="pub" jdoc="Returns the schema name to which the table of the current result set index belongs. @param resultSet The result set pointing to a valid record in the database that was returned by {@link DatabaseMetaData#getTables(String,String,String,String[])}. @return The name of the schema from the given result set @since 2.4.4">
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.database.IMetadataHandler.tableExists(DatabaseMetaData, String, String)" access="pub" jdoc="Checks if the given table exists. @param databaseMetaData The database meta data @param schemaName The schema in which the table should be searched. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; the schema is not used to narrow the table name. @param tableName The table name to be searched @return Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the given table exists in the given schema. Else returns &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt;. @throws SQLException @since 2.4.5">
				<param name="databaseMetaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.IMetadataHandler.getTables(DatabaseMetaData, String, String[])" access="pub" jdoc="Returns the tables in the given schema that matches one of the given tableTypes. @param databaseMetaData The database meta data @param schemaName schema for which the tables should be retrieved; &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; returns all schemas @param tableTypes a list of table types to include; &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; returns all types @return The ResultSet which is retrieved using {@link DatabaseMetaData#getTables(String,String,String,String[])} @throws SQLException @since 2.4.5">
				<param name="databaseMetaData"/>
				<param name="schemaName"/>
				<param name="tableTypes"/>
			</mth>
			<mth name="/:org.dbunit.database.IMetadataHandler.getPrimaryKeys(DatabaseMetaData, String, String)" access="pub" jdoc="@param databaseMetaData The database meta data @param schemaName schema for which the tables should be retrieved; &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; returns all schemas @param tableName table for which the primary keys are retrieved @return The ResultSet which is retrieved using {@link DatabaseMetaData#getPrimaryKeys(String,String,String)} @throws SQLException @since 2.4.5">
				<param name="databaseMetaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.DatabaseDataSourceConnection" intfc="n" abs="n" inn="n" sloc="88" jdoc="This class adapts a JDBC &amp;lt;code&amp;gt;DataSource&amp;lt; code&amp;gt; to a{@link IDatabaseConnection}. @author Manuel Laflamme @version $Revision: 1188 $ @since Mar 8, 2002">
			<comm cntt=""/>
			<comm cntt="IDatabaseConnection interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_schema" access="priv" jdoc=""/>
			<const name="_dataSource" access="priv" jdoc=""/>
			<const name="_user" access="priv" jdoc=""/>
			<const name="_password" access="priv" jdoc=""/>
			<field name="_connection" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(InitialContext, String, String)" access="pub" jdoc="">
				<param name="context"/>
				<param name="jndiName"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(InitialContext, String, String, String, String)" access="pub" jdoc="">
				<param name="context"/>
				<param name="jndiName"/>
				<param name="schema"/>
				<param name="user"/>
				<param name="password"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(InitialContext, String)" access="pub" jdoc="">
				<param name="context"/>
				<param name="jndiName"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(InitialContext, String, String, String)" access="pub" jdoc="">
				<param name="context"/>
				<param name="jndiName"/>
				<param name="user"/>
				<param name="password"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(DataSource)" access="pub" jdoc="">
				<param name="dataSource"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(DataSource, String, String)" access="pub" jdoc="">
				<param name="dataSource"/>
				<param name="user"/>
				<param name="password"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(DataSource, String)" access="pub" jdoc="">
				<param name="dataSource"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.DatabaseDataSourceConnection(DataSource, String, String, String)" access="pub" jdoc="">
				<param name="dataSource"/>
				<param name="schema"/>
				<param name="user"/>
				<param name="password"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.getConnection()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.getSchema()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSourceConnection.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.AbstractDatabaseConnection" intfc="n" abs="y" inn="n" sloc="107" jdoc="@author Manuel Laflamme @version $Revision: 1186 $ @since Mar 6, 2002">
			<comm cntt=""/>
			<comm cntt="IDatabaseConnection interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_dataSet" access="priv" jdoc=""/>
			<const name="_databaseConfig" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.AbstractDatabaseConnection()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.createDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.createDataSet(String[])" access="pub" jdoc="">
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.createQueryTable(String, String)" access="pub" jdoc="">
				<param name="resultName"/>
				<param name="sql"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.createTable(String, PreparedStatement)" access="pub" jdoc="">
				<param name="resultName"/>
				<param name="preparedStatement"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.createTable(String)" access="pub" jdoc="">
				<comm cntt="TODO Think about QualifiedTableNames here - needed or not?"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.getRowCount(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.getRowCount(String, String)" access="pub" jdoc="">
				<comm cntt="add table name and schema (schema only if available)"/>
				<param name="tableName"/>
				<param name="whereClause"/>
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.getConfig()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.getStatementFactory()" access="pub" jdoc="@deprecated Use {@link #getConfig}">
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.getResultSetTableFactory()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.AbstractDatabaseConnection.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.PrimaryKeyFilteredTableWrapper" intfc="n" abs="n" inn="n" sloc="56" jdoc="This class is a wrapper for another table with the condition that only a subset of the original table will be available - the subset is defined by the set of primary keys that are allowed in the new table. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Sep 9, 2005">
			<comm cntt="ITable methods"/>
			<const name="originalTable" access="priv" jdoc="reference to the original table being wrapped"/>
			<const name="filteredRowsMapping" access="priv" jdoc="mapping of filtered rows, i.e, each entry on this list has the value of the index on the original table corresponding to the desired index. For instance, if the original table is: row PK Value 0 pk1 v1 1 pk2 v2 2 pk3 v3 3 pk4 v4 And the allowed PKs are pk2 and pk4, the new table should be: row PK Value 0 pk2 v2 1 pk4 v4 Consequently, the mapping will be {1, 3}"/>
			<const name="logger" access="prot" jdoc="logger"/>
			<mth name="/:org.dbunit.database.PrimaryKeyFilteredTableWrapper.PrimaryKeyFilteredTableWrapper(ITable, Set)" access="pub" jdoc="Creates a PKFilteredTable given an original table and the allowed primary keys for that table. @param table original table @param allowedPKs primary keys allowed on the new table @throws DataSetException if something happened while getting the information">
				<comm cntt="sets the rows for the new table"/>
				<comm cntt="NOTE: this conversion might be an issue for long tables, as it iterates for"/>
				<comm cntt="all values of the original table and that might take time and memory leaks."/>
				<comm cntt="So, this mapping mechanism is a candidate for improvement: another alternative"/>
				<comm cntt="would be to calculate the mapping on the fly, as getValue() is called (and in"/>
				<comm cntt="this case, getRowCount() would be simply the sise of allowedPKs)"/>
				<param name="table"/>
				<param name="allowedPKs"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilteredTableWrapper.setRows(Set)" access="priv" jdoc="This method is used to calculate the mapping between the rows of the original and the filtered tables. @param allowedPKs primary keys allowed in the new table @return list of rows for the new table @throws DataSetException">
				<comm cntt="TODO: support multi-columns PKs"/>
				<param name="allowedPKs"/>
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilteredTableWrapper.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilteredTableWrapper.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.PrimaryKeyFilteredTableWrapper.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="column"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.DatabaseDataSet" intfc="n" abs="n" inn="n" sloc="186" jdoc="Provides access to a database instance as a {@link IDataSet}. @author Manuel Laflamme @author Last changed by: $Author: jeffjensen $ @version $Revision: 1189 $ $Date: 2010-06-05 19:49:22 -0300 (SÃ¡b, 05 Jun 2010) $ @since 1.0 (Feb 17, 2002)">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_connection" access="priv" jdoc=""/>
			<field name="_tableMap" access="priv" jdoc=""/>
			<const name="_tableFilter" access="priv" jdoc=""/>
			<const name="_oracleRecycleBinTableFilter" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseDataSet.DatabaseDataSet(IDatabaseConnection)" access="pub" jdoc="Creates a new database data set @param connection @throws SQLException">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.DatabaseDataSet(IDatabaseConnection, boolean)" access="pub" jdoc="Creates a new database data set @param connection The database connection @param caseSensitiveTableNames Whether or not this dataset should use case sensitive table names @throws SQLException @since 2.4">
				<param name="connection"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.DatabaseDataSet(IDatabaseConnection, boolean, ITableFilterSimple)" access="pub" jdoc="Creates a new database data set @param connection The database connection @param caseSensitiveTableNames Whether or not this dataset should use case sensitive table names @param tableFilter Table filter to specify tables to be omitted in this dataset. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;. @throws SQLException @since 2.4.3">
				<param name="connection"/>
				<param name="caseSensitiveTableNames"/>
				<param name="tableFilter"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.getSelectStatement(String, ITableMetaData, String)" access="pub" jdoc="">
				<comm cntt="select"/>
				<comm cntt="from"/>
				<comm cntt="order by"/>
				<param name="schema"/>
				<param name="metaData"/>
				<param name="escapePattern"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.initialize()" access="priv" jdoc="Get all the table names form the database that are not system tables.">
				<comm cntt="Put the table into the table map"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<comm cntt="Verify if table exist in the database"/>
				<comm cntt="Try to find cached metadata"/>
				<comm cntt="Create metadata and cache it"/>
				<comm cntt="Put the metadata object into the cache map"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		<class name="/:org.dbunit.database.DatabaseDataSet$OracleRecycleBinTableFilter" intfc="n" abs="n" inn="y" sloc="18" jdoc="">
			<const name="_config" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.DatabaseDataSet$OracleRecycleBinTableFilter.OracleRecycleBinTableFilter(DatabaseConfig)" access="pub" jdoc="">
				<param name="config"/>
			</mth>
			<mth name="/:org.dbunit.database.DatabaseDataSet$OracleRecycleBinTableFilter.accept(String)" access="pub" jdoc="">
				<comm cntt="skip oracle 10g recycle bin system tables if enabled"/>
				<comm cntt="Oracle 10g workaround"/>
				<comm cntt="don&amp;apos;t process system tables (oracle recycle bin tables) which"/>
				<comm cntt="are reported to the application due a bug in the oracle JDBC driver"/>
				<param name="tableName"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.database.QueryTableIterator" intfc="n" abs="n" inn="n" sloc="81" jdoc="Iterator used to iterate over a list of tables using a specific query for retrieving data for every table. @author Manuel Laflamme @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 885 $ $Date: 2008-11-23 09:49:32 -0200 (Dom, 23 Nov 2008) $ @since 1.5.6 (Sep 15, 2003)">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tableEntries" access="priv" jdoc=""/>
			<const name="_connection" access="priv" jdoc=""/>
			<field name="_currentTable" access="priv" jdoc=""/>
			<field name="_index" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.QueryTableIterator.QueryTableIterator(List, IDatabaseConnection)" access="pub" jdoc="@param tableEntries list of {@link TableEntry} objects @param connection The database connection needed to load data">
				<param name="tableEntries"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryTableIterator.next()" access="pub" jdoc="{@inheritDoc}">
				<comm cntt="Ensure previous table is closed"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryTableIterator.getTableMetaData()" access="pub" jdoc="{@inheritDoc}">
				<comm cntt="No query specified, use metadata from dataset"/>
			</mth>
			<mth name="/:org.dbunit.database.QueryTableIterator.getTable()" access="pub" jdoc="{@inheritDoc}">
				<comm cntt="No query specified, use table from dataset"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.ScrollableResultSetTable" intfc="n" abs="n" inn="n" sloc="83" jdoc="@author Manuel Laflamme @version $Revision: 679 $ @since Feb 17, 2002">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_rowCount" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.ScrollableResultSetTable.ScrollableResultSetTable(ITableMetaData, ResultSet)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.database.ScrollableResultSetTable.ScrollableResultSetTable(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ScrollableResultSetTable.ScrollableResultSetTable(String, String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="selectStatement"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.ScrollableResultSetTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.ScrollableResultSetTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="columnName"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.database.search">
		<class name="/:org.dbunit.database.search.ImportedKeysSearchCallback" intfc="n" abs="n" inn="n" sloc="11" jdoc="ISearchCallback implementation that get the nodes using direct foreign key dependency, i.e, if table A has a FK for a table B, then getNodes(A) will return B. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.search.ImportedKeysSearchCallback.ImportedKeysSearchCallback(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedKeysSearchCallback.getEdges(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.ImportedKeysSearchCallbackFilteredByPKs" intfc="n" abs="n" inn="n" sloc="25" jdoc="Extension of the ImportedKeysSearchCallback, where each new edge is added to a PrimaryKeyFilter. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 806 $ @since Sep 9, 2005">
			<comm cntt="primary key filter associated with the call back"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="pksFilter" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.search.ImportedKeysSearchCallbackFilteredByPKs.ImportedKeysSearchCallbackFilteredByPKs(IDatabaseConnection, PkTableMap)" access="pub" jdoc="Default constructor. @param connection database connection @param allowedPKs map of allowed rows, based on the primary keys (key is the name of a table; value is a Set with allowed primary keys for that table)">
				<param name="connection"/>
				<param name="allowedPKs"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedKeysSearchCallbackFilteredByPKs.getFilter()" access="pub" jdoc="Get the primary key filter associated with the call back @return primary key filter associated with the call back">
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedKeysSearchCallbackFilteredByPKs.nodeAdded(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedKeysSearchCallbackFilteredByPKs.newEdge(ResultSet, int, String, String, String, String)" access="prot" jdoc="">
				<param name="rs"/>
				<param name="type"/>
				<param name="from"/>
				<param name="to"/>
				<param name="fkColumn"/>
				<param name="pkColumn"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.ForeignKeyRelationshipEdge" intfc="n" abs="n" inn="n" sloc="47" jdoc="Implementation of an edge representing a foreign key (FK) relationship between two tables.&amp;lt;br&amp;gt; The &amp;lt;code&amp;gt;from&amp;lt; code&amp;gt; node is the table which have the FK, while the &amp;lt;code&amp;gt;to&amp;lt; code&amp;gt; node is the table with the PK. In other words, the edge A-&amp;gt;B means FK(A) = PK(B).&amp;lt;br&amp;gt; &amp;lt;strong&amp;gt;NOTE:&amp;lt; strong&amp;gt; only single-column PKs are supported at this moment @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 826 $ $Date: 2008-10-05 14:42:03 -0300 (Dom, 05 Out 2008) $ @since 2.2 (Sep 9, 2005)">
			<field name="fkColumn" access="priv" jdoc=""/>
			<field name="pkColumn" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.search.ForeignKeyRelationshipEdge.ForeignKeyRelationshipEdge(String, String, String, String)" access="pub" jdoc="Creates an edge representing a FK. @param tableFrom table that has the FK @param tableTo table that has the PK @param fkColumn name of the FK column on tableFrom @param pkColumn name of the PK column on tableTo">
				<param name="tableFrom"/>
				<param name="tableTo"/>
				<param name="fkColumn"/>
				<param name="pkColumn"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ForeignKeyRelationshipEdge.getFKColumn()" access="pub" jdoc="Gets the name of the foreign key column in the relationship. @return name of the foreign key column in the relationship.">
			</mth>
			<mth name="/:org.dbunit.database.search.ForeignKeyRelationshipEdge.getPKColumn()" access="pub" jdoc="Gets the name of the primary key column in the relationship. @return name of the primary key column in the relationship.">
			</mth>
			<mth name="/:org.dbunit.database.search.ForeignKeyRelationshipEdge.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.search.ForeignKeyRelationshipEdge.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.search.ForeignKeyRelationshipEdge.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallback" intfc="n" abs="n" inn="n" sloc="13" jdoc="ISearchCallback implementation that get the nodes using both direct and reverse foreign key dependency, i.e, if table C has a FK for a table A and table A has a FK for a table B, then getNodes(A) will return B and C. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallback.ImportedAndExportedKeysSearchCallback(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallback.getEdges(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.ExportedKeysSearchCallback" intfc="n" abs="n" inn="n" sloc="11" jdoc="ISearchCallback implementation that get the nodes using direct foreign key dependency, i.e, if table A has a FK for a table B, then getNodes(B) will return A. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 843 $ $Date: 2008-10-26 09:06:28 -0200 (Dom, 26 Out 2008) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.search.ExportedKeysSearchCallback.ExportedKeysSearchCallback(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ExportedKeysSearchCallback.getEdges(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback" intfc="n" abs="y" inn="n" sloc="132" jdoc="Super-class for the ISearchCallback that implements the &amp;lt;code&amp;gt;getEdges()&amp;lt; code&amp;gt; method using the database meta-data. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 1075 $ @since Aug 25, 2005">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="connection" access="priv" jdoc=""/>
			<const name="IMPORT" access="prot" jdoc=""/>
			<const name="EXPORT" access="prot" jdoc=""/>
			<const name="TABLENAME_INDEXES" access="prot" jdoc="indexes of the column names on the MetaData result sets."/>
			<const name="SCHEMANAME_INDEXES" access="prot" jdoc=""/>
			<const name="PK_INDEXES" access="prot" jdoc=""/>
			<const name="FK_INDEXES" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.AbstractMetaDataBasedSearchCallback(IDatabaseConnection)" access="pub" jdoc="Default constructor. @param connection connection where the edges will be calculated from">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.getConnection()" access="pub" jdoc="Get the connection where the edges will be calculated from. @return the connection where the edges will be calculated from">
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.getNodesFromImportedKeys(Object)" access="prot" jdoc="Get the nodes using the direct foreign key dependency, i.e, if table A has a FK for a table B, then getNodesFromImportedKeys(A) will return B. @param node table name @return tables with direct FK dependency from node @throws SearchException">
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.getNodesFromExportedKeys(Object)" access="prot" jdoc="Get the nodes using the reverse foreign key dependency, i.e, if table C has a FK for a table A, then getNodesFromExportedKeys(A) will return C.&amp;lt;br&amp;gt; &amp;lt;strong&amp;gt;NOTE:&amp;lt; strong&amp;gt; this method should be used only as an auxiliary method for sub-classes that also use &amp;lt;code&amp;gt;getNodesFromImportedKeys()&amp;lt; code&amp;gt; or something similar, otherwise the generated sequence of tables might not work when inserted in the database (as some tables might be missing). &amp;lt;br&amp;gt; @param node table name @return tables with reverse FK dependency from node @throws SearchException">
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.getNodesFromImportAndExportKeys(Object)" access="prot" jdoc="Get the nodes using the both direct and reverse foreign key dependency, i.e, if table C has a FK for a table A and table A has a FK for a table B, then getNodesFromImportAndExportedKeys(A) will return B and C. @param node table name @return tables with reverse and direct FK dependency from node @throws SearchException">
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.getNodes(int, Object)" access="priv" jdoc="">
				<param name="type"/>
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.getNodes(int, Object, Connection, String, DatabaseMetaData, SortedSet)" access="priv" jdoc="">
				<comm cntt="Validate if the table exists"/>
				<comm cntt="set the schema in front if there is none (&amp;quot;SCHEMA.TABLE&amp;quot;) - depending on the &amp;quot;qualified table names&amp;quot; feature"/>
				<param name="type"/>
				<param name="node"/>
				<param name="conn"/>
				<param name="schema"/>
				<param name="metaData"/>
				<param name="edges"/>
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.createFKEdge(ResultSet, int, String, String, String, String)" access="prot" jdoc="Creates an edge representing a foreign key relationship between 2 tables.&amp;lt;br&amp;gt; @param rs database meta-data result set @param type type of relationship (IMPORT or EXPORT) @param from name of the table representing the &amp;apos;from&amp;apos; node @param to name of the table representing the &amp;apos;to&amp;apos; node @param fkColumn name of the foreign key column @param pkColumn name of the primary key column @return edge representing the relationship between the 2 tables, according to the type @throws SearchException not thrown in this method (but might on sub-classes)">
				<param name="rs"/>
				<param name="type"/>
				<param name="from"/>
				<param name="to"/>
				<param name="fkColumn"/>
				<param name="pkColumn"/>
			</mth>
			<mth name="/:org.dbunit.database.search.AbstractMetaDataBasedSearchCallback.newEdge(ResultSet, int, String, String, String, String)" access="prot" jdoc="This method can be overwritten by the sub-classes if they need to decorate the edge (for instance, providing an Edge that contains the primary and foreign keys used). @param rs database meta-data result set @param type type of relationship (IMPORT or EXPORT) @param from name of the table representing the &amp;apos;from&amp;apos; node @param to name of the table representing the &amp;apos;to&amp;apos; node @param fkColumn name of the foreign key column @param pkColumn name of the primary key column @return edge representing the relationship between the 2 tables, according to the type @throws SearchException not thrown in this method (but might on sub-classes)">
				<param name="rs"/>
				<param name="type"/>
				<param name="from"/>
				<param name="to"/>
				<param name="fkColumn"/>
				<param name="pkColumn"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.FKRelationshipEdge" intfc="n" abs="n" inn="n" sloc="18" jdoc="FIXME remove - duplicates {@link ForeignKeyRelationshipEdge} @author Felipe Leme @author Last changed by: $Author: gommma $ @version $Revision: 800 $ $Date: 2008-09-06 17:16:09 -0300 (SÃ¡b, 06 Set 2008) $ @since 2.2.0 @deprecated this class duplicates {@link ForeignKeyRelationshipEdge} and should be removed">
			<comm cntt="TODO: support multiple columns"/>
			<comm cntt="TODO: hashcode and equals"/>
			<field name="fkColumn" access="priv" jdoc=""/>
			<field name="pkColumn" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.search.FKRelationshipEdge.FKRelationshipEdge(String, String, String, String)" access="pub" jdoc="">
				<param name="tableFrom"/>
				<param name="tableTo"/>
				<param name="fkColumn"/>
				<param name="pkColumn"/>
			</mth>
			<mth name="/:org.dbunit.database.search.FKRelationshipEdge.getFKColumn()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.search.FKRelationshipEdge.getPKColumn()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.search.FKRelationshipEdge.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.TablesDependencyHelper" intfc="n" abs="n" inn="n" sloc="116" jdoc="Helper for the graph-search based classes used to calculate dependency among tables. @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 843 $ $Date: 2008-10-26 09:06:28 -0200 (Dom, 26 Out 2008) $ @since Aug 26, 2005">
			<comm cntt="this is a &amp;quot;static&amp;quot; class"/>
			<comm cntt="TODO: javadoc (and unit tests) from down here..."/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.TablesDependencyHelper()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getDependentTables(IDatabaseConnection, String)" access="pub" jdoc="Get the name of all tables that depend on the root tables (i.e, all tables that have FKs pointing to the PK of the root table). @param connection database connection @param rootTable root table described above @return name of all tables that depend on the root table (including the root table), in the right order for insertions @throws SearchException if an exception occurred while calculating the order">
				<param name="connection"/>
				<param name="rootTable"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getDependentTables(IDatabaseConnection, String[])" access="pub" jdoc="Get the name of all tables that depend on the root tables (i.e, all tables that have FKs pointing to the PK of one of the root tables). @param connection database connection @param rootTables array of root tables described above @return name of all tables that depend on the root tables (including the root tables), in the right order for insertions @throws SearchException if an exception occurred while calculating the order">
				<param name="connection"/>
				<param name="rootTables"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getDependsOnTables(IDatabaseConnection, String)" access="pub" jdoc="Get the name of all tables that the given rootTable depends on (i.e, all tables whose PK is a FK for the root table). @param connection database connection @param rootTable root table described above @return name of all tables that the rootTable depends on (including the rootTable itself), in the right order for insertions @throws SearchException if an exception occurred while calculating the order @since 2.4">
				<param name="connection"/>
				<param name="rootTable"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getAllDependentTables(IDatabaseConnection, String)" access="pub" jdoc="Get the name of all tables that depend on a root table ( i.e, all tables whose PK is a FK for the root table) and also the tables the root table depends on (i.e., all tables which have a FK for the root table&amp;apos;s PK). @param connection database connection @param rootTable root table described above @return name of all tables that depend on the root table (including the root table), in the right order for insertions @throws SearchException if an exception occurred while calculating the order">
				<param name="connection"/>
				<param name="rootTable"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getAllDependentTables(IDatabaseConnection, String[])" access="pub" jdoc="Get the name of all tables that depend on the root tables ( i.e, all tables whose PK is a FK for any of the root tables) and also the tables the root tables depends on (i.e., all tables which have a FK for any of the root table&amp;apos;s PK). @param connection database connection @param rootTables root tables described above @return name of all tables that depend on the root tables (including the root tables), in the right order for insertions @throws SearchException if an exception occurred while calculating the order">
				<param name="connection"/>
				<param name="rootTables"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getDataset(IDatabaseConnection, String, Set)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="rootTable"/>
				<param name="allowedIds"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getDataset(IDatabaseConnection, PkTableMap)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="rootTables"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getAllDataset(IDatabaseConnection, String, Set)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="rootTable"/>
				<param name="allowedPKs"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getAllDataset(IDatabaseConnection, PkTableMap)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="rootTables"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getDirectDependsOnTables(IDatabaseConnection, String)" access="pub" jdoc="Returns a set of tables on which the given table directly depends on. @param connection The connection to be used for the database lookup. @param tableName @return a set of tables on which the given table directly depends on. @throws SearchException @since 2.4">
				<comm cntt="Do a depthFirstSearch with a recursion depth of 1"/>
				<param name="connection"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.database.search.TablesDependencyHelper.getDirectDependentTables(IDatabaseConnection, String)" access="pub" jdoc="Returns a set of tables which directly depend on the given table. @param connection The connection to be used for the database lookup. @param tableName @return a set of tables on which the given table directly depends on. @throws SearchException @since 2.4">
				<comm cntt="Do a depthFirstSearch with a recursion depth of 1"/>
				<param name="connection"/>
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallbackFilteredByPKs" intfc="n" abs="n" inn="n" sloc="30" jdoc="Extension of the ImportedAndExportedKeysSearchCallback, where each new edge is added to a PrimaryKeyFilter. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 806 $ @since Sep 9, 2005">
			<comm cntt="primary key filter associated with the call back"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="pksFilter" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallbackFilteredByPKs.ImportedAndExportedKeysSearchCallbackFilteredByPKs(IDatabaseConnection, PkTableMap)" access="pub" jdoc="Default constructor. @param connectiondatabase connection @param allowedPKsmap of allowed rows, based on the primary keys (key is the name of a table; value is a Set with allowed primary keys for that table)">
				<param name="connection"/>
				<param name="allowedPKs"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallbackFilteredByPKs.getFilter()" access="pub" jdoc="Get the primary key filter associated with the call back @return primary key filter associated with the call back">
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallbackFilteredByPKs.nodeAdded(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.database.search.ImportedAndExportedKeysSearchCallbackFilteredByPKs.newEdge(ResultSet, int, String, String, String, String)" access="prot" jdoc="">
				<param name="rs"/>
				<param name="type"/>
				<param name="from"/>
				<param name="to"/>
				<param name="fkColumn"/>
				<param name="pkColumn"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.database.statement">
		<class name="/:org.dbunit.database.statement.SimplePreparedStatement" intfc="n" abs="n" inn="n" sloc="47" jdoc="@author Manuel Laflamme @version $Revision: 672 $ @since Mar 16, 2002">
			<comm cntt=""/>
			<comm cntt="IPreparedBatchStatement interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_index" access="priv" jdoc=""/>
			<field name="_result" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.SimplePreparedStatement.SimplePreparedStatement(String, Connection)" access="pub" jdoc="">
				<param name="sql"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.SimplePreparedStatement.addValue(Object, DataType)" access="pub" jdoc="">
				<comm cntt="Special NULL handling"/>
				<param name="value"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.SimplePreparedStatement.addBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.SimplePreparedStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.SimplePreparedStatement.clearBatch()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.AbstractStatementFactory" intfc="n" abs="y" inn="n" sloc="14" jdoc="@author Manuel Laflamme @version $Revision: 672 $ @since Apr 10, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.statement.AbstractStatementFactory.supportBatchStatement(IDatabaseConnection)" access="prot" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if target database supports batch statement.">
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.IPreparedBatchStatement" intfc="y" abs="n" inn="n" sloc="9" jdoc="@author Manuel Laflamme @version $Revision: 398 $ @since Mar 15, 2002">
			<mth name="/:org.dbunit.database.statement.IPreparedBatchStatement.addValue(Object, DataType)" access="pub" jdoc="">
				<param name="value"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.IPreparedBatchStatement.addBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.IPreparedBatchStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.IPreparedBatchStatement.clearBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.IPreparedBatchStatement.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.AutomaticPreparedBatchStatement" intfc="n" abs="n" inn="n" sloc="46" jdoc="@author Manuel Laflamme @since Jun 12, 2003 @version $Revision: 672 $">
			<comm cntt=""/>
			<comm cntt="IPreparedBatchStatement interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_statement" access="priv" jdoc=""/>
			<field name="_batchCount" access="priv" jdoc=""/>
			<field name="_threshold" access="priv" jdoc=""/>
			<field name="_result" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.AutomaticPreparedBatchStatement.AutomaticPreparedBatchStatement(IPreparedBatchStatement, int)" access="pub" jdoc="">
				<param name="statement"/>
				<param name="threshold"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.AutomaticPreparedBatchStatement.addValue(Object, DataType)" access="pub" jdoc="">
				<param name="value"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.AutomaticPreparedBatchStatement.addBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.AutomaticPreparedBatchStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.AutomaticPreparedBatchStatement.clearBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.AutomaticPreparedBatchStatement.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.AbstractPreparedBatchStatement" intfc="n" abs="y" inn="n" sloc="15" jdoc="@author Manuel Laflamme @version $Revision: 675 $ @since Mar 16, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_statement" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.AbstractPreparedBatchStatement.AbstractPreparedBatchStatement(String, Connection)" access="pub" jdoc="">
				<param name="sql"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.AbstractPreparedBatchStatement.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.SimpleStatement" intfc="n" abs="n" inn="n" sloc="36" jdoc="@author Manuel Laflamme @version $Revision: 920 $ @since Feb 20, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_list" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.SimpleStatement.SimpleStatement(Connection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.SimpleStatement.addBatch(String)" access="pub" jdoc="">
				<param name="sql"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.SimpleStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.SimpleStatement.clearBatch()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.IBatchStatement" intfc="y" abs="n" inn="n" sloc="7" jdoc="@author Manuel Laflamme @version $Revision: 398 $ @since Mar 15, 2002">
			<mth name="/:org.dbunit.database.statement.IBatchStatement.addBatch(String)" access="pub" jdoc="">
				<param name="sql"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.IBatchStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.IBatchStatement.clearBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.IBatchStatement.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.AbstractBatchStatement" intfc="n" abs="y" inn="n" sloc="22" jdoc="@author Manuel Laflamme @version $Revision: 1188 $ @since Mar 15, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_statement" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.AbstractBatchStatement.AbstractBatchStatement(Connection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.AbstractBatchStatement.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.IStatementFactory" intfc="y" abs="n" inn="n" sloc="7" jdoc="@author Manuel Laflamme @version $Revision: 398 $ @since Mar 16, 2002">
			<mth name="/:org.dbunit.database.statement.IStatementFactory.createBatchStatement(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.IStatementFactory.createPreparedBatchStatement(String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="sql"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.PreparedBatchStatement" intfc="n" abs="n" inn="n" sloc="44" jdoc="@author Manuel Laflamme @version $Revision: 672 $ @since Mar 16, 2002">
			<comm cntt=""/>
			<comm cntt="IPreparedBatchStatement interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_index" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.PreparedBatchStatement.PreparedBatchStatement(String, Connection)" access="pub" jdoc="">
				<param name="sql"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.PreparedBatchStatement.addValue(Object, DataType)" access="pub" jdoc="">
				<comm cntt="Special NULL handling"/>
				<param name="value"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.PreparedBatchStatement.addBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.PreparedBatchStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.PreparedBatchStatement.clearBatch()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.BatchStatement" intfc="n" abs="n" inn="n" sloc="29" jdoc="@author Manuel Laflamme @version $Revision: 672 $ @since Feb 20, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.statement.BatchStatement.BatchStatement(Connection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatement.addBatch(String)" access="pub" jdoc="">
				<param name="sql"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatement.clearBatch()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.CompoundStatement" intfc="n" abs="n" inn="n" sloc="25" jdoc="@author Manuel Laflamme @version $Revision: 672 $ @since Feb 20, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_buffer" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.CompoundStatement.CompoundStatement(Connection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.CompoundStatement.addBatch(String)" access="pub" jdoc="">
				<param name="sql"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.CompoundStatement.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.CompoundStatement.clearBatch()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.BatchStatementDecorator" intfc="n" abs="n" inn="n" sloc="56" jdoc="@author Manuel Laflamme @version $Revision: 672 $ @since Mar 16, 2002">
			<comm cntt=""/>
			<comm cntt="IPreparedBatchStatement interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_statement" access="priv" jdoc=""/>
			<const name="_sqlTemplate" access="priv" jdoc=""/>
			<field name="_sqlBuffer" access="priv" jdoc=""/>
			<field name="_index" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.database.statement.BatchStatementDecorator.BatchStatementDecorator(String, IBatchStatement)" access="pub" jdoc="">
				<comm cntt="reset sql buffer"/>
				<param name="sql"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatementDecorator.addValue(Object, DataType)" access="pub" jdoc="">
				<param name="value"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatementDecorator.addBatch()" access="pub" jdoc="">
				<comm cntt="reset sql buffer"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatementDecorator.executeBatch()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatementDecorator.clearBatch()" access="pub" jdoc="">
				<comm cntt="reset sql buffer"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.BatchStatementDecorator.close()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.PreparedStatementFactory" intfc="n" abs="n" inn="n" sloc="36" jdoc="@author Manuel Laflamme @version $Revision: 655 $ @since Mar 20, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.statement.PreparedStatementFactory.createBatchStatement(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.PreparedStatementFactory.createPreparedBatchStatement(String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="sql"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.database.statement.StatementFactory" intfc="n" abs="n" inn="n" sloc="23" jdoc="@author Manuel Laflamme @version $Revision: 672 $ @since Mar 15, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.database.statement.StatementFactory.createBatchStatement(IDatabaseConnection)" access="pub" jdoc="">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.database.statement.StatementFactory.createPreparedBatchStatement(String, IDatabaseConnection)" access="pub" jdoc="">
				<param name="sql"/>
				<param name="connection"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset">
		<class name="/:org.dbunit.dataset.CompositeTable" intfc="n" abs="n" inn="n" sloc="64" jdoc="@author Manuel Laflamme @version $Revision: 1176 $ @since Feb 17, 2002">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_metaData" access="priv" jdoc=""/>
			<const name="_tables" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.CompositeTable.CompositeTable(ITableMetaData, ITable)" access="pub" jdoc="Creates a composite table that combines the specified metadata with the specified table.">
				<param name="metaData"/>
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeTable.CompositeTable(ITableMetaData, ITable[])" access="pub" jdoc="Creates a composite table that combines the specified metadata with the specified tables.">
				<param name="metaData"/>
				<param name="tables"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeTable.CompositeTable(ITable, ITable)" access="pub" jdoc="Creates a composite table that combines the specified specified tables. The metadata from the first table is used as metadata for the new table.">
				<param name="table1"/>
				<param name="table2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeTable.CompositeTable(String, ITable)" access="pub" jdoc="Creates a composite dataset that encapsulate the specified table with a new name.">
				<param name="newName"/>
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeTable.toString()" access="pub" jdoc="{@inheritDoc}">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.AbstractDataSet" intfc="n" abs="y" inn="n" sloc="88" jdoc="This abstract class provides the basic implementation of the IDataSet interface. Subclass are only required to implement the {@link #createIterator}method. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1014 $ $Date: 2009-06-01 15:44:23 -0300 (Seg, 01 Jun 2009) $ @since 1.0 (Feb 22, 2002)">
			<comm cntt="TODO (matthias) Use a DataSetBuilder PLUS IDataSet to avoid this ugly lazy initialization with loads of protected internals a user must know..."/>
			<comm cntt="protected ITable[] cloneTables(ITable[] tables)"/>
			<comm cntt="{"/>
			<comm cntt="logger.debug(&amp;quot;cloneTables(tables={}) - start&amp;quot;, tables);"/>
			<comm cntt=""/>
			<comm cntt="ITable[] clones = new ITable[tables.length];"/>
			<comm cntt="for (int i = 0; i &amp;lt; tables.length; i++)"/>
			<comm cntt="{"/>
			<comm cntt="clones[i] = tables[i];"/>
			<comm cntt="}"/>
			<comm cntt="return clones;"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<comm cntt=""/>
			<comm cntt="Object class"/>
			<field name="_orderedTableNameMap" access="prot" jdoc=""/>
			<field name="_caseSensitiveTableNames" access="priv" jdoc="Whether or not table names of this dataset are case sensitive. By default case-sensitivity is set to false for datasets"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.AbstractDataSet()" access="pub" jdoc="Default constructor">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.AbstractDataSet(boolean)" access="pub" jdoc="Constructor @param caseSensitiveTableNames Whether or not table names should be case sensitive @since 2.4">
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.isCaseSensitiveTableNames()" access="pub" jdoc="@return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the case sensitivity of table names is used in this dataset. @since 2.4">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.createTableNameMap()" access="prot" jdoc="Creates and returns a new instance of the table names container. Implementors should use this method to retrieve a map which stores table names which can be linked with arbitrary objects. @return a new empty instance of the table names container @since 2.4">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.initialize()" access="priv" jdoc="Initializes the tables of this dataset @throws DataSetException @since 2.4">
				<comm cntt="already initialized"/>
				<comm cntt="Gather all tables in the OrderedTableNameMap which also makes the duplicate check"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.createIterator(boolean)" access="prot" jdoc="Creates an iterator which provides access to all tables of this dataset @param reversed Whether the created iterator should be a reversed one or not @return The created {@link ITableIterator} @throws DataSetException">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.getTables()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.iterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.reverseIterator()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractDataSet.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.ITableIterator" intfc="y" abs="n" inn="n" sloc="6" jdoc="@author Manuel Laflamme @since Apr 5, 2003 @version $Revision: 398 $">
			<mth name="/:org.dbunit.dataset.ITableIterator.next()" access="pub" jdoc="Position this iterator to the next table. The iterator is initially positioned before the first table; the first call to the method next makes the first table the current table; the second call makes the second table the current table, and so on. @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the new current table is valid; &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; if there are no more table">
			</mth>
			<mth name="/:org.dbunit.dataset.ITableIterator.getTableMetaData()" access="pub" jdoc="Returns the metadata of the current table.">
			</mth>
			<mth name="/:org.dbunit.dataset.ITableIterator.getTable()" access="pub" jdoc="Returns the current table.">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.FilteredDataSet" intfc="n" abs="n" inn="n" sloc="46" jdoc="Decorates a dataset and exposes only some tables from it. Can be used with different filtering strategies. @see ITableFilter @see SequenceTableFilter @see org.dbunit.dataset.filter.DefaultTableFilter @author Manuel Laflamme @version $Revision: 1049 $ @since Feb 22, 2002">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<const name="_filter" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.FilteredDataSet.FilteredDataSet(String[], IDataSet)" access="pub" jdoc="Creates a FilteredDataSet that decorates the specified dataset and exposes only the specified tables using {@link SequenceTableFilter} as filtering strategy. @throws AmbiguousTableNameException If the given tableNames array contains ambiguous names">
				<param name="tableNames"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredDataSet.FilteredDataSet(ITableFilter, IDataSet)" access="pub" jdoc="Creates a FilteredDataSet that decorates the specified dataset and exposes only the tables allowed by the specified filter. @param dataSet the filtered dataset @param filter the filtering strategy">
				<param name="filter"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.FilteredTableMetaData" intfc="n" abs="n" inn="n" sloc="49" jdoc="@author Manuel Laflamme @version $Revision: 677 $ @since May 11, 2004">
			<comm cntt=""/>
			<comm cntt="ITableMetaData interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tableName" access="priv" jdoc=""/>
			<const name="_columns" access="priv" jdoc=""/>
			<const name="_primaryKeys" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.FilteredTableMetaData.FilteredTableMetaData(ITableMetaData, IColumnFilter)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="columnFilter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredTableMetaData.getFilteredColumns(String, Column[], IColumnFilter)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="columns"/>
				<param name="columnFilter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredTableMetaData.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredTableMetaData.getColumns()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.FilteredTableMetaData.getPrimaryKeys()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.CompositeDataSet" intfc="n" abs="n" inn="n" sloc="93" jdoc="Combines multiple datasets into a single logical dataset. @author Manuel Laflamme @version $Revision: 911 $ @since Feb 19, 2002">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tables" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(IDataSet[])" access="pub" jdoc="Creates a composite dataset that combines specified datasets. Tables having the same name are merged into one table.">
				<param name="dataSets"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(IDataSet[], boolean)" access="pub" jdoc="Creates a composite dataset that combines specified datasets. @param dataSetslist of datasets @param combineif &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt;, tables having the same name are merged into one table.">
				<param name="dataSets"/>
				<param name="combine"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(IDataSet[], boolean, boolean)" access="pub" jdoc="Creates a composite dataset that combines specified datasets. @param dataSetslist of datasets @param combineif &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt;, tables having the same name are merged into one table. @param caseSensitiveTableNames Whether or not table names are handled in a case sensitive way over all datasets. @since 2.4.2">
				<comm cntt="Check for duplicates using the OrderedTableNameMap as helper"/>
				<param name="dataSets"/>
				<param name="combine"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(IDataSet, IDataSet)" access="pub" jdoc="Creates a composite dataset that combines the two specified datasets. Tables having the same name are merged into one table.">
				<param name="dataSet1"/>
				<param name="dataSet2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(IDataSet, IDataSet, boolean)" access="pub" jdoc="Creates a composite dataset that combines the two specified datasets. @param dataSet1first dataset @param dataSet2second dataset @param combineif &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt;, tables having the same name are merged into one table.">
				<param name="dataSet1"/>
				<param name="dataSet2"/>
				<param name="combine"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(IDataSet, boolean)" access="pub" jdoc="Creates a composite dataset that combines duplicate tables of the specified dataset. @param dataSetthe dataset @param combineif &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt;, tables having the same name are merged into one table. @deprecated This constructor is useless when the combine parameter is &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt;. Use overload that doesn&amp;apos;t have the combine argument.">
				<param name="dataSet"/>
				<param name="combine"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(IDataSet)" access="pub" jdoc="Creates a composite dataset that combines duplicate tables of the specified dataset. @param dataSetthe dataset">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(ITable[])" access="pub" jdoc="Creates a composite dataset that combines tables having identical name. Tables having the same name are merged into one table.">
				<param name="tables"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.CompositeDataSet(ITable[], boolean)" access="pub" jdoc="Creates a composite dataset that combines tables having identical name. Tables having the same name are merged into one table. @param tables The tables to merge to one dataset @param caseSensitiveTableNames Whether or not table names are handled in a case sensitive way over all datasets. @since 2.4.2">
				<param name="tables"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.addTable(ITable, OrderedTableNameMap, boolean)" access="priv" jdoc="@param newTable @param tableMap @param combine @throws AmbiguousTableNameException Can only occur when the combine flag is set to &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt;.">
				<comm cntt="No merge required, simply add new table at then end of the list"/>
				<comm cntt="Merge required, search for existing table with the same name"/>
				<comm cntt="Found existing table, merge existing and new tables together"/>
				<comm cntt="No existing table found, add new table at the end of the list"/>
				<param name="newTable"/>
				<param name="tableMap"/>
				<param name="combine"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CompositeDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.ReplacementDataSet" intfc="n" abs="n" inn="n" sloc="82" jdoc="Decorator that replace configured values from the decorated dataset with replacement values. @author Manuel Laflamme @since Mar 17, 2003 @version $Revision: 855 $">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<comm cntt=""/>
			<comm cntt="ReplacementIterator class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<const name="_objectMap" access="priv" jdoc=""/>
			<const name="_substringMap" access="priv" jdoc=""/>
			<field name="_startDelim" access="priv" jdoc=""/>
			<field name="_endDelim" access="priv" jdoc=""/>
			<field name="_strictReplacement" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.ReplacementDataSet(IDataSet)" access="pub" jdoc="Create a new ReplacementDataSet object that decorates the specified dataset. @param dataSet the decorated table">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.ReplacementDataSet(IDataSet, Map, Map)" access="pub" jdoc="Create a new ReplacementDataSet object that decorates the specified dataset. @param dataSet the decorated dataset @param objectMap the replacement objects mapping @param substringMap the replacement substrings mapping">
				<param name="dataSet"/>
				<param name="objectMap"/>
				<param name="substringMap"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.setStrictReplacement(boolean)" access="pub" jdoc="Setting this property to true indicates that when no replacement is found for a delimited substring the replacement will fail fast. @param strictReplacement true if replacement should be strict">
				<param name="strictReplacement"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.addReplacementObject(Object, Object)" access="pub" jdoc="Add a new Object replacement mapping. @param originalObject the object to replace @param replacementObject the replacement object">
				<param name="originalObject"/>
				<param name="replacementObject"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.addReplacementSubstring(String, String)" access="pub" jdoc="Add a new substring replacement mapping. @param originalSubstring the substring to replace @param replacementSubstring the replacement substring">
				<param name="originalSubstring"/>
				<param name="replacementSubstring"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.setSubstringDelimiters(String, String)" access="pub" jdoc="Sets substring delimiters.">
				<param name="startDelimiter"/>
				<param name="endDelimiter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.createReplacementTable(ITable)" access="priv" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		<class name="/:org.dbunit.dataset.ReplacementDataSet$ReplacementIterator" intfc="n" abs="n" inn="y" sloc="24" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_iterator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet$ReplacementIterator.ReplacementIterator(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet$ReplacementIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet$ReplacementIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementDataSet$ReplacementIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.CachedDataSet" intfc="n" abs="n" inn="n" sloc="80" jdoc="Hold copy of another dataset or a consumed provider content. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 941 $ $Date: 2009-01-16 13:42:11 -0200 (Sex, 16 Jan 2009) $ @since 1.x (Apr 18, 2003)">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSetConsumer interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_tables" access="priv" jdoc=""/>
			<field name="_activeTable" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.CachedDataSet.CachedDataSet()" access="pub" jdoc="Default constructor.">
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.CachedDataSet(IDataSet)" access="pub" jdoc="Creates a copy of the specified dataset.">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.CachedDataSet(IDataSetProducer)" access="pub" jdoc="Creates a CachedDataSet that synchronously consume the specified producer.">
				<param name="producer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.CachedDataSet(IDataSetProducer, boolean)" access="pub" jdoc="Creates a CachedDataSet that synchronously consume the specified producer. @param producer @param caseSensitiveTableNames Whether or not case sensitive table names should be used @throws DataSetException">
				<param name="producer"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.initialize()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.startDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.endDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.startTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.endTable()" access="pub" jdoc="">
				<comm cntt="Check whether the table appeared once before"/>
				<comm cntt="Add all newly collected rows to the existing table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CachedDataSet.row(Object[])" access="pub" jdoc="">
				<param name="values"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.NoPrimaryKeyException" intfc="n" abs="n" inn="n" sloc="18" jdoc="@author Manuel Laflamme @version $Revision: 398 $ @since Feb 19, 2002">
			<mth name="/:org.dbunit.dataset.NoPrimaryKeyException.NoPrimaryKeyException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.NoPrimaryKeyException.NoPrimaryKeyException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoPrimaryKeyException.NoPrimaryKeyException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoPrimaryKeyException.NoPrimaryKeyException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.DefaultTableMetaData" intfc="n" abs="n" inn="n" sloc="42" jdoc="@author Manuel Laflamme @version $Revision: 741 $ @since Feb 17, 2002">
			<comm cntt=""/>
			<comm cntt="ITableMetaData interface"/>
			<const name="_tableName" access="priv" jdoc=""/>
			<const name="_columns" access="priv" jdoc=""/>
			<const name="_primaryKeys" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.DefaultTableMetaData.DefaultTableMetaData(String, Column[])" access="pub" jdoc="">
				<comm cntt="throws DataSetException"/>
				<param name="tableName"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableMetaData.DefaultTableMetaData(String, Column[], String[])" access="pub" jdoc="">
				<comm cntt="throws DataSetException"/>
				<param name="tableName"/>
				<param name="columns"/>
				<param name="primaryKeys"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableMetaData.DefaultTableMetaData(String, Column[], Column[])" access="pub" jdoc="">
				<comm cntt="throws DataSetException"/>
				<param name="tableName"/>
				<param name="columns"/>
				<param name="primaryKeys"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableMetaData.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableMetaData.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableMetaData.getColumns()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableMetaData.getPrimaryKeys()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.ForwardOnlyDataSet" intfc="n" abs="n" inn="n" sloc="36" jdoc="Decorator that allows forward only access to decorated dataset. @author Manuel Laflamme @since Apr 9, 2003 @version $Revision: 677 $">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<comm cntt=""/>
			<comm cntt="ForwardOnlyIterator class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<field name="_iteratorCount" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet.ForwardOnlyDataSet(IDataSet)" access="pub" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		<class name="/:org.dbunit.dataset.ForwardOnlyDataSet$ForwardOnlyIterator" intfc="n" abs="n" inn="y" sloc="21" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="_iterator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet$ForwardOnlyIterator.ForwardOnlyIterator(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet$ForwardOnlyIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet$ForwardOnlyIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyDataSet$ForwardOnlyIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.OrderedTableNameMap" intfc="n" abs="n" inn="n" sloc="131" jdoc="Associates a table name with an arbitrary object. Moreover the order of the added table names is maintained and the ordered table names can be retrieved via {@link #getTableNames()}. &amp;lt;p&amp;gt; The map ensures that one table name can only be added once. &amp;lt; p&amp;gt; TODO In the future it might be discussed if a ListOrderedMap (apache-commons-collections) can should be used. @author gommma @author Last changed by: $Author: gommma $ @version $Revision: 941 $ @since 2.4.0">
			<const name="LOGGER" access="priv" jdoc="Logger for this class"/>
			<field name="_tableMap" access="priv" jdoc="The map for fast access to the existing table names and for associating an arbitrary object with a table name"/>
			<field name="_tableNames" access="priv" jdoc="Chronologically ordered list of table names - keeps the order in which the table names have been added as well as the case in which the table has been added"/>
			<field name="_lastTableNameOverride" access="priv" jdoc=""/>
			<field name="_caseSensitiveTableNames" access="priv" jdoc="Whether or not case sensitive table names should be used. Defaults to false."/>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.OrderedTableNameMap(boolean)" access="pub" jdoc="Creates a new map which does strictly force that one table can only occur once. @param caseSensitiveTableNames Whether or not table names should be case sensitive">
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.get(String)" access="pub" jdoc="Returns the object associated with the given table name @param tableName The table name for which the associated object is retrieved @return The object that has been associated with the given table name">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.getTableNames()" access="pub" jdoc="Provides the ordered table names having the same order in which the table names have been added via {@link #add(String,Object)}. @return The list of table names ordered in the sequence as they have been added to this map">
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.containsTable(String)" access="pub" jdoc="Checks if this map contains the given table name @param tableName @return Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the map of tables contains the given table name">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.isLastTable(String)" access="pub" jdoc="@param tableName The table name to check @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the given tableName matches the last table that has been added to this map.">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.getLastTableName()" access="pub" jdoc="@return The name of the last table that has been added to this map. Returns &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if no table has been added yet.">
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.setLastTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.add(String, Object)" access="pub" jdoc="Adds the given table name to the map of table names, associating it with the given object. @param tableName The table name to be added @param object Object to be associated with the given table name. Can be null @throws AmbiguousTableNameException If the given table name already exists">
				<comm cntt="Get the table name in the correct case"/>
				<comm cntt="prevent table name conflict"/>
				<comm cntt="Reset the override of the lastTableName"/>
				<param name="tableName"/>
				<param name="object"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.orderedValues()" access="pub" jdoc="@return The values of this map ordered in the sequence they have been added">
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.update(String, Object)" access="pub" jdoc="Updates the value associated with the given table name. Must be invoked if the table name has already been added before. @param tableName The table name for which the association should be updated @param object The new object to be associated with the given table name">
				<comm cntt="prevent table name conflict"/>
				<param name="tableName"/>
				<param name="object"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.getTableName(String)" access="pub" jdoc="Returns the table name in the correct case (for example as upper case string) @param tableName The input table name to be resolved @return The table name for the given string in the correct case.">
				<comm cntt="&amp;quot;Locale.ENGLISH&amp;quot; Fixes bug #1537894 when clients have a special"/>
				<comm cntt="locale like turkish. (for release 2.4.3)"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.OrderedTableNameMap.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.SortedTable" intfc="n" abs="n" inn="n" sloc="115" jdoc="This is a ITable decorator that provide a sorted view of the decorated table. This implementation does not keep a separate copy of the decorated table data. @author Manuel Laflamme @author Last changed by: $Author: jeffjensen $ @version $Revision: 1176 $ $Date: 2009-05-01 02:56:07 -0500 (Fri, 01 May 2009) $ @since Feb 19, 2003">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<comm cntt=""/>
			<comm cntt="Comparator interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_table" access="priv" jdoc=""/>
			<const name="_columns" access="priv" jdoc=""/>
			<field name="_indexes" access="priv" jdoc=""/>
			<field name="rowComparator" access="priv" jdoc="The row comparator which is used for sorting"/>
			<mth name="/:org.dbunit.dataset.SortedTable.SortedTable(ITable, Column[])" access="pub" jdoc="Sort the decorated table by specified columns order. @param tabledecorated table @param columnscolumns to be used for sorting @throws DataSetException">
				<param name="table"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.SortedTable(ITable, String[])" access="pub" jdoc="Sort the decorated table by specified columns order. @param tabledecorated table @param columnNamesnames of columns to be used for sorting @throws DataSetException">
				<param name="table"/>
				<param name="columnNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.SortedTable(ITable, ITableMetaData)" access="pub" jdoc="Sort the decorated table by specified metadata columns order. All metadata columns will be used. @param tableThe decorated table @param metaDataThe metadata used to retrieve all columns which in turn are used for sorting the table @throws DataSetException">
				<param name="table"/>
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.SortedTable(ITable)" access="pub" jdoc="Sort the decorated table by its own columns order which is defined by{@link ITable#getTableMetaData()}. All table columns will be used. @param tableThe decorated table @throws DataSetException">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.validateAndResolveColumns(Column[])" access="priv" jdoc="Verifies that all given columns really exist in the current table and returns the physical {@link Column} objects from the table. @param columns @return @throws DataSetException">
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.validateAndResolveColumns(String[])" access="priv" jdoc="Verifies that all given columns really exist in the current table and returns the physical {@link Column} objects from the table. @param columnNames @return @throws DataSetException">
				<param name="columnNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.initialize()" access="priv" jdoc="">
				<comm cntt="The default comparator is the one that sorts by string - for"/>
				<comm cntt="backwards compatibility"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.getSortColumns()" access="pub" jdoc="@return The columns that are used for sorting the table">
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.getOriginalRowIndex(int)" access="priv" jdoc="">
				<param name="row"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.setUseComparable(boolean)" access="pub" jdoc="Whether or not the comparable interface should be used of the compared columns instead of the plain strings Default value is &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; for backwards compatibility Set whether or not to use the Comparable implementation of the corresponding column DataType for comparing values or not. Default value is &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; which means that the old string comparison is used. &amp;lt;br&amp;gt; @param useComparable @since 2.3.0">
				<param name="useComparable"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.setRowComparator(Comparator)" access="pub" jdoc="Sets the comparator to be used for sorting the table rows. @param comparatorthat sorts the table rows @since 2.4.2">
				<comm cntt="TODO this is an ugly design to avoid increasing the number of"/>
				<comm cntt="constructors from 4 to 8. To be discussed how to implement it the"/>
				<comm cntt="best way."/>
				<param name="comparator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable.toString()" access="pub" jdoc="{@inheritDoc}">
			</mth>
		<class name="/:org.dbunit.dataset.SortedTable$AbstractRowComparator" intfc="n" abs="y" inn="y" sloc="40" jdoc="Abstract class for sorting the table rows of a given table in a specific order">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_table" access="priv" jdoc=""/>
			<const name="_sortColumns" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.SortedTable$AbstractRowComparator.AbstractRowComparator(ITable, Column[])" access="pub" jdoc="@param tableThe wrapped table to be sorted @param sortColumnsThe columns to be used for sorting in the given order">
				<param name="table"/>
				<param name="sortColumns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable$AbstractRowComparator.compare(Object, Object)" access="pub" jdoc="">
				<comm cntt="Compare the two values with each other for sorting"/>
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable$AbstractRowComparator.compare(Column, Object, Object)" access="prot" jdoc="@param columnThe column to be compared @param value1The first value of the given column @param value2The second value of the given column @return 0 if both values are considered equal. @throws TypeCastException">
				<param name="column"/>
				<param name="value1"/>
				<param name="value2"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.SortedTable$RowComparator" intfc="n" abs="n" inn="y" sloc="18" jdoc="Compares the rows with each other in order to sort them in the correct order using the data type and the Comparable implementation the current column has.">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.SortedTable$RowComparator.RowComparator(ITable, Column[])" access="pub" jdoc="">
				<param name="table"/>
				<param name="sortColumns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable$RowComparator.compare(Column, Object, Object)" access="prot" jdoc="">
				<param name="column"/>
				<param name="value1"/>
				<param name="value2"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.SortedTable$RowComparatorByString" intfc="n" abs="n" inn="y" sloc="19" jdoc="Compares the rows with each other in order to sort them in the correct order using the string value of both values for the comparison.">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.SortedTable$RowComparatorByString.RowComparatorByString(ITable, Column[])" access="pub" jdoc="">
				<param name="table"/>
				<param name="sortColumns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedTable$RowComparatorByString.compare(Column, Object, Object)" access="prot" jdoc="">
				<comm cntt="Default behavior since ever"/>
				<param name="column"/>
				<param name="value1"/>
				<param name="value2"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.RowFilterTable" intfc="n" abs="n" inn="n" sloc="55" jdoc="Filters table rows by using arbitrary column values of the table to check if a row should be filtered or not. &amp;lt;br&amp;gt; Implemented as a decorator for {@link ITable}. See dbunit feature request at &amp;lt;a href=&amp;quot;https: sourceforge.net tracker index.php?func=detail&amp;aid=1959771&amp;group_id=47439&amp;atid=449494&amp;quot;&amp;gt;#1959771&amp;lt; a&amp;gt; @author gommma @author Last changed by: $Author: gommma $ @version $Revision: 850 $ $Date: 2008-10-31 16:39:59 -0200 (Sex, 31 Out 2008) $ @since 2.3.0">
			<comm cntt="ITable methods"/>
			<const name="originalTable" access="priv" jdoc="reference to the original table being wrapped"/>
			<const name="filteredRowIndexes" access="priv" jdoc="mapping of filtered rows, i.e, each entry on this list has the value of the index on the original table corresponding to the desired index. For instance, if the original table is: row PK Value 0 pk1 v1 1 pk2 v2 2 pk3 v3 3 pk4 v4 And the allowed PKs are pk2 and pk4, the new table should be: row PK Value 0 pk2 v2 1 pk4 v4 Consequently, the mapping will be {1, 3}"/>
			<const name="logger" access="priv" jdoc="logger"/>
			<field name="currentRowIdx" access="priv" jdoc="The row that is currently checked for filtering. Used in the implementation of {@link IRowValueProvider}"/>
			<mth name="/:org.dbunit.dataset.RowFilterTable.RowFilterTable(ITable, IRowFilter)" access="pub" jdoc="Creates a new {@link ITable} where some rows can be filtered out from the original table @param table The table to be wrapped @param rowFilter The row filter that checks for every row whether or not it should be filtered @throws DataSetException">
				<comm cntt="sets the rows for the new table"/>
				<comm cntt="NOTE: this conversion might be an issue for long tables, as it iterates for"/>
				<comm cntt="all values of the original table and that might take time and memory leaks."/>
				<comm cntt="So, this mapping mechanism is a candidate for improvement: another alternative"/>
				<comm cntt="would be to calculate the mapping on the fly, as getValue() is called (and in"/>
				<comm cntt="this case, getRowCount() would be simply the size of allowedPKs)"/>
				<param name="table"/>
				<param name="rowFilter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.RowFilterTable.setRows(IRowFilter)" access="priv" jdoc="">
				<param name="rowFilter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.RowFilterTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.RowFilterTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.RowFilterTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.dataset.RowFilterTable.getColumnValue(String)" access="pub" jdoc="Returns the column value for the column with the given name of the currently processed row @throws DataSetException @see org.dbunit.dataset.IRowValueProvider#getColumnValue(java.lang.String)">
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.AbstractTable" intfc="n" abs="y" inn="n" sloc="35" jdoc="@author Manuel Laflamme @version $Revision: 1176 $ @since Feb 17, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.AbstractTable.assertValidRowIndex(int)" access="prot" jdoc="">
				<param name="row"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTable.assertValidRowIndex(int, int)" access="prot" jdoc="">
				<param name="row"/>
				<param name="rowCount"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTable.assertValidColumn(String)" access="prot" jdoc="">
				<comm cntt="Try to find the column in the metadata - if it cannot be found an"/>
				<comm cntt="exception is thrown"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTable.getColumnIndex(String)" access="prot" jdoc="">
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.ForwardOnlyTable" intfc="n" abs="n" inn="n" sloc="29" jdoc="@author Manuel Laflamme @since Apr 9, 2003 @version $Revision: 679 $">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_table" access="priv" jdoc=""/>
			<field name="_lastRow" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.ForwardOnlyTable.ForwardOnlyTable(ITable)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ForwardOnlyTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="column"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.CachedTable" intfc="n" abs="n" inn="n" sloc="12" jdoc="@author Manuel Laflamme @since Apr 10, 2003 @version $Revision: 444 $">
			<mth name="/:org.dbunit.dataset.CachedTable.CachedTable(ITable)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CachedTable.CachedTable(ITableMetaData)" access="prot" jdoc="">
				<param name="metaData"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.ITableMetaData" intfc="y" abs="n" inn="n" sloc="7" jdoc="Represents table metadata. @author Manuel Laflamme @version $Revision: 741 $ @since Feb 17, 2002">
			<mth name="/:org.dbunit.dataset.ITableMetaData.getTableName()" access="pub" jdoc="Returns this table name. @return this table name">
			</mth>
			<mth name="/:org.dbunit.dataset.ITableMetaData.getColumns()" access="pub" jdoc="Returns this table columns as recognized by dbunit. In cases where columns are resolved using database metadata it can happen that an empty array is returned when a table does not have a single column that is recognized by the configured {@link org.dbunit.dataset.datatype.IDataTypeFactory}. Note that it is &amp;lt;b&amp;gt;not&amp;lt; b&amp;gt; an exceptional case within dbunit when a {@link ITableMetaData}does not have a column. @return The columns for this table @throws DataSetException">
			</mth>
			<mth name="/:org.dbunit.dataset.ITableMetaData.getPrimaryKeys()" access="pub" jdoc="Returns this table primary key columns. @return this table primary key columns. @throws DataSetException">
			</mth>
			<mth name="/:org.dbunit.dataset.ITableMetaData.getColumnIndex(String)" access="pub" jdoc="Returns the column&amp;apos;s array index of the column with the given name within this table metadata. @param columnName The name of the column that is searched @return The index of the given column within this metadata, starting with 0 for the first column @throws NoSuchColumnException if the given column has not been found @throws DataSetException if something goes wrong when trying to retrieve the columns @since 2.3.0">
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.DefaultTable" intfc="n" abs="n" inn="n" sloc="105" jdoc="Default table implementation backed by a simple java in-memory list. @author Manuel Laflamme @version $Revision: 771 $ @since Feb 17, 2002">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_metaData" access="priv" jdoc=""/>
			<const name="_rowList" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.DefaultTable.DefaultTable(ITableMetaData, List)" access="pub" jdoc="Creates a new empty table with specified metadata and values. @deprecated Use public mutators to initialize table values instead">
				<param name="metaData"/>
				<param name="list"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.DefaultTable(String)" access="pub" jdoc="Creates a new empty table having the specified name.">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.DefaultTable(String, Column[], List)" access="pub" jdoc="Creates a new empty table with specified metadata and values. @deprecated Use public mutators to initialize table values instead">
				<param name="tableName"/>
				<param name="columns"/>
				<param name="list"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.DefaultTable(String, Column[])" access="pub" jdoc="Creates a new empty table with specified metadata.">
				<param name="tableName"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.DefaultTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.addRow()" access="pub" jdoc="Inserts a new empty row. You can add values with {@link #setValue}.">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.addRow(Object[])" access="pub" jdoc="Inserts a new row initialized with specified array of values. @param values The array of values. Each value correspond to the column at the same index from {@link ITableMetaData#getColumns}. @see #getTableMetaData">
				<param name="values"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.addTableRows(ITable)" access="pub" jdoc="Inserts all rows from the specified table. @param table The source table.">
				<comm cntt="end of table"/>
				<comm cntt="ignore error."/>
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.setValue(int, String, Object)" access="pub" jdoc="Replaces the value at the specified position in this table with the specified value. @param row The row index @param column The column name @param value The value to store at the specified location @return the value previously at the specified location @throws RowOutOfBoundsException if the row index is out of range @throws NoSuchColumnException if the column does not exist @throws DataSetException if an unexpected error occurs">
				<param name="row"/>
				<param name="column"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTable.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.CaseInsensitiveDataSet" intfc="n" abs="n" inn="n" sloc="52" jdoc="Allows access to a decorated dataset in a case insensitive way. Dataset implementations provided by the framework are case sensitive. This class allows using them in situation where case sensitiveness is not desirable. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 841 $ $Date: 2008-10-20 17:09:07 -0200 (Seg, 20 Out 2008) $ @deprecated All IDataSet implementations are case insensitive since DbUnit 1.5 - may change again since tablenames on RDBMSes can be case sensitive @since 1.0">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<comm cntt=""/>
			<comm cntt="CaseInsensitiveIterator class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<field name="orderedTableMap" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet.CaseInsensitiveDataSet(IDataSet)" access="pub" jdoc="">
				<comm cntt="Check for duplicates using the OrderedTableNameMap as helper"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet.getInternalTableName(String)" access="priv" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		<class name="/:org.dbunit.dataset.CaseInsensitiveDataSet$CaseInsensitiveIterator" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="_iterator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet$CaseInsensitiveIterator.CaseInsensitiveIterator(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet$CaseInsensitiveIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet$CaseInsensitiveIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveDataSet$CaseInsensitiveIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.ReplacementTable" intfc="n" abs="n" inn="n" sloc="170" jdoc="Decorator that replaces configured values from the decorated table with replacement values. @author Manuel Laflamme @since Mar 17, 2003 @version $Revision: 855 $">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_table" access="priv" jdoc=""/>
			<const name="_objectMap" access="priv" jdoc=""/>
			<const name="_substringMap" access="priv" jdoc=""/>
			<field name="_startDelim" access="priv" jdoc=""/>
			<field name="_endDelim" access="priv" jdoc=""/>
			<field name="_strictReplacement" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.ReplacementTable.ReplacementTable(ITable)" access="pub" jdoc="Create a new ReplacementTable object that decorates the specified table. @param table the decorated table">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.ReplacementTable(ITable, Map, Map, String, String)" access="pub" jdoc="">
				<param name="table"/>
				<param name="objectMap"/>
				<param name="substringMap"/>
				<param name="startDelimiter"/>
				<param name="endDelimiter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.setStrictReplacement(boolean)" access="pub" jdoc="Setting this property to true indicates that when no replacement is found for a delimited substring the replacement will fail fast. @param strictReplacement true if replacement should be strict">
				<param name="strictReplacement"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.addReplacementObject(Object, Object)" access="pub" jdoc="Add a new Object replacement mapping. @param originalObject the object to replace @param replacementObject the replacement object">
				<param name="originalObject"/>
				<param name="replacementObject"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.addReplacementSubstring(String, String)" access="pub" jdoc="Add a new substring replacement mapping. @param originalSubstring the substring to replace @param replacementSubstring the replacement substring">
				<param name="originalSubstring"/>
				<param name="replacementSubstring"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.setSubstringDelimiters(String, String)" access="pub" jdoc="Sets substring delimiters.">
				<param name="startDelimiter"/>
				<param name="endDelimiter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.replaceAll(StringBuffer, String, String)" access="priv" jdoc="Replace occurrences of source in text with target. Operates directly on text.">
				<param name="text"/>
				<param name="source"/>
				<param name="target"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.replaceStrings(String, String, String)" access="priv" jdoc="">
				<param name="value"/>
				<param name="lDelim"/>
				<param name="rDelim"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.replaceSubstrings(String)" access="priv" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.replaceDelimitedSubstrings(String)" access="priv" jdoc="@throws DataSetException when stringReplacement fails">
				<comm cntt="No more delimited substring"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.getValue(int, String)" access="pub" jdoc="">
				<comm cntt="Object replacement"/>
				<comm cntt="Stop here if substring replacement not applicable"/>
				<comm cntt="Substring replacement"/>
				<param name="row"/>
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ReplacementTable.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.DefaultDataSet" intfc="n" abs="n" inn="n" sloc="56" jdoc="Simple implementation of a dataset backed by {@link ITable} objects which can be added dynamically. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1014 $ $Date: 2009-06-01 15:44:23 -0300 (Seg, 01 Jun 2009) $ @since 1.0 (Feb 18, 2002)">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.DefaultDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.DefaultDataSet(boolean)" access="pub" jdoc="Creates a default dataset which is empty initially @param caseSensitiveTableNames @since 2.4.2">
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.DefaultDataSet(ITable)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.DefaultDataSet(ITable, ITable)" access="pub" jdoc="">
				<param name="table1"/>
				<param name="table2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.DefaultDataSet(ITable[])" access="pub" jdoc="">
				<param name="tables"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.DefaultDataSet(ITable[], boolean)" access="pub" jdoc="Creates a default dataset which consists of the given tables @param caseSensitiveTableNames @since 2.4.2">
				<param name="tables"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.addTable(ITable)" access="pub" jdoc="Add a new table in this dataset. @throws AmbiguousTableNameException">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.initialize()" access="prot" jdoc="Initializes the {@link _orderedTableNameMap} of the parent class if it is not initialized yet. @throws DataSetException @since 2.4.6">
				<comm cntt="already initialized"/>
				<comm cntt="Gather all tables in the OrderedTableNameMap which also makes the duplicate check"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.RowOutOfBoundsException" intfc="n" abs="n" inn="n" sloc="18" jdoc="@author Manuel Laflamme @version $Revision: 398 $ @since Feb 17, 2002">
			<mth name="/:org.dbunit.dataset.RowOutOfBoundsException.RowOutOfBoundsException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.RowOutOfBoundsException.RowOutOfBoundsException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.dataset.RowOutOfBoundsException.RowOutOfBoundsException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.RowOutOfBoundsException.RowOutOfBoundsException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.IDataSet" intfc="y" abs="n" inn="n" sloc="11" jdoc="Represents a collection of tables. @author Manuel Laflamme @version $Revision: 911 $ @since Feb 17, 2002">
			<mth name="/:org.dbunit.dataset.IDataSet.getTableNames()" access="pub" jdoc="Returns names of tables in this dataset in proper sequence. Multiple occurrence of the same name may be returned if multiple tables having the same name are present in the dataset.">
			</mth>
			<mth name="/:org.dbunit.dataset.IDataSet.getTableMetaData(String)" access="pub" jdoc="Returns the specified table metadata. @throws AmbiguousTableNameException if dataset contains multiple tables having the specified name. Use {@link #iterator} to access to all tables. @throws NoSuchTableException if dataset do not contains the specified table">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.IDataSet.getTable(String)" access="pub" jdoc="Returns the specified table. @throws AmbiguousTableNameException if dataset contains multiple tables having the specified name. Use {@link #iterator} to access to all tables. @throws NoSuchTableException if dataset do not contains the specified table">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.IDataSet.getTables()" access="pub" jdoc="Returns tables in this dataset in proper sequence. Multiple tables having the same name but different data may be returned. @deprecated Use {@link #iterator} or {@link #reverseIterator} instead.">
			</mth>
			<mth name="/:org.dbunit.dataset.IDataSet.iterator()" access="pub" jdoc="Returns an iterator over the tables in this dataset in proper sequence.">
			</mth>
			<mth name="/:org.dbunit.dataset.IDataSet.reverseIterator()" access="pub" jdoc="Returns an iterator over the tables in this dataset in reverse sequence.">
			</mth>
			<mth name="/:org.dbunit.dataset.IDataSet.isCaseSensitiveTableNames()" access="pub" jdoc="Whether or not this dataset handles table names in a case sensitive way or not. @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the case sensitivity of table names is used in this dataset. @since 2.4.2">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.ColumnFilterTable" intfc="n" abs="n" inn="n" sloc="42" jdoc="A table that filters some columns out from the original table. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 850 $ $Date: 2008-10-31 16:39:59 -0200 (Sex, 31 Out 2008) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="logger"/>
			<const name="originalTable" access="priv" jdoc="reference to the original table being wrapped"/>
			<const name="tableMetaData" access="priv" jdoc="The filtered table metadata"/>
			<mth name="/:org.dbunit.dataset.ColumnFilterTable.ColumnFilterTable(ITable, IColumnFilter)" access="pub" jdoc="@param table The table from which some columns should be filtered @param columnFilter The filter defining which columns to be filtered @throws DataSetException">
				<param name="table"/>
				<param name="columnFilter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ColumnFilterTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ColumnFilterTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.ColumnFilterTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.dataset.ColumnFilterTable.getOriginalMetaData()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.DefaultTableIterator" intfc="n" abs="n" inn="n" sloc="38" jdoc="@author Manuel Laflamme @since Apr 5, 2003 @version $Revision: 741 $">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<field name="logger" access="priv" jdoc=""/>
			<const name="_tables" access="priv" jdoc=""/>
			<field name="_index" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.DefaultTableIterator.DefaultTableIterator(ITable[])" access="pub" jdoc="">
				<param name="tables"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableIterator.DefaultTableIterator(ITable[], boolean)" access="pub" jdoc="">
				<param name="tables"/>
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DefaultTableIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.IRowValueProvider" intfc="y" abs="n" inn="n" sloc="3" jdoc="Provides arbitrary values for one single database ITable row. @author gommmma @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since 2.3.0">
			<mth name="/:org.dbunit.dataset.IRowValueProvider.getColumnValue(String)" access="pub" jdoc="Returns the column value for the column with the given name of the currently processed row @param columnName The db column name for which the value should be provided (current row&amp;apos;s value) @return The value of the given column in the current row @throws DataSetException">
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.DataSetUtils" intfc="n" abs="n" inn="n" sloc="129" jdoc="This class contains various methods for manipulating datasets. @author Manuel Laflamme @version $Revision: 759 $ @since Feb 19, 2002">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.DataSetUtils.DataSetUtils()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.assertEquals(IDataSet, IDataSet)" access="pub" jdoc="Asserts that the two specified dataset are equals. This method ignore the tables order. @deprecated Use Assertion.assertEquals">
				<param name="expectedDataSet"/>
				<param name="actualDataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.assertEquals(ITable, ITable)" access="pub" jdoc="Asserts that the two specified tables are equals. This method ignore the table names, the columns order, the columns data type and the primary keys. @deprecated Use Assertion.assertEquals">
				<param name="expectedTable"/>
				<param name="actualTable"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getQualifiedName(String, String)" access="pub" jdoc="Returns the specified name qualified with the specified prefix. The name is not modified if the prefix is &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; or if the name is already qualified. &amp;lt;p&amp;gt; Example: &amp;lt;br&amp;gt; &amp;lt;code&amp;gt;getQualifiedName(null, &amp;quot;NAME&amp;quot;)&amp;lt; code&amp;gt; returns &amp;lt;code&amp;gt;&amp;quot;NAME&amp;quot;&amp;lt; code&amp;gt;. &amp;lt;code&amp;gt;getQualifiedName(&amp;quot;PREFIX&amp;quot;, &amp;quot;NAME&amp;quot;)&amp;lt; code&amp;gt; returns &amp;lt;code&amp;gt;&amp;quot;PREFIX.NAME&amp;quot;&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;getQualifiedName(&amp;quot;PREFIX2&amp;quot;, &amp;quot;PREFIX1.NAME&amp;quot;)&amp;lt; code&amp;gt; returns &amp;lt;code&amp;gt;&amp;quot;PREFIX1.NAME&amp;quot;&amp;lt; code&amp;gt;. @param prefix the prefix that qualifies the name and is prepended if the name is not qualified yet @param name the name The name to be qualified if it is not qualified already @return the qualified name @deprecated since 2.3.0. Prefer usage of {@link QualifiedTableName#getQualifiedName()} creating a new {@link QualifiedTableName} object">
				<param name="prefix"/>
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getQualifiedName(String, String, String)" access="pub" jdoc="@param prefix the prefix that qualifies the name and is prepended if the name is not qualified yet @param name the name The name to be qualified if it is not qualified already @param escapePattern The escape pattern to be applied on the prefix and the name. Can be null. @return The qualified name @deprecated since 2.3.0. Prefer usage of {@link QualifiedTableName#getQualifiedName()} creating a new {@link QualifiedTableName} object">
				<param name="prefix"/>
				<param name="name"/>
				<param name="escapePattern"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getEscapedName(String, String)" access="pub" jdoc="@param name @param escapePattern @return The escaped name if the escape pattern is not null @deprecated since 2.3.0. Prefer usage of {@link QualifiedTableName#getQualifiedName()} creating a new {@link QualifiedTableName} object">
				<param name="name"/>
				<param name="escapePattern"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getSqlValueString(Object, DataType)" access="pub" jdoc="Returns the specified value as a string to be use in an SQL Statement. For example the string &amp;lt;code&amp;gt;myValue&amp;lt; code&amp;gt; is returned as &amp;lt;code&amp;gt;&amp;apos;myValue&amp;apos;&amp;lt; code&amp;gt;. @param value the value @param dataType the value data type @return the SQL string value">
				<comm cntt="no single quotes"/>
				<comm cntt="escaping single quotes"/>
				<param name="value"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getColumn(String, Column[])" access="pub" jdoc="Search and returns the specified column from the specified column array. @param columnName the name of the column to search. @param columns the array of columns from which the column must be searched. @return the column or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if the column is not found @deprecated since 2.3.0 - prefer usage of {@link Columns#getColumn(String,Column[])}">
				<param name="columnName"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getTables(String[], IDataSet)" access="pub" jdoc="Search and returns the specified tables from the specified dataSet. @param names the names of the tables to search. @param dataSet the dataset from which the tables must be searched. @return the tables or an empty array if no tables are found.">
				<param name="names"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getTables(IDataSet)" access="pub" jdoc="Returns the tables from the specified dataset.">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getTables(ITableIterator)" access="pub" jdoc="Returns the tables from the specified iterator.">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.getReverseTableNames(IDataSet)" access="pub" jdoc="Returns the table names from the specified dataset in reverse order.">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetUtils.reverseStringArray(String[])" access="pub" jdoc="reverses a String array. @param array @return String[] - reversed array.">
				<param name="array"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.SortedDataSet" intfc="n" abs="n" inn="n" sloc="31" jdoc="Decorator that returns the {@link ITable}s of the decorated dataset as {@link SortedTable}s. @author Manuel Laflamme @version $Revision: 815 $ @since Feb 19, 2003">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<comm cntt=""/>
			<comm cntt="SortedIterator class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.SortedDataSet.SortedDataSet(IDataSet)" access="pub" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.SortedDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		<class name="/:org.dbunit.dataset.SortedDataSet$SortedIterator" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="_iterator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.SortedDataSet$SortedIterator.SortedIterator(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.SortedDataSet$SortedIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.SortedDataSet$SortedIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.SortedDataSet$SortedIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.AbstractTableMetaData" intfc="n" abs="y" inn="n" sloc="108" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1031 $ $Date: 2009-09-12 12:13:43 -0300 (SÃ¡b, 12 Set 2009) $ @since 1.0 (Mar 8, 2002)">
			<field name="_columnsToIndexes" access="priv" jdoc=""/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.AbstractTableMetaData.AbstractTableMetaData()" access="pub" jdoc="Default constructor">
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTableMetaData.getPrimaryKeys(Column[], String[])" access="prot" jdoc="@param columns @param keyNames @return The primary key columns @deprecated since 2.3.0 - use {@link Columns#getColumns(String[],Column[])}">
				<param name="columns"/>
				<param name="keyNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTableMetaData.getPrimaryKeys(String, Column[], IColumnFilter)" access="prot" jdoc="@param tableName @param columns @param columnFilter @return The filtered primary key columns @deprecated since 2.3.0 - use {@link Columns#getColumns(String[],Column[])}">
				<param name="tableName"/>
				<param name="columns"/>
				<param name="columnFilter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTableMetaData.getColumnIndex(String)" access="pub" jdoc="Provides the index of the column with the given name within this table. Uses method {@link ITableMetaData#getColumns()} to retrieve all available columns. @throws DataSetException @see org.dbunit.dataset.ITableMetaData#getColumnIndex(java.lang.String)">
				<comm cntt="lazily create the map"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTableMetaData.createColumnIndexesMap(Column[])" access="priv" jdoc="@param columns The columns to be put into the hash table @return A map having the key value pair [columnName, columnIndexInInputArray]">
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTableMetaData.getDataTypeFactory(IDatabaseConnection)" access="pub" jdoc="Validates and returns the datatype factory of the given connection @param connection The connection providing the {@link IDataTypeFactory} @return The datatype factory of the given connection @throws SQLException">
				<comm cntt="TODO Would a &amp;quot;DatabaseUnitConfigurationException make more sense?"/>
				<comm cntt="Validate, e.g. oracle metaData + oracleDataTypeFactory ==&amp;gt; OK"/>
				<comm cntt="Inform the user that we think he could get trouble with the current configuration"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.dataset.AbstractTableMetaData.validateDataTypeFactory(IDataTypeFactory, DatabaseMetaData)" access="pub" jdoc="Verifies that the data type factory supports the database product on the connection. If the data type factory is not valid for the connection, a warning is logged. @param dataTypeFactory The data type factory to validate. @param metaData The {@link DatabaseMetaData} needed to get the DB product name of the connection RDBMS. @return A validation message if there is a potential problem or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if everything is fine. @throws java.sql.SQLException A database problem.">
				<comm cntt="If we get here, the validation failed"/>
				<param name="dataTypeFactory"/>
				<param name="metaData"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.ITable" intfc="y" abs="n" inn="n" sloc="7" jdoc="A table represents a collection of tabular data. @author Manuel Laflamme @version $Revision: 746 $ @since Feb 17, 2002">
			<const name="NO_VALUE" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.dataset.ITable.getTableMetaData()" access="pub" jdoc="Returns this table metadata.">
			</mth>
			<mth name="/:org.dbunit.dataset.ITable.getRowCount()" access="pub" jdoc="Returns this table row count.">
			</mth>
			<mth name="/:org.dbunit.dataset.ITable.getValue(int, String)" access="pub" jdoc="Returns this table value for the specified row and column. @param row The row index, starting with 0 @param column The name of the column @return The value @throws NoSuchColumnException if specified column name do not exist in this table @throws RowOutOfBoundsException if specified row is less than zero or equals or greater than &amp;lt;code&amp;gt;getRowCount&amp;lt; code&amp;gt;">
				<param name="row"/>
				<param name="column"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.LowerCaseDataSet" intfc="n" abs="n" inn="n" sloc="50" jdoc="Specialized IDataSet decorator that convert the table name and column names to lower case. Used in DbUnit own test suite to verify that operations are case insensitive. @author Manuel Laflamme @version $Revision: 677 $ @since Feb 14, 2003">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<comm cntt=""/>
			<comm cntt="LowerCaseIterator class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.LowerCaseDataSet(ITable)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.LowerCaseDataSet(ITable[])" access="pub" jdoc="">
				<param name="tables"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.LowerCaseDataSet(IDataSet)" access="pub" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.createLowerTable(ITable)" access="priv" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.getTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet.getTable(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		<class name="/:org.dbunit.dataset.LowerCaseDataSet$LowerCaseIterator" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="_iterator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet$LowerCaseIterator.LowerCaseIterator(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet$LowerCaseIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet$LowerCaseIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseDataSet$LowerCaseIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.CaseInsensitiveTable" intfc="n" abs="n" inn="n" sloc="38" jdoc="@author Manuel Laflamme @version $Revision: 718 $ @since Mar 27, 2002 @deprecated All IDataSet implementations are case insensitive since DbUnit 1.5">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_table" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveTable.CaseInsensitiveTable(ITable)" access="pub" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveTable.getInternalColumnName(String)" access="priv" jdoc="">
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.CaseInsensitiveTable.getValue(int, String)" access="pub" jdoc="">
				<param name="row"/>
				<param name="column"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.Column" intfc="n" abs="n" inn="n" sloc="128" jdoc="Represents a table column. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 938 $ $Date: 2009-01-10 09:07:15 -0200 (SÃ¡b, 10 Jan 2009) $ @since 1.0 (Feb 17, 2002)">
			<comm cntt=""/>
			<comm cntt="Object class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="NO_NULLS" access="pub" jdoc="Indicates that the column might not allow &amp;lt;code&amp;gt;NULL&amp;lt; code&amp;gt; values."/>
			<const name="NULLABLE" access="pub" jdoc="Indicates that the column definitely allows &amp;lt;code&amp;gt;NULL&amp;lt; code&amp;gt; values."/>
			<const name="NULLABLE_UNKNOWN" access="pub" jdoc="Indicates that the nullability of columns is unknown."/>
			<const name="_columnName" access="priv" jdoc=""/>
			<const name="_dataType" access="priv" jdoc=""/>
			<const name="_sqlTypeName" access="priv" jdoc=""/>
			<const name="_nullable" access="priv" jdoc=""/>
			<const name="_defaultValue" access="priv" jdoc=""/>
			<const name="_remarks" access="priv" jdoc=""/>
			<const name="_autoIncrement" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.Column.Column(String, DataType)" access="pub" jdoc="Creates a Column object. This constructor set nullable to true. @param columnName the column name @param dataType the data type">
				<param name="columnName"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.Column(String, DataType, Nullable)" access="pub" jdoc="Creates a Column object.">
				<param name="columnName"/>
				<param name="dataType"/>
				<param name="nullable"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.Column(String, DataType, String, Nullable)" access="pub" jdoc="Creates a Column object.">
				<param name="columnName"/>
				<param name="dataType"/>
				<param name="sqlTypeName"/>
				<param name="nullable"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.Column(String, DataType, String, Nullable, String)" access="pub" jdoc="Creates a Column object. @param columnName The name of the column @param dataType The DbUnit {@link DataType} of the column @param sqlTypeName The SQL name of the column which comes from the JDBC driver. See value &amp;apos;TYPE_NAME&amp;apos; in {@link DatabaseMetaData#getColumns(String,String,String,String)} @param nullable whether or not the column is nullable @param defaultValue The default value on the DB for this column. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;.">
				<param name="columnName"/>
				<param name="dataType"/>
				<param name="sqlTypeName"/>
				<param name="nullable"/>
				<param name="defaultValue"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.Column(String, DataType, String, Nullable, String, String, AutoIncrement)" access="pub" jdoc="Creates a Column object. @param columnName The name of the column @param dataType The DbUnit {@link DataType} of the column @param sqlTypeName The SQL name of the column which comes from the JDBC driver. See value &amp;apos;TYPE_NAME&amp;apos; in {@link DatabaseMetaData#getColumns(String,String,String,String)} @param nullable whether or not the column is nullable @param defaultValue The default value on the DB for this column. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;. @param remarks The remarks on the DB for this column. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;. @param autoIncrement The auto increment setting for this column. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;.">
				<param name="columnName"/>
				<param name="dataType"/>
				<param name="sqlTypeName"/>
				<param name="nullable"/>
				<param name="defaultValue"/>
				<param name="remarks"/>
				<param name="autoIncrement"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.getColumnName()" access="pub" jdoc="Returns this column name.">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.getDataType()" access="pub" jdoc="Returns this column data type.">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.getSqlTypeName()" access="pub" jdoc="Returns this column sql data type name.">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.getNullable()" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if this column is nullable.">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.getDefaultValue()" access="pub" jdoc="@return The default value the database uses for this column if not specified in the insert column list">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.getRemarks()" access="pub" jdoc="@return The remarks set on the database for this column @since 2.4.3">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.getAutoIncrement()" access="pub" jdoc="@return The auto-increment property for this column @since 2.4.3">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.nullableValue(int)" access="pub" jdoc="Returns the appropriate Nullable constant according specified JDBC DatabaseMetaData constant. @param nullable one of the following constants{@link java.sql.DatabaseMetaData#columnNoNulls},{@link java.sql.DatabaseMetaData#columnNullable},{@link java.sql.DatabaseMetaData#columnNullableUnknown}">
				<param name="nullable"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.nullableValue(boolean)" access="pub" jdoc="Returns the appropriate Nullable constant. @param nullable &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if null is allowed">
				<param name="nullable"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.Column.equals(Object)" access="pub" jdoc="">
				<comm cntt="Default value is nullable"/>
				<param name="o"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column.hashCode()" access="pub" jdoc="">
			</mth>
		<class name="/:org.dbunit.dataset.Column$Nullable" intfc="n" abs="n" inn="y" sloc="12" jdoc="Specifies nullable usage. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 938 $ $Date: 2009-01-10 09:07:15 -0200 (SÃ¡b, 10 Jan 2009) $ @since Feb 17, 2002 @see Column">
			<comm cntt=""/>
			<comm cntt="Object class"/>
			<const name="_name" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.Column$Nullable.Nullable(String)" access="priv" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column$Nullable.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.Column$AutoIncrement" intfc="n" abs="n" inn="y" sloc="38" jdoc="Enumeration for valid auto-increment values provided by JDBC driver implementations. @author gommma @author Last changed by: $Author: gommma $ @version $Revision: 938 $ $Date: 2009-01-10 09:07:15 -0200 (SÃ¡b, 10 Jan 2009) $ @since 2.4.3 @see Column">
			<const name="YES" access="pub" jdoc=""/>
			<const name="NO" access="pub" jdoc=""/>
			<const name="UNKNOWN" access="pub" jdoc=""/>
			<const name="LOGGER" access="priv" jdoc="Logger for this class"/>
			<const name="key" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.Column$AutoIncrement.AutoIncrement(String)" access="priv" jdoc="">
				<param name="key"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column$AutoIncrement.getKey()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.Column$AutoIncrement.autoIncrementValue(String)" access="pub" jdoc="Searches the enumeration type for the given String provided by the JDBC driver. &amp;lt;p&amp;gt; If the parameter &amp;lt;code&amp;gt;autoIncrementValue&amp;lt; code&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;equalsIgnoreCase &amp;quot;YES&amp;quot; or equals &amp;quot;1&amp;quot; then {@link AutoIncrement#YES} is returned&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; &amp;lt; p&amp;gt; @param isAutoIncrement The String from the JDBC driver. @return The enumeration">
				<param name="isAutoIncrement"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Column$AutoIncrement.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.DataSetException" intfc="n" abs="n" inn="n" sloc="18" jdoc="Thrown to indicate that a problem occurred with a dataset. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 793 $ $Date: 2008-08-17 08:35:43 -0300 (Dom, 17 Ago 2008) $ @since Feb 17, 2002">
			<mth name="/:org.dbunit.dataset.DataSetException.DataSetException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetException.DataSetException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetException.DataSetException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.DataSetException.DataSetException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.NoSuchColumnException" intfc="n" abs="n" inn="n" sloc="37" jdoc="Thrown to indicate that a database column has been accessed that does not exist. @author Manuel Laflamme @version $Revision: 718 $ @since Feb 17, 2002">
			<mth name="/:org.dbunit.dataset.NoSuchColumnException.NoSuchColumnException()" access="pub" jdoc="@deprecated since 2.3.0. Prefer constructor taking a table columnName as argument">
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchColumnException.NoSuchColumnException(String)" access="pub" jdoc="@deprecated since 2.3.0. Prefer constructor taking a table columnName as argument">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchColumnException.NoSuchColumnException(String, String)" access="pub" jdoc="Creates an exception using the given table name + column name @param tableName table in which the column was not found. Can be null @param columnName the column that was not found @since 2.3.0">
				<param name="tableName"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchColumnException.NoSuchColumnException(String, String, String)" access="pub" jdoc="Creates an exception using the given table name + column name @param tableName table in which the column was not found. Can be null @param columnName the column that was not found @param msg Additional message to append to the exception text @since 2.3.0">
				<param name="tableName"/>
				<param name="columnName"/>
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchColumnException.NoSuchColumnException(String, Throwable)" access="pub" jdoc="@param msg @param e @deprecated since 2.3.0. Prefer constructor taking a table columnName as argument">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchColumnException.NoSuchColumnException(Throwable)" access="pub" jdoc="@param e @deprecated since 2.3.0. Prefer constructor taking a table columnName as argument">
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchColumnException.buildText(String, String, String)" access="priv" jdoc="">
				<param name="tableName"/>
				<param name="columnName"/>
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.LowerCaseTableMetaData" intfc="n" abs="n" inn="n" sloc="60" jdoc="Specialized ITableMetaData implementation that convert the table name and column names to lower case. Used in DbUnit own test suite to verify that operations are case insensitive. @author Manuel Laflamme @version $Revision: 873 $ @since Feb 14, 2003">
			<comm cntt=""/>
			<comm cntt="ITableMetaData interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tableName" access="priv" jdoc=""/>
			<const name="_columns" access="priv" jdoc=""/>
			<const name="_primaryKeys" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.LowerCaseTableMetaData(String, Column[])" access="pub" jdoc="">
				<comm cntt="throws DataSetException"/>
				<param name="tableName"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.LowerCaseTableMetaData(String, Column[], String[])" access="pub" jdoc="">
				<comm cntt="throws DataSetException"/>
				<param name="tableName"/>
				<param name="columns"/>
				<param name="primaryKeys"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.LowerCaseTableMetaData(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.LowerCaseTableMetaData(String, Column[], Column[])" access="pub" jdoc="">
				<comm cntt="throws DataSetException"/>
				<param name="tableName"/>
				<param name="columns"/>
				<param name="primaryKeys"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.createLowerColumns(Column[])" access="priv" jdoc="">
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.createLowerColumn(Column)" access="priv" jdoc="">
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.getColumns()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.LowerCaseTableMetaData.getPrimaryKeys()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.NoSuchTableException" intfc="n" abs="n" inn="n" sloc="18" jdoc="@author Manuel Laflamme @version $Revision: 398 $ @since Feb 17, 2002">
			<mth name="/:org.dbunit.dataset.NoSuchTableException.NoSuchTableException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchTableException.NoSuchTableException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchTableException.NoSuchTableException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.NoSuchTableException.NoSuchTableException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.Columns" intfc="n" abs="n" inn="n" sloc="151" jdoc="This class exclusively provides static methods that operate on {@link Column} objects. @author gommma @version $Revision: 887 $ @since 2.3.0">
			<comm cntt="ColumnComparator class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="COLUMN_COMPARATOR" access="priv" jdoc=""/>
			<const name="EMPTY_COLUMNS" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.Columns.Columns()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getColumns(String[], Column[])" access="pub" jdoc="Search and return the {@link Column}s from the specified column array that match one of the given &amp;lt;code&amp;gt;columnNames&amp;lt; code&amp;gt;. &amp;lt;br&amp;gt; Note that this method has a bad performance compared to {@link #findColumnsByName(String[],ITableMetaData)}because it iterates over all columns. @param columnNames the names of the columns to search. @param columns the array of columns in which the &amp;lt;code&amp;gt;columnNames&amp;lt; code&amp;gt; will be searched. @return the column array which is empty if no column has been found or no column names have been given @see #findColumnsByName(String[],ITableMetaData)">
				<param name="columnNames"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.findColumnsByName(String[], ITableMetaData)" access="pub" jdoc="Searches for the given &amp;lt;code&amp;gt;columns&amp;lt; code&amp;gt; using only the {@link Column#getColumnName()} in the given &amp;lt;code&amp;gt;tableMetaData&amp;lt; code&amp;gt; @param columnNames The column names that are searched in the given table metadata @param tableMetaData The table metadata in which the columns are searched by name @return The column objects from the given &amp;lt;code&amp;gt;tableMetaData&amp;lt; code&amp;gt; @throws NoSuchColumnException if the given column has not been found @throws DataSetException if something goes wrong when trying to retrieve the columns">
				<param name="columnNames"/>
				<param name="tableMetaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.findColumnsByName(Column[], ITableMetaData)" access="pub" jdoc="Searches for the given &amp;lt;code&amp;gt;columns&amp;lt; code&amp;gt; using only the {@link Column#getColumnName()} in the given &amp;lt;code&amp;gt;tableMetaData&amp;lt; code&amp;gt; @param columns The columns whose names are searched in the given table metadata @param tableMetaData The table metadata in which the columns are searched by name @return The column objects from the given &amp;lt;code&amp;gt;tableMetaData&amp;lt; code&amp;gt; @throws NoSuchColumnException if the given column has not been found @throws DataSetException if something goes wrong when trying to retrieve the columns">
				<param name="columns"/>
				<param name="tableMetaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getColumn(String, Column[])" access="pub" jdoc="Search and return the specified column from the specified column array. &amp;lt;br&amp;gt; Note that this method has a bad performance compared to {@link ITableMetaData#getColumnIndex(String)}because it iterates over all columns. @param columnName the name of the column to search. @param columns the array of columns in which the &amp;lt;code&amp;gt;columnName&amp;lt; code&amp;gt; will be searched. @return the column or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if the column is not found">
				<param name="columnName"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getColumnValidated(String, Column[], String)" access="pub" jdoc="Search and return the specified column from the specified column array. @param columnName the name of the column to search. @param columns the array of columns in which the &amp;lt;code&amp;gt;columnName&amp;lt; code&amp;gt; will be searched. @param tableName The name of the table to which the column array belongs - only needed for the exception message in case of a validation failure @return the valid column @throws NoSuchColumnException If no column exists with the given name">
				<param name="columnName"/>
				<param name="columns"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getColumns(String, Column[], IColumnFilter)" access="pub" jdoc="Search and return the columns from the specified column array which are accepted by the given {@link IColumnFilter}. @param tableName The name of the table which is needed for the filter invocation @param columns All available columns to which the filter will be applied @param columnFilter The column filter that is applied to the given &amp;lt;code&amp;gt;columns&amp;lt; code&amp;gt; @return The columns that are accepted by the given filter">
				<param name="tableName"/>
				<param name="columns"/>
				<param name="columnFilter"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getSortedColumns(ITableMetaData)" access="pub" jdoc="Returns a sorted array of column objects @param metaData The metaData needed to get the columns to be sorted @return The columns sorted by their column names, ignoring the case of the column names @throws DataSetException">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getColumnNames(Column[])" access="pub" jdoc="Returns the names of the given column objects as string array @param columns The column objects @return The names of the given column objects @since 2.4">
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getColumnNamesAsString(Column[])" access="pub" jdoc="Creates a pretty string representation of the given column names @param columns The columns to be formatted @return The string representation of the given column names">
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.mergeColumnsByName(Column[], Column[])" access="pub" jdoc="Merges the two arrays of columns so that all of the columns are available in the result array. The first array is considered as master and if a column with a specific name is available in both arrays the one from the first array is used. @param referenceColumns reference columns treated as master columns during the merge @param columnsToMerge potentially new columns to be merged if they do not yet exist in the referenceColumns @return Array of merged columns">
				<comm cntt="All columns that exist in the referenceColumns"/>
				<comm cntt="Check if this colToMerge exists in the refColumn"/>
				<comm cntt="We found the column in the refColumns - so no candidate for adding to the result list"/>
				<comm cntt="Add all &amp;quot;columnsToMerge&amp;quot; that have not been found in the referenceColumnList"/>
				<param name="referenceColumns"/>
				<param name="columnsToMerge"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns.getColumnDiff(ITableMetaData, ITableMetaData)" access="pub" jdoc="Returns the column difference of the two given {@link ITableMetaData} objects @param expectedMetaData @param actualMetaData @return The columns that differ in the both given {@link ITableMetaData} objects @throws DataSetException">
				<param name="expectedMetaData"/>
				<param name="actualMetaData"/>
			</mth>
		<class name="/:org.dbunit.dataset.Columns$ColumnComparator" intfc="n" abs="n" inn="y" sloc="13" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.Columns$ColumnComparator.compare(Object, Object)" access="pub" jdoc="Compare columns by name ignoring case @see java.util.Comparator#compare(T,T)">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.Columns$ColumnDiff" intfc="n" abs="n" inn="y" sloc="94" jdoc="Describes the {@link Column}s that are different in two tables. @author gommma @version $Revision: 887 $ @since 2.3.0">
			<comm cntt=""/>
			<comm cntt="@return A pretty formatted message that shows up the difference"/>
			<comm cntt=""/>
			<comm cntt="private String toMessage()"/>
			<comm cntt="{"/>
			<comm cntt="StringBuffer sb = new StringBuffer();"/>
			<comm cntt="sb.append(&amp;quot;column-diffs (expected &amp;lt;-&amp;gt; actual): &amp;quot;);"/>
			<comm cntt="if(this.hasDifference())"/>
			<comm cntt="{"/>
			<comm cntt="sb.append(getExpectedAsString());"/>
			<comm cntt="sb.append(&amp;quot; &amp;lt;-&amp;gt; &amp;quot;);"/>
			<comm cntt="sb.append(getActualAsString());"/>
			<comm cntt="}"/>
			<comm cntt="else"/>
			<comm cntt="{"/>
			<comm cntt="sb.append(NO_DIFFERENCE);"/>
			<comm cntt="}"/>
			<comm cntt="return sb.toString();"/>
			<comm cntt="}"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="NO_DIFFERENCE" access="priv" jdoc="String message that is returned when no difference has been found in the compared columns"/>
			<field name="expected" access="priv" jdoc="The columns that exist in the expected result but not in the actual"/>
			<field name="actual" access="priv" jdoc="The columns that exist in the actual result but not in the expected"/>
			<field name="expectedMetaData" access="priv" jdoc=""/>
			<field name="actualMetaData" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.ColumnDiff(ITableMetaData, ITableMetaData)" access="pub" jdoc="Creates the difference between the two metadata&amp;apos;s columns @param expectedMetaData The metadata of the expected results table @param actualMetaData The metadata of the actual results table @throws DataSetException">
				<comm cntt="Get the columns that are missing on the actual side (walk through actual"/>
				<comm cntt="columns and look for them in the expected metadata)"/>
				<comm cntt="Get the columns that are missing on the expected side (walk through expected"/>
				<comm cntt="columns and look for them in the actual metadata)"/>
				<param name="expectedMetaData"/>
				<param name="actualMetaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.findMissingColumnsIn(ITableMetaData, Column[])" access="priv" jdoc="Searches and returns all columns that are missing in the given {@link ITableMetaData} object @param metaDataToCheck The {@link ITableMetaData} in which the given columns should be searched @param columnsToSearch The columns to be searched in the given {@link ITableMetaData} @return Those {@link Column}s out of the columnsToSearch that have not been found in metaDataToCheck @throws DataSetException">
				<param name="metaDataToCheck"/>
				<param name="columnsToSearch"/>
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.hasDifference()" access="pub" jdoc="@return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if there is a difference in the columns given in the constructor">
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.getExpected()" access="pub" jdoc="@return The columns that exist in the expected result but not in the actual">
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.getActual()" access="pub" jdoc="@return The columns that exist in the actual result but not in the expected">
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.getExpectedAsString()" access="pub" jdoc="@return The value of {@link #getExpected()} as formatted string @see #getExpected()">
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.getActualAsString()" access="pub" jdoc="@return The value of {@link #getActual()} as formatted string @see #getActual()">
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.getMessage()" access="pub" jdoc="@return A pretty formatted message that can be used for user information @throws DataSetException">
			</mth>
			<mth name="/:org.dbunit.dataset.Columns$ColumnDiff.toString()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.common.handlers">
		<class name="/:org.dbunit.dataset.common.handlers.EnforceHandler" intfc="n" abs="n" inn="n" sloc="52" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="enforcedComponents" access="priv" jdoc=""/>
			<field name="theHandlerComponent" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.EnforceHandler(PipelineComponent[])" access="priv" jdoc="">
				<param name="components"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.ENFORCE(PipelineComponent)" access="pub" jdoc="">
				<param name="component"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.ENFORCE(PipelineComponent[])" access="pub" jdoc="">
				<param name="components"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.setPipeline(Pipeline)" access="pub" jdoc="">
				<param name="pipeline"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.getEnforcedComponents()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.setEnforcedComponents(PipelineComponent[])" access="prot" jdoc="">
				<param name="enforcedComponents"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.getTheHandlerComponent()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler.setTheHandlerComponent(PipelineComponent)" access="pub" jdoc="">
				<param name="theHandlerComponent"/>
			</mth>
		<class name="/:org.dbunit.dataset.common.handlers.EnforceHandler$ENFORCE" intfc="n" abs="n" inn="y" sloc="16" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.EnforceHandler$ENFORCE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="ignore the char"/>
				<param name="c"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent" intfc="n" abs="y" inn="n" sloc="67" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="successor" access="priv" jdoc=""/>
			<field name="pipeline" access="priv" jdoc=""/>
			<field name="helper" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.getSuccessor()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.getPipeline()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.setPipeline(Pipeline)" access="pub" jdoc="">
				<param name="pipeline"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.getPipelineConfig()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.setSuccessor(PipelineComponent)" access="pub" jdoc="">
				<param name="successor"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.getThePiece()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.handle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.noMoreInput()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.allowForNoMoreInput()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.createPipelineComponent(AbstractPipelineComponent, Helper)" access="prot" jdoc="">
				<param name="handler"/>
				<param name="helper"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.accept(char)" access="pub" jdoc="Method invoked when the character should be accepted @param c">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.getHelper()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent.setHelper(Helper)" access="priv" jdoc="">
				<param name="helper"/>
			</mth>
		<class name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent$IGNORE" intfc="n" abs="n" inn="y" sloc="4" jdoc="">
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent$IGNORE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="IGNORE"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent$ACCEPT" intfc="n" abs="n" inn="y" sloc="7" jdoc="">
			<mth name="/:org.dbunit.dataset.common.handlers.AbstractPipelineComponent$ACCEPT.helpWith(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.UnquotedFieldAssembler" intfc="n" abs="n" inn="n" sloc="19" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<comm cntt="private LinkedList getAddedComponents() {"/>
			<comm cntt="logger.debug(&amp;quot;getAddedComponents() - start&amp;quot;);"/>
			<comm cntt=""/>
			<comm cntt="return addedComponents;"/>
			<comm cntt="}"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="addedComponents" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.UnquotedFieldAssembler.UnquotedFieldAssembler()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.UnquotedFieldAssembler.setAddedComponents(LinkedList)" access="priv" jdoc="">
				<param name="addedComponents"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.UnquotedFieldAssembler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		<class name="/:org.dbunit.dataset.common.handlers.UnquotedFieldAssembler$ASSEMBLE" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.UnquotedFieldAssembler$ASSEMBLE.helpWith(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.WhitespacesHandler" intfc="n" abs="n" inn="n" sloc="17" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.WhitespacesHandler.WhitespacesHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.WhitespacesHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.WhitespacesHandler.ACCEPT()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.WhitespacesHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.LineEndHandler" intfc="n" abs="n" inn="n" sloc="4" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<mth name="/:org.dbunit.dataset.common.handlers.LineEndHandler.LineEndHandler()" access="priv" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler" intfc="n" abs="n" inn="n" sloc="29" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<comm cntt="public static final PipelineComponent UNQUOTE () { return createPipelineComponent(new IsAlnumHandler(), new UNQUOTE()); }"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler.IsAlnumHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler.ACCEPT()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler.QUOTE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		<class name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler$QUOTE" intfc="n" abs="n" inn="y" sloc="11" jdoc="">
			<comm cntt="private boolean add = true;"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler$QUOTE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="getHandler().getPipeline().putFront(IsAlnumHandler.UNQUOTE());"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler$UNQUOTE" intfc="n" abs="n" inn="y" sloc="15" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.IsAlnumHandler$UNQUOTE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="ignore the char"/>
				<param name="c"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.Handler" intfc="y" abs="n" inn="n" sloc="6" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<mth name="/:org.dbunit.dataset.common.handlers.Handler.handle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Handler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Handler.noMoreInput()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Handler.allowForNoMoreInput()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.EscapeHandler" intfc="n" abs="n" inn="n" sloc="27" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<comm cntt="@todo: make sense?"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DEFAULT_ESCAPE_CHAR" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.EscapeHandler.EscapeHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EscapeHandler.ACCEPT()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EscapeHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EscapeHandler.ESCAPE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.EscapeHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		<class name="/:org.dbunit.dataset.common.handlers.EscapeHandler$ESCAPE" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.EscapeHandler$ESCAPE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="ignore the char"/>
				<param name="c"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.PipelineException" intfc="n" abs="n" inn="n" sloc="5" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineException.PipelineException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.QuoteHandler" intfc="n" abs="n" inn="n" sloc="30" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="QUOTE_CHAR" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler.QuoteHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler.ACCEPT()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler.QUOTE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler.UNQUOTE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		<class name="/:org.dbunit.dataset.common.handlers.QuoteHandler$QUOTE" intfc="n" abs="n" inn="y" sloc="12" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler$QUOTE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="ignore the char"/>
				<param name="c"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.QuoteHandler$UNQUOTE" intfc="n" abs="n" inn="y" sloc="20" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler$UNQUOTE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="ignore the char"/>
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.QuoteHandler$UNQUOTE.allowForNoMoreInput()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.Pipeline" intfc="n" abs="n" inn="n" sloc="114" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="components" access="priv" jdoc=""/>
			<field name="products" access="priv" jdoc=""/>
			<field name="currentProduct" access="priv" jdoc=""/>
			<field name="noHandler" access="priv" jdoc=""/>
			<field name="pipelineConfig" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.Pipeline()" access="pub" jdoc="">
				<comm cntt="add a no handler as the last handler"/>
				<comm cntt="add a transparent handler as placeholder"/>
				<comm cntt="getComponents().addFirst(TransparentHandler.IGNORE);"/>
				<comm cntt="prepareNewPiece();"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.getCurrentProduct()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.setCurrentProduct(StringBuffer)" access="pub" jdoc="">
				<param name="currentProduct"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.prepareNewPiece()" access="priv" jdoc="">
				<comm cntt="remove all the components down to a TrasparentHandler"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.thePieceIsDone()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.getProducts()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.setProducts(List)" access="prot" jdoc="">
				<param name="products"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.getComponents()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.setComponents(LinkedList)" access="priv" jdoc="">
				<param name="components"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.putFront(PipelineComponent)" access="pub" jdoc="">
				<param name="component"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.removeFront()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.remove(PipelineComponent)" access="pub" jdoc="">
				<param name="component"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.handle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.allowForNoMoreInput()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.getNoHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.setNoHandler(PipelineComponent)" access="priv" jdoc="">
				<param name="noHandler"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.resetProducts()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.noMoreInput()" access="pub" jdoc="">
				<comm cntt="thePieceIsDone();"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.getPipelineConfig()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Pipeline.setPipelineConfig(PipelineConfig)" access="pub" jdoc="">
				<param name="pipelineConfig"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.NoHandler" intfc="n" abs="n" inn="n" sloc="9" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<mth name="/:org.dbunit.dataset.common.handlers.NoHandler.NoHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.NoHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.NoHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.Helper" intfc="n" abs="y" inn="n" sloc="15" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="handler" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.Helper.helpWith(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Helper.allowForNoMoreInput()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Helper.getHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.Helper.setHandler(PipelineComponent)" access="pub" jdoc="">
				<param name="handler"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.PipelineComponent" intfc="y" abs="n" inn="n" sloc="6" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineComponent.setSuccessor(PipelineComponent)" access="pub" jdoc="">
				<param name="successor"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineComponent.accept(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineComponent.setPipeline(Pipeline)" access="pub" jdoc="">
				<param name="line"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineComponent.getPipeline()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.PipelineConfig" intfc="n" abs="n" inn="n" sloc="19" jdoc="@author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 817 $ $Date: 2008-09-29 17:23:35 -0300 (Seg, 29 Set 2008) $ @since 2.4.0">
			<field name="separatorChar" access="priv" jdoc=""/>
			<field name="escapeChar" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineConfig.PipelineConfig()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineConfig.getSeparatorChar()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineConfig.setSeparatorChar(char)" access="pub" jdoc="">
				<param name="separatorChar"/>
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineConfig.getEscapeChar()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.PipelineConfig.setEscapeChar(char)" access="pub" jdoc="">
				<param name="escapeChar"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.SeparatorHandler" intfc="n" abs="n" inn="n" sloc="28" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="DEFAULT_SEPARATOR_CHAR" access="pub" jdoc=""/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.SeparatorHandler.SeparatorHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.SeparatorHandler.ACCEPT()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.SeparatorHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.SeparatorHandler.ENDPIECE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.SeparatorHandler.canHandle(char)" access="pub" jdoc="">
				<comm cntt="throw new IllegalInputCharacterException(&amp;quot;Cannot handle character &amp;apos;&amp;quot; + c + &amp;quot;&amp;apos;&amp;quot;);"/>
				<param name="c"/>
			</mth>
		<class name="/:org.dbunit.dataset.common.handlers.SeparatorHandler$ENDPIECE" intfc="n" abs="n" inn="y" sloc="8" jdoc="">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.SeparatorHandler$ENDPIECE.helpWith(char)" access="pub" jdoc="">
				<comm cntt="we are done with the piece"/>
				<param name="c"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.IllegalInputCharacterException" intfc="n" abs="n" inn="n" sloc="6" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<mth name="/:org.dbunit.dataset.common.handlers.IllegalInputCharacterException.IllegalInputCharacterException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.TransparentHandler" intfc="n" abs="n" inn="n" sloc="13" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.TransparentHandler.TransparentHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.TransparentHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.TransparentHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.common.handlers.AllHandler" intfc="n" abs="n" inn="n" sloc="15" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.2 (Sep 12, 2004)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.common.handlers.AllHandler.AllHandler()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AllHandler.ACCEPT()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AllHandler.IGNORE()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.common.handlers.AllHandler.canHandle(char)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.csv">
		<class name="/:org.dbunit.dataset.csv.IllegalCharacterSeen" intfc="n" abs="n" inn="n" sloc="5" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since Sep 12, 2004 (pre 2.3)">
			<mth name="/:org.dbunit.dataset.csv.IllegalCharacterSeen.IllegalCharacterSeen(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvParser" intfc="y" abs="n" inn="n" sloc="5" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 825 $ $Date: 2008-10-05 14:40:31 -0300 (Dom, 05 Out 2008) $ @since 2.2 (Sep 12, 2004)">
			<mth name="/:org.dbunit.dataset.csv.CsvParser.parse(File)" access="pub" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParser.parse(URL)" access="pub" jdoc="">
				<param name="url"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParser.parse(String)" access="pub" jdoc="">
				<param name="csv"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvProducer" intfc="n" abs="n" inn="n" sloc="93" jdoc="@author Federico Spinazzi @author Last changed by: $Author: gommma $ @version $Revision: 1042 $ $Date: 2009-09-24 05:13:17 -0300 (Qui, 24 Set 2009) $ @since 1.5 (Sep 17, 2003)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EMPTY_CONSUMER" access="priv" jdoc=""/>
			<field name="_consumer" access="priv" jdoc=""/>
			<field name="_theDirectory" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.csv.CsvProducer.CsvProducer(String)" access="pub" jdoc="">
				<param name="theDirectory"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvProducer.CsvProducer(File)" access="pub" jdoc="">
				<param name="theDirectory"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvProducer.setConsumer(IDataSetConsumer)" access="pub" jdoc="">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvProducer.produce()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvProducer.produceFromFile(File)" access="priv" jdoc="">
				<param name="theDataFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvProducer.getTables(URL, String)" access="pub" jdoc="Get a list of tables that this producer will create @return a list of Strings, where each item is a CSV file relative to the base URL @throws IOException when IO on the base URL has issues.">
				<param name="base"/>
				<param name="tableList"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvDataSet" intfc="n" abs="n" inn="n" sloc="6" jdoc="This class constructs an IDataSet given a directory containing CSV files. It handles translations of &amp;quot;null&amp;quot;(the string), into null. @author Lenny Marks (lenny@aps.org) @author Last changed by: $Author: gommma $ @version $Revision: 770 $ $Date: 2008-08-04 16:30:27 -0300 (Seg, 04 Ago 2008) $ @since Sep 12, 2004 (pre 2.3)">
			<comm cntt="private File dir;"/>
			<const name="TABLE_ORDERING_FILE" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSet.CsvDataSet(File)" access="pub" jdoc="">
				<comm cntt="this.dir = dir;"/>
				<param name="dir"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvDataSetWriter" intfc="n" abs="n" inn="n" sloc="163" jdoc="@author fede @since 24-set-2003 15.27.05 @version $Revision: 1042 $">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="NULL" access="pub" jdoc="todo: customizable separators (field, lines), manage the writers opened for each table"/>
			<const name="NONE" access="priv" jdoc=""/>
			<const name="FIELD_SEPARATOR" access="priv" jdoc=""/>
			<const name="QUOTE" access="priv" jdoc=""/>
			<const name="ESCAPE" access="priv" jdoc=""/>
			<field name="writer" access="priv" jdoc=""/>
			<field name="_activeMetaData" access="priv" jdoc=""/>
			<field name="theDirectory" access="priv" jdoc=""/>
			<field name="testExport" access="priv" jdoc=""/>
			<field name="tableList" access="priv" jdoc="list of tables"/>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.CsvDataSetWriter(String)" access="pub" jdoc="">
				<param name="theDirectory"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.CsvDataSetWriter(File)" access="pub" jdoc="">
				<param name="theDirectory"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.write(IDataSet)" access="pub" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.startDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.endDataSet()" access="pub" jdoc="">
				<comm cntt="write out table ordering file"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.startTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.writeColumnNames()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.endTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.row(Object[])" access="pub" jdoc="">
				<comm cntt="null"/>
				<comm cntt="none"/>
				<comm cntt="values"/>
				<param name="values"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.quote(String)" access="priv" jdoc="">
				<param name="stringValue"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.escape(String)" access="prot" jdoc="">
				<param name="stringValue"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.getWriter()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.setWriter(Writer)" access="pub" jdoc="">
				<param name="writer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.getTheDirectory()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.setTheDirectory(String)" access="pub" jdoc="">
				<param name="theDirectory"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.write(IDataSet, File)" access="pub" jdoc="">
				<param name="dataset"/>
				<param name="dest"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvDataSetWriter.finalize()" access="prot" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvURLDataSet" intfc="n" abs="n" inn="n" sloc="6" jdoc="This class constructs an IDataSet given a base URL containing CSV files. It handles translations of &amp;quot;null&amp;quot; (the string), into null. Based HEAVILY on {@link org.dbunit.dataset.csv.CsvDataSet} @author Lenny Marks (lenny@aps.org) @author Dion Gillard (diongillard@users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 770 $ $Date: 2008-08-04 16:30:27 -0300 (Seg, 04 Ago 2008) $ @since 2.1.0">
			<comm cntt="private URL base;"/>
			<mth name="/:org.dbunit.dataset.csv.CsvURLDataSet.CsvURLDataSet(URL)" access="pub" jdoc="Create a Data Set from CSV files, using the base URL provided to find data.">
				<comm cntt="this.base = base;"/>
				<param name="base"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvParserException" intfc="n" abs="n" inn="n" sloc="5" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since Sep 12, 2004 (pre 2.3)">
			<mth name="/:org.dbunit.dataset.csv.CsvParserException.CsvParserException(String)" access="pub" jdoc="">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvURLProducer" intfc="n" abs="n" inn="n" sloc="65" jdoc="A {@link IDataSetProducer Data Set Producer} that produces datasets from CVS files found at a base URL. Based HEAVILY on {@link org.dbunit.dataset.csv.CsvProducer}. @author Dion Gillard @author Federico Spinazzi @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since Sep 12, 2004 (pre 2.3)">
			<comm cntt="@see IDataSetProducer#setConsumer(org.dbunit.dataset.stream.IDataSetConsumer)"/>
			<comm cntt="@see IDataSetProducer#produce()"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EMPTY_CONSUMER" access="priv" jdoc="the default consumer - does nothing"/>
			<field name="_consumer" access="priv" jdoc="the consumer of the produced datasets, by default a {@link DefaultConsumer}"/>
			<field name="base" access="priv" jdoc="the base url to retrieve data from"/>
			<field name="tableList" access="priv" jdoc="the offset from the base url where the list of tables can be found"/>
			<mth name="/:org.dbunit.dataset.csv.CsvURLProducer.CsvURLProducer(URL, String)" access="pub" jdoc="Create a CSV Data Set Producer which uses the base URL to retrieve a list of tables and the data. @param base the URL where the tableList and data can be found. @param tableList the relative location of the list of tables.">
				<param name="base"/>
				<param name="tableList"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvURLProducer.setConsumer(IDataSetConsumer)" access="pub" jdoc="">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvURLProducer.produce()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvURLProducer.produceFromURL(URL)" access="priv" jdoc="Produce a dataset from a URL. The URL is assumed to contain data in CSV format. @param url a url containing CSV data.">
				<param name="url"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.csv.CsvParserImpl" intfc="n" abs="n" inn="n" sloc="120" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 823 $ $Date: 2008-10-05 07:15:40 -0300 (Dom, 05 Out 2008) $ @since 2.2 (Sep 12, 2004)">
			<comm cntt="private List parseFirstLine(LineNumberReader lineNumberReader, File file, List rows) throws IOException, CsvParserException {"/>
			<comm cntt="if(logger.isDebugEnabled())"/>
			<comm cntt="logger.debug(&amp;quot;parseFirstLine(lineNumberReader={}, file={}, rows={}) - start&amp;quot;,"/>
			<comm cntt="new Object[]{lineNumberReader, file, rows} );"/>
			<comm cntt=""/>
			<comm cntt="return parseFirstLine(lineNumberReader, file.getAbsolutePath().toString(), rows);"/>
			<comm cntt="}"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="pipeline" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.CsvParserImpl()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.resetThePipeline()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.parse(String)" access="pub" jdoc="">
				<param name="csv"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.parse(File)" access="pub" jdoc="">
				<param name="file"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.parse(URL)" access="pub" jdoc="">
				<param name="url"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.parse(Reader, String)" access="pub" jdoc="">
				<param name="reader"/>
				<param name="source"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.parseFirstLine(LineNumberReader, String, List)" access="priv" jdoc="parse the first line of data from the given source">
				<param name="lineNumberReader"/>
				<param name="source"/>
				<param name="rows"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.parseTheData(List, LineNumberReader, List)" access="priv" jdoc="">
				<param name="columnsInFirstLine"/>
				<param name="lineNumberReader"/>
				<param name="rows"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.collectExpectedNumberOfColumns(int, LineNumberReader)" access="priv" jdoc="">
				<param name="expectedNumberOfColumns"/>
				<param name="lineNumberReader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.getPipeline()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.csv.CsvParserImpl.setPipeline(Pipeline)" access="pub" jdoc="">
				<param name="pipeline"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.datatype">
		<class name="/:org.dbunit.dataset.datatype.IDbProductRelatable" intfc="y" abs="n" inn="n" sloc="4" jdoc="Reports what database products this object relates to. Typically implemented by an &amp;lt;code&amp;gt;IDaatTypeFactory&amp;lt; code&amp;gt;. @author John Hurst @author Last changed by: $Author: $ @version $Revision:$ $Date:$ @since 2.4.6 (Septemeber 11, 2009) @see IDataTypeFactory">
			<mth name="/:org.dbunit.dataset.datatype.IDbProductRelatable.getValidDbProducts()" access="pub" jdoc="Returns a set of Strings representing database product names that this object relates to. @return Set of Strings.">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.BitDataType" intfc="n" abs="n" inn="n" sloc="7" jdoc="@author gommma @author Last changed by: $Author: gommma $ @version $Revision: 783 $ $Date: 2008-08-10 18:34:56 -0300 (Dom, 10 Ago 2008) $ @since 2.3.0">
			<mth name="/:org.dbunit.dataset.datatype.BitDataType.BitDataType()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.StringDataType" intfc="n" abs="n" inn="n" sloc="100" jdoc="@author Manuel Laflamme @author Last changed by: $Author: jbhurst $ @version $Revision: 1124 $ $Date: 2009-12-01 18:49:33 -0200 (Ter, 01 Dez 2009) $ @since 1.0">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.StringDataType.StringDataType(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.StringDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.StringDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.StringDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.BooleanDataType" intfc="n" abs="n" inn="n" sloc="88" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1023 $ $Date: 2009-08-03 18:08:12 -0300 (Seg, 03 Ago 2009) $">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.BooleanDataType.BooleanDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BooleanDataType.BooleanDataType(String, int)" access="pub" jdoc="@param name @param sqlType @since 2.3">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BooleanDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BooleanDataType.compareNonNulls(Object, Object)" access="prot" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BooleanDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BooleanDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.BlobDataType" intfc="n" abs="n" inn="n" sloc="28" jdoc="@author Manuel Laflamme @version $Revision: 754 $ @since Jan 12, 2004">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.BlobDataType.BlobDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BlobDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BlobDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.ClobDataType" intfc="n" abs="n" inn="n" sloc="26" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 773 $ $Date: 2008-08-05 16:08:51 -0300 (Ter, 05 Ago 2008) $ @since Jan 12, 2004">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.ClobDataType.ClobDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ClobDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ClobDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.AbstractDataType" intfc="n" abs="y" inn="n" sloc="119" jdoc="Abstract data type implementation that provides generic methods that are appropriate for most data type implementations. Among those is the generic implementation of the {@link #compare(Object,Object)} method. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 909 $ $Date: 2008-12-04 18:20:00 -0200 (Qui, 04 Dez 2008) $ @since Mar 19, 2002">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<comm cntt=""/>
			<comm cntt="Object class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_name" access="priv" jdoc=""/>
			<const name="_sqlType" access="priv" jdoc=""/>
			<const name="_classType" access="priv" jdoc=""/>
			<const name="_isNumber" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.AbstractDataType(String, int, Class, boolean)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
				<param name="classType"/>
				<param name="isNumber"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.compare(Object, Object)" access="pub" jdoc="">
				<comm cntt="New in 2.3: Object level check for equality - should give massive performance improvements"/>
				<comm cntt="in the most cases because the typecast can be avoided (null values and equal objects)"/>
				<comm cntt="Comparable check based on the results of method &amp;quot;typeCast&amp;quot;"/>
				<comm cntt="Check for &amp;quot;null&amp;quot;s again because typeCast can produce them"/>
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.compareNonNulls(Object, Object)" access="prot" jdoc="Compares non-null values to each other. Both objects are guaranteed to be not null and to implement the interface {@link Comparable}. The two given objects are the results of the {@link #typeCast(Object)} method call which is usually implemented by a specialized {@link DataType} implementation. @param value1 First value resulting from the {@link #typeCast(Object)} method call @param value2 Second value resulting from the {@link #typeCast(Object)} method call @return The result of the {@link Comparable#compareTo(Object)} invocation. @throws TypeCastException">
				<param name="value1"/>
				<param name="value2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.areObjectsEqual(Object, Object)" access="prot" jdoc="Checks whether the given objects are equal or not. @param o1 first object @param o2 second object @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if both objects are &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; (and hence equal) or if the &amp;lt;code&amp;gt;o1.equals(o2)&amp;lt; code&amp;gt; is &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt;.">
				<comm cntt="Note that no more check is needed for o2 because it definitely does is not equal to o1"/>
				<comm cntt="Instead immediately proceed with the typeCast method"/>
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.getSqlType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.getTypeClass()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.isNumber()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.isDateTime()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.loadClass(String, Connection)" access="prot" jdoc="@param clazz The fully qualified name of the class to be loaded @param connection The JDBC connection needed to load the given class @return The loaded class @throws ClassNotFoundException">
				<param name="clazz"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.loadClass(String, ClassLoader)" access="prot" jdoc="@param clazz The fully qualified name of the class to be loaded @param classLoader The classLoader to be used to load the given class @return The loaded class @throws ClassNotFoundException">
				<param name="clazz"/>
				<param name="classLoader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.AbstractDataType.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.TimestampDataType" intfc="n" abs="n" inn="n" sloc="84" jdoc="@author Manuel Laflamme @author Last changed by: $Author: jbhurst $ @version $Revision: 1131 $ $Date: 2009-12-27 17:22:13 -0200 (Dom, 27 Dez 2009) $ @since 1.0 (Feb 19, 2002)">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.TimestampDataType.TimestampDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimestampDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimestampDataType.isDateTime()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimestampDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimestampDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.NumberTolerantDataType" intfc="n" abs="n" inn="n" sloc="77" jdoc="Extended version of the {@link NumberDataType}. Extends the {@link #compare(Object,Object)} method in order to respect precision tolerance. This is comparable to the JUnit method &amp;lt;code&amp;gt;assert(double val1, double val2, double toleratedDelta)&amp;lt; code&amp;gt;. @author gommma @author Last changed by: $Author: gommma $ @version $Revision: 909 $ $Date: 2008-12-04 18:20:00 -0200 (Qui, 04 Dez 2008) $ @since 2.3.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="C_100" access="priv" jdoc=""/>
			<field name="toleratedDelta" access="priv" jdoc="The allowed tolerated difference"/>
			<mth name="/:org.dbunit.dataset.datatype.NumberTolerantDataType.NumberTolerantDataType(String, int, Precision)" access="pub" jdoc="Creates a new number tolerant datatype @param name @param sqlType @param delta The tolerated delta to be used for the comparison">
				<param name="name"/>
				<param name="sqlType"/>
				<param name="delta"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.NumberTolerantDataType.getToleratedDelta()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.NumberTolerantDataType.compareNonNulls(Object, Object)" access="prot" jdoc="The only method overwritten from the base implementation to compare numbers allowing a tolerance @see org.dbunit.dataset.datatype.AbstractDataType#compareNonNulls(java.lang.Object,java.lang.Object)">
				<comm cntt="Start of special handling"/>
				<comm cntt="Exact match"/>
				<comm cntt="within tolerance delta, so accept"/>
				<comm cntt="TODO it would be beautiful to report a precise description about difference and tolerated delta values in the assertion"/>
				<comm cntt="Therefore think about introducing a method &amp;quot;DataType.getCompareInfo()&amp;quot;"/>
				<comm cntt="percentage comparison"/>
				<comm cntt="within tolerance delta, so accept"/>
				<comm cntt="TODO it would be beautiful to report a precise description about difference and tolerated delta values in the assertion"/>
				<comm cntt="Therefore think about introducing a method &amp;quot;DataType.getCompareInfo()&amp;quot;"/>
				<param name="value1cast"/>
				<param name="value2cast"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.NumberTolerantDataType.isZero(BigDecimal)" access="pub" jdoc="Checks if the given value is zero. @param value @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if and only if the given value is zero.">
				<param name="value"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.TimeDataType" intfc="n" abs="n" inn="n" sloc="67" jdoc="Data type that maps a SQL {@link Types#TIME} object to a java object. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 767 $ $Date: 2008-08-01 09:26:47 -0300 (Sex, 01 Ago 2008) $ @since 1.0 (Feb 19, 2002)">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.TimeDataType.TimeDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimeDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimeDataType.isDateTime()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimeDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TimeDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.BytesDataType" intfc="n" abs="n" inn="n" sloc="188" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1179 $ $Date: 2010-03-25 19:09:07 -0300 (Qui, 25 Mar 2010) $ @since 1.0 (Mar 20, 2002)">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="MAX_URI_LENGTH" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.datatype.BytesDataType.BytesDataType(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BytesDataType.toByteArray(InputStream, int)" access="priv" jdoc="">
				<param name="in"/>
				<param name="length"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BytesDataType.typeCast(Object)" access="pub" jdoc="Casts the given value into a byte[] using different strategies. Note that this might sometimes result in undesired behavior when character data (Strings) are used. @see org.dbunit.dataset.datatype.DataType#typeCast(java.lang.Object)">
				<comm cntt="Assume not an uri if length greater than max uri length"/>
				<comm cntt="Try value as URL"/>
				<comm cntt="Not an URL, try as file name"/>
				<comm cntt="Not a file name either"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BytesDataType.compareNonNulls(Object, Object)" access="prot" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BytesDataType.compare(byte[], byte[])" access="pub" jdoc="">
				<param name="v1"/>
				<param name="v2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BytesDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BytesDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.BinaryStreamDataType" intfc="n" abs="n" inn="n" sloc="53" jdoc="@author fede @author Last changed by: $Author: gommma $ @version $Revision: 940 $ $Date: 2009-01-13 19:13:32 -0200 (Ter, 13 Jan 2009) $ @since Sep 12, 2004 (pre 2.3)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.BinaryStreamDataType.BinaryStreamDataType(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BinaryStreamDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BinaryStreamDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="Sets the given value on the given statement and therefore invokes {@link BytesDataType#typeCast(Object)}. @see org.dbunit.dataset.datatype.BytesDataType#setSqlValue(java.lang.Object,int,java.sql.PreparedStatement)">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.IntegerDataType" intfc="n" abs="n" inn="n" sloc="53" jdoc="@author Manuel Laflamme @version $Revision: 1023 $">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.IntegerDataType.IntegerDataType(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.IntegerDataType.typeCast(Object)" access="pub" jdoc="">
				<comm cntt="Bugfix in release 2.4.6"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.IntegerDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.IntegerDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.IDataTypeFactory" intfc="y" abs="n" inn="n" sloc="6" jdoc="A factory for creating {@link DataType}. @author Manuel Laflamme @since May 17, 2003 @version $Revision: 654 $">
			<mth name="/:org.dbunit.dataset.datatype.IDataTypeFactory.createDataType(int, String)" access="pub" jdoc="Returns the DataType object that corresponds to the specified{@link java.sql.Types}. @param sqlType SQL type from {@link java.sql.Types} @param sqlTypeName Data source dependent type name">
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.IDataTypeFactory.createDataType(int, String, String, String)" access="pub" jdoc="Returns the DataType object that corresponds to the specified{@link java.sql.Types} and regards the given tableName and columnName. When a {@link org.dbunit.dataset.datatype.ToleratedDeltaMap.ToleratedDelta} has been set for a tableName.columnName set then this method automatically creates the correct datatype that honours the tolerance value in the assertion. @param sqlType SQL type from {@link java.sql.Types} @param sqlTypeName Data source dependent type name @param tableName The database table for which the type is created @param columnName The database column in the given table for which the type is created @since 2.3.0">
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
				<param name="tableName"/>
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.DateDataType" intfc="n" abs="n" inn="n" sloc="79" jdoc="@author Manuel Laflamme @version $Revision: 709 $ @since Feb 19, 2002">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.DateDataType.DateDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DateDataType.typeCast(Object)" access="pub" jdoc="">
				<comm cntt="Probably a Timestamp, try it just in case!"/>
				<comm cntt="return java.sql.Date.valueOf(new java.sql.Date(time).toString());"/>
				<comm cntt="Was not a Timestamp, let java.sql.Date handle this value"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DateDataType.isDateTime()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DateDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DateDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.DataTypeException" intfc="n" abs="n" inn="n" sloc="19" jdoc="@author Manuel Laflamme @version $Revision: 441 $">
			<mth name="/:org.dbunit.dataset.datatype.DataTypeException.DataTypeException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataTypeException.DataTypeException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataTypeException.DataTypeException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataTypeException.DataTypeException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.NumberDataType" intfc="n" abs="n" inn="n" sloc="54" jdoc="@author Manuel Laflamme @version $Revision: 709 $ @since Feb 17, 2002">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="TRUE" access="priv" jdoc=""/>
			<const name="FALSE" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.datatype.NumberDataType.NumberDataType(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.NumberDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.NumberDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.NumberDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.UnknownDataType" intfc="n" abs="n" inn="n" sloc="26" jdoc="@author Manuel Laflamme @version $Revision: 844 $">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.UnknownDataType.UnknownDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.UnknownDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.UnknownDataType.compare(Object, Object)" access="pub" jdoc="">
				<comm cntt="New since dbunit 2.4 for performance optimization (avoid the &amp;quot;asString&amp;quot;)"/>
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.BigIntegerDataType" intfc="n" abs="n" inn="n" sloc="59" jdoc="Inserts and reads {@link BigInteger} values into from a database. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1032 $ $Date: 2009-09-14 04:15:47 -0300 (Seg, 14 Set 2009) $ @since 2.4.6">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.BigIntegerDataType.BigIntegerDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BigIntegerDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BigIntegerDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.BigIntegerDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.StringIgnoreCaseDataType" intfc="n" abs="n" inn="n" sloc="15" jdoc="String data type that ignore case when comparing String values. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 909 $ $Date: 2008-12-04 18:20:00 -0200 (Qui, 04 Dez 2008) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.StringIgnoreCaseDataType.StringIgnoreCaseDataType(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.StringIgnoreCaseDataType.compareNonNulls(Object, Object)" access="prot" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.DefaultDataTypeFactory" intfc="n" abs="n" inn="n" sloc="67" jdoc="Generic factory that handle standard JDBC types. @author Manuel Laflamme @since May 17, 2003 @version $Revision: 1031 $">
			<field name="_toleratedDeltaMap" access="priv" jdoc=""/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<mth name="/:org.dbunit.dataset.datatype.DefaultDataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DefaultDataTypeFactory.createDataType(int, String)" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDataTypeFactory#createDataType(int,java.lang.String)">
				<comm cntt="Necessary for compatibility with DbUnit 1.5 and older"/>
				<comm cntt="BLOB"/>
				<comm cntt="CLOB"/>
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DefaultDataTypeFactory.createDataType(int, String, String, String)" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDataTypeFactory#createDataType(int,java.lang.String,java.lang.String,java.lang.String)">
				<comm cntt="Check if the user has set a tolerance delta for this floating point field"/>
				<comm cntt="Found a toleratedDelta object"/>
				<comm cntt="Use a special data type to implement the tolerance for numbers (floating point things)"/>
				<comm cntt="In all other cases (default) use the default data type creation"/>
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
				<param name="tableName"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DefaultDataTypeFactory.getToleratedDeltaMap()" access="pub" jdoc="@return The whole map of tolerated delta objects that have been set until now @since 2.3.0">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DefaultDataTypeFactory.addToleratedDelta(ToleratedDelta)" access="pub" jdoc="Adds a tolerated delta to this data type factory to be used for numeric comparisons @param delta The new tolerated delta object @since 2.3.0">
				<param name="delta"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DefaultDataTypeFactory.toString()" access="pub" jdoc="Returns a string representation of this {@link DefaultDataTypeFactory} instance @since 2.4.6">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.DoubleDataType" intfc="n" abs="n" inn="n" sloc="48" jdoc="@author Manuel Laflamme @version $Revision: 709 $">
			<comm cntt=""/>
			<comm cntt="DataType methods"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.DoubleDataType.DoubleDataType(String, int)" access="pub" jdoc="">
				<param name="name"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DoubleDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DoubleDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DoubleDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap" intfc="n" abs="n" inn="n" sloc="50" jdoc="Container that manages a map of {@link ToleratedDelta} objects to be used for numeric comparisons with an allowed deviation of two values @author gommma @author Last changed by: $Author: gommma $ @version $Revision: 824 $ $Date: 2008-10-05 14:20:37 -0300 (Dom, 05 Out 2008) $ @since 2.3.0">
			<field name="_toleratedDeltas" access="priv" jdoc="List of {@link ToleratedDelta} objects"/>
			<field name="logger" access="priv" jdoc="The logger"/>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap.findToleratedDelta(String, String)" access="pub" jdoc="Lookup a tolerated delta object by tableName and ColumnName. @param tableName @param columnName @return The object from the map or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if no such object was found">
				<param name="tableName"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap.getToleratedDeltasNullSafe()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap.getToleratedDeltas()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap.addToleratedDelta(ToleratedDelta)" access="pub" jdoc="Adds a new object to the map of tolerated deltas @param delta The object to be added to the map">
				<comm cntt="Put the new object into the map"/>
				<comm cntt="Give a hint to the user when an already existing object has been overwritten replaced"/>
				<param name="delta"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap.buildMapKey(String, String)" access="pub" jdoc="Utility method to create a map key from the input parameters @param tableName @param columnName @return The key for the tolerated delta object map, consisting of the tableName and the columnName">
				<param name="tableName"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap.buildMapKey(ToleratedDelta)" access="pub" jdoc="Utility method to create a map key from the input parameters @param delta @return The key for the tolerated delta object map, consisting of the tableName and the columnName">
				<param name="delta"/>
			</mth>
		<class name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta" intfc="n" abs="n" inn="y" sloc="48" jdoc="Simple bean that holds the tolerance for floating point comparisons for a specific database column.">
			<field name="tableName" access="priv" jdoc=""/>
			<field name="columnName" access="priv" jdoc=""/>
			<field name="toleratedDelta" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.ToleratedDelta(String, String, double)" access="pub" jdoc="@param tableName The name of the table @param columnName The name of the column for which the tolerated delta should be applied @param toleratedDelta The tolerated delta. For example 1E-5 means that the comparison must match the first 5 decimal digits. All subsequent decimals are ignored.">
				<param name="tableName"/>
				<param name="columnName"/>
				<param name="toleratedDelta"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.ToleratedDelta(String, String, BigDecimal)" access="pub" jdoc="@param tableName The name of the table @param columnName The name of the column for which the tolerated delta should be applied @param toleratedDelta The tolerated delta. For example 1E-5 means that the comparison must match the first 5 decimal digits. All subsequent decimals are ignored.">
				<param name="tableName"/>
				<param name="columnName"/>
				<param name="toleratedDelta"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.ToleratedDelta(String, String, BigDecimal, boolean)" access="pub" jdoc="@param tableName The name of the table @param columnName The name of the column for which the tolerated delta should be applied @param toleratedDelta The tolerated delta. For example 1E-5 means that the comparison must match the first 5 decimal digits. All subsequent decimals are ignored. @param isPercentage Whether or not the given toleratedDelta value is a percentage. See {@link Precision} for more.">
				<param name="tableName"/>
				<param name="columnName"/>
				<param name="toleratedDelta"/>
				<param name="isPercentage"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.ToleratedDelta(String, String, Precision)" access="pub" jdoc="@param tableName The name of the table @param columnName The name of the column for which the tolerated delta should be applied @param toleratedDelta The tolerated delta. For example 1E-5 means that the comparison must match the first 5 decimal digits. All subsequent decimals are ignored.">
				<param name="tableName"/>
				<param name="columnName"/>
				<param name="toleratedDelta"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.getTableName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.getColumnName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.getToleratedDelta()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.matches(String, String)" access="pub" jdoc="Checks whether or not the &amp;lt;code&amp;gt;tableName&amp;lt; code&amp;gt; and the &amp;lt;code&amp;gt;columnName&amp;lt; code&amp;gt; match the ones of this object. @param tableName @param columnName @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if both given values match those of this object.">
				<param name="tableName"/>
				<param name="columnName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$ToleratedDelta.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$Precision" intfc="n" abs="n" inn="y" sloc="23" jdoc="Container for the tolerated delta of two values that are compared to each other. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 824 $ $Date: 2008-10-05 14:20:37 -0300 (Dom, 05 Out 2008) $ @since 2.4.0">
			<const name="ZERO" access="priv" jdoc=""/>
			<field name="percentage" access="priv" jdoc=""/>
			<field name="delta" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$Precision.Precision(BigDecimal)" access="pub" jdoc="@param delta The allowed tolerated difference">
				<param name="delta"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$Precision.Precision(BigDecimal, boolean)" access="pub" jdoc="@param delta The allowed tolerated difference @param percentage Whether or not the given &amp;lt;code&amp;gt;delta&amp;lt; code&amp;gt; should be interpreted as percentage or not during the comparison">
				<param name="delta"/>
				<param name="percentage"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$Precision.isPercentage()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.ToleratedDeltaMap$Precision.getDelta()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.datatype.DataType" intfc="n" abs="y" inn="n" sloc="111" jdoc="Data type that maps {@link java.sql.Types} objects to their java counterparts. It also provides immutable constants for the most common data types. @see &amp;lt;a href=&amp;quot;http: java.sun.com j2se 1.3 docs guide jdbc getstart mapping.html#table1&amp;quot;&amp;gt;sun JDBC object mapping&amp;lt; a&amp;gt; @author Manuel Laflamme @version $Revision: 1194 $">
			<comm cntt="public static final DataType BIGINT = new LongDataType();"/>
			<comm cntt="New JDBC 4.0 types:"/>
			<comm cntt="todo: ROWID = -8, NCLOB = 2011, SQLXML = 2009."/>
			<comm cntt="auxiliary types at the very end"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="UNKNOWN" access="pub" jdoc=""/>
			<const name="CHAR" access="pub" jdoc=""/>
			<const name="VARCHAR" access="pub" jdoc=""/>
			<const name="LONGVARCHAR" access="pub" jdoc=""/>
			<const name="CLOB" access="pub" jdoc=""/>
			<const name="NUMERIC" access="pub" jdoc=""/>
			<const name="DECIMAL" access="pub" jdoc=""/>
			<const name="BOOLEAN" access="pub" jdoc=""/>
			<const name="BIT" access="pub" jdoc=""/>
			<const name="TINYINT" access="pub" jdoc=""/>
			<const name="SMALLINT" access="pub" jdoc=""/>
			<const name="INTEGER" access="pub" jdoc=""/>
			<const name="BIGINT" access="pub" jdoc=""/>
			<const name="BIGINT_AUX_LONG" access="pub" jdoc="Auxiliary for the BIGINT type using a long. Is currently only needed for method {@link DataType#forObject(Object)}."/>
			<const name="REAL" access="pub" jdoc=""/>
			<const name="FLOAT" access="pub" jdoc=""/>
			<const name="DOUBLE" access="pub" jdoc=""/>
			<const name="DATE" access="pub" jdoc=""/>
			<const name="TIME" access="pub" jdoc=""/>
			<const name="TIMESTAMP" access="pub" jdoc=""/>
			<const name="BINARY" access="pub" jdoc=""/>
			<const name="VARBINARY" access="pub" jdoc=""/>
			<const name="LONGVARBINARY" access="pub" jdoc=""/>
			<const name="BLOB" access="pub" jdoc=""/>
			<const name="NCHAR" access="pub" jdoc=""/>
			<const name="NVARCHAR" access="pub" jdoc=""/>
			<const name="LONGNVARCHAR" access="pub" jdoc=""/>
			<const name="TYPES" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.datatype.DataType.typeCast(Object)" access="pub" jdoc="Returns the specified value typecasted to this &amp;lt;code&amp;gt;DataType&amp;lt; code&amp;gt;">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.compare(Object, Object)" access="pub" jdoc="Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. &amp;lt;p&amp;gt; The two values are typecast to this DataType before being compared. @throws TypeCastException if the arguments&amp;apos; types prevent them from being compared by this Comparator.">
				<param name="o1"/>
				<param name="o2"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.getSqlType()" access="pub" jdoc="Returns the corresponding {@link java.sql.Types}.">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.getTypeClass()" access="pub" jdoc="Returns the runtime class of the typecast result.">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.isNumber()" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if this &amp;lt;code&amp;gt;DataType&amp;lt; code&amp;gt; represents a number.">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.isDateTime()" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if this &amp;lt;code&amp;gt;DataType&amp;lt; code&amp;gt; represents a date and or time.">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.getSqlValue(int, ResultSet)" access="pub" jdoc="Returns the specified column value from the specified resultset object.">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="Set the specified value to the specified prepared statement object.">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.asString(Object)" access="pub" jdoc="Typecast the specified value to string.">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.forSqlType(int)" access="pub" jdoc="Returns the &amp;lt;code&amp;gt;DataType&amp;lt; code&amp;gt; corresponding to the specified Sql type. See {@link java.sql.Types}.">
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.forSqlTypeName(String)" access="pub" jdoc="Returns the &amp;lt;code&amp;gt;DataType&amp;lt; code&amp;gt; corresponding to the specified Sql type name. @deprecated Should not be used anymore">
				<param name="sqlTypeName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.DataType.forObject(Object)" access="pub" jdoc="Returns the &amp;lt;code&amp;gt;DataType&amp;lt; code&amp;gt; corresponding to the specified value runtime class. This method returns &amp;lt;code&amp;gt;DataType.UNKNOWN&amp;lt; code&amp;gt; if the value is &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; or runtime class not recognized.">
				<param name="value"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.LongDataType" intfc="n" abs="n" inn="n" sloc="48" jdoc="@author Manuel Laflamme @version $Revision: 709 $">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.LongDataType.LongDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.LongDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.LongDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.LongDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.FloatDataType" intfc="n" abs="n" inn="n" sloc="48" jdoc="@author Manuel Laflamme @version $Revision: 709 $">
			<comm cntt=""/>
			<comm cntt="DataType class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.datatype.FloatDataType.FloatDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.FloatDataType.typeCast(Object)" access="pub" jdoc="">
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.FloatDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.FloatDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.datatype.TypeCastException" intfc="n" abs="n" inn="n" sloc="25" jdoc="@author Manuel Laflamme @version $Revision: 706 $">
			<comm cntt="public TypeCastException()"/>
			<comm cntt="{"/>
			<comm cntt="super();"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="public TypeCastException(String msg)"/>
			<comm cntt="{"/>
			<comm cntt="super(msg);"/>
			<comm cntt="}"/>
			<mth name="/:org.dbunit.dataset.datatype.TypeCastException.TypeCastException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TypeCastException.TypeCastException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TypeCastException.TypeCastException(Object, DataType)" access="pub" jdoc="">
				<param name="value"/>
				<param name="dataType"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TypeCastException.TypeCastException(Object, DataType, Throwable)" access="pub" jdoc="">
				<param name="value"/>
				<param name="dataType"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.datatype.TypeCastException.buildMessage(Object, DataType)" access="priv" jdoc="">
				<param name="value"/>
				<param name="dataType"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.excel">
		<class name="/:org.dbunit.dataset.excel.XlsDataSet" intfc="n" abs="n" inn="n" sloc="35" jdoc="This dataset implementation can read and write MS Excel documents. Each sheet represents a table. The first row of a sheet defines the columns names and remaining rows contains the data. @author Manuel Laflamme @since Feb 21, 2003 @version $Revision: 875 $">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tables" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSet.XlsDataSet(File)" access="pub" jdoc="Creates a new XlsDataSet object that loads the specified Excel document.">
				<param name="file"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSet.XlsDataSet(InputStream)" access="pub" jdoc="Creates a new XlsDataSet object that loads the specified Excel document.">
				<param name="in"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSet.write(IDataSet, OutputStream)" access="pub" jdoc="Write the specified dataset to the specified Excel document.">
				<param name="dataSet"/>
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.excel.XlsDataSetWriter" intfc="n" abs="n" inn="n" sloc="98" jdoc="Writes an {@link IDataSet} to an XLS file or OutputStream. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 915 $ $Date: 2008-12-07 11:17:25 -0200 (Dom, 07 Dez 2008) $ @since 2.4.0">
			<comm cntt="public static Date get1900(Date date) {"/>
			<comm cntt="Calendar cal = Calendar.getInstance();"/>
			<comm cntt="cal.setTimeInMillis(date.getTime() % (24 60 60 1000));"/>
			<comm cntt="cal.set(1900, 0, 1); 1.1.1900"/>
			<comm cntt="return cal.getTime();"/>
			<comm cntt="}"/>
			<comm cntt=""/>
			<comm cntt="public static Calendar get1900Cal(Date date) {"/>
			<comm cntt="Calendar cal = Calendar.getInstance();"/>
			<comm cntt="cal.clear();"/>
			<comm cntt="long hoursInMillis = date.getTime() % (24 60 60 1000);"/>
			<comm cntt="long smallerThanDays = date.getTime() % (24 60 60 1000);"/>
			<comm cntt="cal.setTimeInMillis(date.getTime() % (24 60 60 1000));"/>
			<comm cntt="cal.set(Calendar.SECOND, (int) (date.getTime() % (24 60 60 1000)) (1000) );"/>
			<comm cntt="cal.set(Calendar.MINUTE, (int) (date.getTime() % (24 60 60 1000)) (1000 60) );"/>
			<comm cntt="cal.set(Calendar.HOUR, (int) (date.getTime() % (24 60 60 1000)) (1000 60 60) );"/>
			<comm cntt="cal.set(1900, 0, 1); 1.1.1900"/>
			<comm cntt="System.out.println(cal.isSet(Calendar.DATE));"/>
			<comm cntt="return cal;"/>
			<comm cntt="}"/>
			<const name="ZEROS" access="pub" jdoc=""/>
			<const name="DATE_FORMAT_AS_NUMBER_DBUNIT" access="pub" jdoc="A special format pattern used to create a custom {@link HSSFDataFormat} which marks {@link Date} values that are stored via POI to an XLS file. Note that it might produce problems if a normal numeric value uses this format pattern incidentally."/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="dateCellStyle" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSetWriter.write(IDataSet, OutputStream)" access="pub" jdoc="Write the specified dataset to the specified Excel document.">
				<comm cntt="create the table i.e. sheet"/>
				<comm cntt="write table metadata i.e. first row in sheet"/>
				<comm cntt="write table data"/>
				<comm cntt="write xls document"/>
				<param name="dataSet"/>
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSetWriter.createDateCellStyle(HSSFWorkbook)" access="prot" jdoc="">
				<param name="workbook"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSetWriter.setDateCell(HSSFCell, Date, HSSFWorkbook)" access="prot" jdoc="">
				<comm cntt="double excelDateValue = HSSFDateUtil.getExcelDate(value);"/>
				<comm cntt="cell.setCellValue(excelDateValue);"/>
				<comm cntt="cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC);"/>
				<comm cntt="System.out.println(HSSFDataFormat.getBuiltinFormats());"/>
				<comm cntt="TODO Find out correct cell styles for date objects"/>
				<comm cntt="HSSFCellStyle cellStyleDate = workbook.createCellStyle();"/>
				<comm cntt="cellStyleDate.setDataFormat(HSSFDataFormat.getBuiltinFormat(&amp;quot;m d yy h:mm&amp;quot;));"/>
				<comm cntt=""/>
				<comm cntt="HSSFCellStyle cellStyleDateTimeWithSeconds = workbook.createCellStyle();"/>
				<comm cntt="cellStyleDateTimeWithSeconds.setDataFormat(HSSFDataFormat.getBuiltinFormat(&amp;quot;h:mm:ss&amp;quot;));"/>
				<comm cntt=""/>
				<comm cntt="HSSFDataFormat dataFormat = workbook.createDataFormat();"/>
				<comm cntt="HSSFCellStyle cellStyle = workbook.createCellStyle();"/>
				<comm cntt="cellStyle.setDataFormat(dataFormat.getFormat(&amp;quot;dd mm yyyy hh:mm:ss&amp;quot;));"/>
				<comm cntt=""/>
				<comm cntt="SimpleDateFormat formatter = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss.SSS&amp;quot;);"/>
				<comm cntt="SimpleDateFormat formatter2 = new SimpleDateFormat(&amp;quot;dd MM yyyy&amp;quot;);"/>
				<comm cntt="SimpleDateFormat formatter3 = new SimpleDateFormat(&amp;quot;HH:mm:ss.SSS&amp;quot;);"/>
				<comm cntt=""/>
				<comm cntt=""/>
				<comm cntt="Date dateValue = (Date)value;"/>
				<comm cntt="Calendar cal = null;"/>
				<comm cntt=""/>
				<comm cntt="If it is a date value that does not have seconds"/>
				<comm cntt="if(dateValue.getTime() % 60000 == 0){"/>
				<comm cntt="cellStyle = cellStyleDate;"/>
				<comm cntt="cal=Calendar.getInstance();"/>
				<comm cntt="cal.setTimeInMillis(dateValue.getTime());"/>
				<comm cntt=""/>
				<comm cntt="cell.setCellValue(cal);"/>
				<comm cntt="cell.setCellStyle(cellStyle);"/>
				<comm cntt="cell.setCellValue(cal);"/>
				<comm cntt="}"/>
				<comm cntt="else {"/>
				<comm cntt="HSSFDataFormatter formatter = new HSSFDataFormatter();"/>
				<comm cntt=""/>
				<comm cntt="If we have seconds assume that it is only h:mm:ss without date"/>
				<comm cntt="TODO Clean implementation where user can control date formats would be nice"/>
				<comm cntt="double dateDouble = dateValue.getTime() % (24 60 60 1000);"/>
				<comm cntt="cal = get1900Cal(dateValue);"/>
				<comm cntt=""/>
				<comm cntt="String formatted = formatter3.format(dateValue);"/>
				<comm cntt="TODO Format ..."/>
				<comm cntt="cellStyle = cellStyleDateTimeWithSeconds;"/>
				<comm cntt="System.out.println(&amp;quot;date formatted:&amp;quot;+formatted);"/>
				<comm cntt="HSSFRichTextString s = new HSSFRichTextString(formatted);"/>
				<comm cntt="cell.setCellValue(s);"/>
				<comm cntt="cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC);"/>
				<comm cntt="cell.setCellValue((double)dateValue.getTime());"/>
				<comm cntt="cell.setCellStyle(cellStyleDateTimeWithSeconds);"/>
				<comm cntt="}"/>
				<param name="cell"/>
				<param name="value"/>
				<param name="workbook"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSetWriter.setNumericCell(HSSFCell, BigDecimal, HSSFWorkbook)" access="prot" jdoc="">
				<param name="cell"/>
				<param name="value"/>
				<param name="workbook"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsDataSetWriter.createZeros(int)" access="priv" jdoc="">
				<param name="count"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.excel.XlsTable" intfc="n" abs="n" inn="n" sloc="183" jdoc="@author Manuel Laflamme @author Last changed by: $Author: jbhurst $ @version $Revision: 1148 $ $Date: 2010-01-23 20:17:13 -0200 (SÃ¡b, 23 Jan 2010) $ @since Feb 21, 2003">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_metaData" access="priv" jdoc=""/>
			<const name="_sheet" access="priv" jdoc=""/>
			<const name="symbols" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.XlsTable(String, HSSFSheet)" access="pub" jdoc="">
				<comm cntt="Needed for later &amp;quot;BigDecimal&amp;quot; &amp;quot;Number&amp;quot; conversion"/>
				<param name="sheetName"/>
				<param name="sheet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.createMetaData(String, HSSFRow)" access="pub" jdoc="">
				<comm cntt="Bugfix for issue ID 2818981 - if a cell has a formatting but no name also ignore it"/>
				<param name="tableName"/>
				<param name="sampleRow"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.getValue(int, String)" access="pub" jdoc="">
				<comm cntt="The special dbunit date format"/>
				<param name="row"/>
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.getDateValueFromJavaNumber(HSSFCell)" access="prot" jdoc="">
				<comm cntt="return new Long(numericValueBd.unscaledValue().longValue());"/>
				<param name="cell"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.getDateValue(HSSFCell)" access="prot" jdoc="">
				<comm cntt="Add the timezone offset again because it was subtracted automatically by Apache-POI (we need UTC)"/>
				<comm cntt="TODO use a calendar for XLS Date objects when it is supported better by POI"/>
				<comm cntt="HSSFCellStyle style = cell.getCellStyle();"/>
				<comm cntt="HSSFDataFormatter formatter = new HSSFDataFormatter();"/>
				<comm cntt="Format f = formatter.createFormat(cell);"/>
				<comm cntt="String formatted = fomatter.formatCellValue(cell);"/>
				<comm cntt="System.out.println(&amp;quot;###&amp;quot;+formatted);"/>
				<comm cntt="Date dateValue = cell.getDateCellValue();"/>
				<param name="cell"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.stripTrailingZeros(BigDecimal)" access="priv" jdoc="Removes all trailing zeros from the end of the given BigDecimal value up to the decimal point. @param value The value to be stripped @return The value without trailing zeros">
				<comm cntt="Stop when decimal point is reached"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.getNumericValue(HSSFCell)" access="prot" jdoc="">
				<comm cntt="Probably was not a BigDecimal format retrieved from the excel. Some"/>
				<comm cntt="date formats are not yet recognized by HSSF as DateFormats so that"/>
				<comm cntt="we could get here."/>
				<param name="cell"/>
			</mth>
			<mth name="/:org.dbunit.dataset.excel.XlsTable.toBigDecimal(double)" access="priv" jdoc="@param cellValue @return @since 2.4.6">
				<comm cntt="To ensure that intergral numbers do not have decimal point and trailing zero"/>
				<comm cntt="(to restore backward compatibility and provide a string representation consistent with Excel)"/>
				<param name="cellValue"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.filter">
		<class name="/:org.dbunit.dataset.filter.DefaultTableFilter" intfc="n" abs="n" inn="n" sloc="25" jdoc="This filter exposes only tables matching include patterns and not matching exclude patterns. This implementation do not modify the original table sequence from the filtered dataset and support duplicate table names. @author Manuel Laflamme @since Apr 17, 2004 @version $Revision: 554 $">
			<comm cntt=""/>
			<comm cntt="AbstractTableFilter interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_includeFilter" access="priv" jdoc=""/>
			<const name="_excludeFilter" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.DefaultTableFilter.includeTable(String)" access="pub" jdoc="Add a new accepted table name pattern. The following wildcard characters are supported: &amp;apos; &amp;apos; matches zero or more characters, &amp;apos;?&amp;apos; matches one character.">
				<param name="patternName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultTableFilter.excludeTable(String)" access="pub" jdoc="Add a new refused table pattern name. The following wildcard characters are supported: &amp;apos; &amp;apos; matches zero or more characters, &amp;apos;?&amp;apos; matches one character.">
				<param name="patternName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultTableFilter.isValidName(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.IColumnFilter" intfc="y" abs="n" inn="n" sloc="4" jdoc="A filter for database columns. &amp;lt;p&amp;gt; Instances of this interface may be passed to the &amp;lt;code&amp;gt;{@link org.dbunit.dataset.FilteredTableMetaData#FilteredTableMetaData(org.dbunit.dataset.ITableMetaData,IColumnFilter)}&amp;lt; code&amp;gt; method of the &amp;lt;code&amp;gt;{@link org.dbunit.dataset.FilteredTableMetaData}&amp;lt; code&amp;gt; class. @author Manuel Laflamme @since Apr 17, 2004 @version $Revision: 741 $">
			<mth name="/:org.dbunit.dataset.filter.IColumnFilter.accept(String, Column)" access="pub" jdoc="Tests whether or not the specified column of the specified tableName should be included by this filter. @param tableName The tableName to be tested @param column The column to be tested @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if and only if the given parameter set should be included">
				<param name="tableName"/>
				<param name="column"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.IRowFilter" intfc="y" abs="n" inn="n" sloc="3" jdoc="Interface to filter out rows by checking specific column values provided by the {@link IRowValueProvider}. @author gommma @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since 2.3.0">
			<mth name="/:org.dbunit.dataset.filter.IRowFilter.accept(IRowValueProvider)" access="pub" jdoc="Checks if the current row should be accepted or not @param rowValueProvider provides arbitrary column values of the current row to be checked. @return True if the given value (and so that current row) should be accepted">
				<param name="rowValueProvider"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.ExcludeTableFilter" intfc="n" abs="n" inn="n" sloc="31" jdoc="This filter hides specified tables from the filtered dataset. This implementation do not modify the original table order from the filtered dataset and support duplicate table names. @author Manuel Laflamme @since Mar 7, 2003 @version $Revision: 554 $">
			<comm cntt=""/>
			<comm cntt="ITableFilter interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_patternMatcher" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.ExcludeTableFilter.ExcludeTableFilter()" access="pub" jdoc="Create a new empty ExcludeTableFilter. Use {@link #excludeTable} to hide some tables.">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.ExcludeTableFilter.ExcludeTableFilter(String[])" access="pub" jdoc="Create a new ExcludeTableFilter which prevent access to specified tables.">
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.ExcludeTableFilter.excludeTable(String)" access="pub" jdoc="Add a new refused table pattern name. The following wildcard characters are supported: &amp;apos; &amp;apos; matches zero or more characters, &amp;apos;?&amp;apos; matches one character.">
				<param name="patternName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.ExcludeTableFilter.isEmpty()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.ExcludeTableFilter.isValidName(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.ITableFilterSimple" intfc="y" abs="n" inn="n" sloc="4" jdoc="A filter for table names. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 942 $ $Date: 2009-01-17 19:40:51 -0200 (SÃ¡b, 17 Jan 2009) $ @since 2.4.3">
			<mth name="/:org.dbunit.dataset.filter.ITableFilterSimple.accept(String)" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if specified table is allowed by this filter.">
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.IncludeTableFilter" intfc="n" abs="n" inn="n" sloc="31" jdoc="This filter exposes only allowed tables from the filtered dataset. This implementation do not modify the original table sequence from the filtered dataset and support duplicate table names. @author Manuel Laflamme @since Mar 7, 2003 @version $Revision: 942 $">
			<comm cntt=""/>
			<comm cntt="ITableFilter interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_patternMatcher" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.IncludeTableFilter.IncludeTableFilter()" access="pub" jdoc="Create a new empty IncludeTableFilter. Use {@link #includeTable} to allow access to some tables.">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.IncludeTableFilter.IncludeTableFilter(String[])" access="pub" jdoc="Create a new IncludeTableFilter which allow access to specified tables.">
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.IncludeTableFilter.includeTable(String)" access="pub" jdoc="Add a new accepted table name pattern. The following wildcard characters are supported: &amp;apos; &amp;apos; matches zero or more characters, &amp;apos;?&amp;apos; matches one character.">
				<param name="patternName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.IncludeTableFilter.isEmpty()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.IncludeTableFilter.isValidName(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.SequenceTableFilter" intfc="n" abs="n" inn="n" sloc="60" jdoc="This filter expose a specified table sequence and can be used to reorder tables in a dataset. This implementation does not support duplicate table names. Thus you cannot specify the same table name more than once in this filter and the filtered dataset must not contains duplicate table names. This is the default filter used by the {@link org.dbunit.dataset.FilteredDataSet}. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1049 $ $Date: 2009-09-27 17:59:22 -0300 (Dom, 27 Set 2009) $ @since Mar 7, 2003">
			<comm cntt=""/>
			<comm cntt="ITableFilter interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tableNameMap" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableFilter.SequenceTableFilter(String[])" access="pub" jdoc="Creates a new SequenceTableFilter with specified table names sequence. @throws AmbiguousTableNameException If the given array contains ambiguous names">
				<param name="tableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableFilter.SequenceTableFilter(String[], boolean)" access="pub" jdoc="Creates a new SequenceTableFilter with specified table names sequence. @param tableNames @param caseSensitiveTableNames @throws AmbiguousTableNameException If the given array contains ambiguous names @since 2.4.2">
				<comm cntt="Gather all tables in the OrderedTableNameMap which also makes the duplicate check"/>
				<param name="tableNames"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableFilter.accept(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableFilter.getTableNames(IDataSet)" access="pub" jdoc="">
				<comm cntt="Use the table name from the filtered dataset. This ensure"/>
				<comm cntt="that table names are having the same case (lower upper) from"/>
				<comm cntt="getTableNames() and getTables() methods."/>
				<comm cntt="Skip this table name because the filtered dataset does not"/>
				<comm cntt="contains it."/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableFilter.iterator(IDataSet, boolean)" access="pub" jdoc="">
				<param name="dataSet"/>
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableFilter.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.ITableFilter" intfc="y" abs="n" inn="n" sloc="6" jdoc="Represents a strategy used by {@link org.dbunit.dataset.FilteredDataSet} to exposes only some tables from a dataset. @author Manuel Laflamme @since Mar 7, 2003 @version $Revision: 942 $">
			<mth name="/:org.dbunit.dataset.filter.ITableFilter.getTableNames(IDataSet)" access="pub" jdoc="Returns the table names allowed by this filter from the specified dataset. @param dataSet the filtered dataset">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.ITableFilter.iterator(IDataSet, boolean)" access="pub" jdoc="Returns iterator of tables allowed by this filter from the specified dataset. @param dataSet the filtered dataset">
				<param name="dataSet"/>
				<param name="reversed"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.SequenceTableIterator" intfc="n" abs="n" inn="n" sloc="28" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 767 $ $Date: 2008-08-01 09:26:47 -0300 (Sex, 01 Ago 2008) $ @since Apr 6, 2003">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_tableNames" access="priv" jdoc=""/>
			<const name="_dataSet" access="priv" jdoc=""/>
			<field name="_index" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableIterator.SequenceTableIterator(String[], IDataSet)" access="pub" jdoc="">
				<param name="tableNames"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.SequenceTableIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.DefaultColumnFilter" intfc="n" abs="n" inn="n" sloc="91" jdoc="Implementation of the IColumnFilter interface that exposes columns matching include patterns and not matching exclude patterns. @author Manuel Laflamme @since Apr 17, 2004 @version $Revision: 850 $">
			<comm cntt=""/>
			<comm cntt="IColumnFilter interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_includeMatcher" access="priv" jdoc=""/>
			<const name="_excludeMatcher" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.includeColumn(String)" access="pub" jdoc="Add a new accepted column name pattern for all tables. The following wildcard characters are supported: &amp;apos; &amp;apos; matches zero or more characters, &amp;apos;?&amp;apos; matches one character. @param columnPattern The column pattern to be supported">
				<param name="columnPattern"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.includeColumns(Column[])" access="pub" jdoc="Add specified columns to accepted column name list.">
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.excludeColumn(String)" access="pub" jdoc="Add a new refused column name pattern for all tables. The following wildcard characters are supported: &amp;apos; &amp;apos; matches zero or more characters, &amp;apos;?&amp;apos; matches one character.">
				<param name="columnPattern"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.excludeColumns(Column[])" access="pub" jdoc="Add specified columns to excluded column name list.">
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.includedColumnsTable(ITable, String[])" access="pub" jdoc="Returns a table backed by the specified table that only exposes specified columns.">
				<param name="table"/>
				<param name="columnNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.includedColumnsTable(ITable, Column[])" access="pub" jdoc="Returns a table backed by the specified table that only exposes specified columns.">
				<param name="table"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.excludedColumnsTable(ITable, String[])" access="pub" jdoc="Returns a table backed by the specified table but with specified columns excluded.">
				<param name="table"/>
				<param name="columnNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.excludedColumnsTable(ITable, Column[])" access="pub" jdoc="Returns a table backed by the specified table but with specified columns excluded.">
				<param name="table"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.accept(String, Column)" access="pub" jdoc="">
				<param name="tableName"/>
				<param name="column"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.DefaultColumnFilter.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.filter.AbstractTableFilter" intfc="n" abs="y" inn="n" sloc="32" jdoc="This class provides a skeletal implementation of the {@link ITableFilter}interface to minimize the effort required to implement a filter. Subclasses are only required to implement the {@link #isValidName} method. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 956 $ $Date: 2009-02-07 16:59:55 -0200 (SÃ¡b, 07 Fev 2009) $ @since 2.2.0">
			<comm cntt=""/>
			<comm cntt="ITableFilter interface"/>
			<comm cntt=""/>
			<comm cntt="FilterIterator class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter.isValidName(String)" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if specified table is allowed by this filter. This legacy method, now replaced by accept, still exist for compatibily with older environment">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter.accept(String)" access="pub" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter.getTableNames(IDataSet)" access="pub" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter.iterator(IDataSet, boolean)" access="pub" jdoc="">
				<param name="dataSet"/>
				<param name="reversed"/>
			</mth>
		<class name="/:org.dbunit.dataset.filter.AbstractTableFilter$FilterIterator" intfc="n" abs="n" inn="y" sloc="31" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_iterator" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter$FilterIterator.FilterIterator(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter$FilterIterator.next()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter$FilterIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.AbstractTableFilter$FilterIterator.getTable()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.filter.PatternMatcher" intfc="n" abs="n" inn="n" sloc="218" jdoc="@author Manuel Laflamme @since Apr 17, 2004 @version $Revision: 699 $">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_acceptedNames" access="priv" jdoc=""/>
			<const name="_acceptedPatterns" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.filter.PatternMatcher.addPattern(String)" access="pub" jdoc="Add a new accepted pattern. The following wildcard characters are supported: &amp;apos; &amp;apos; matches zero or more characters, &amp;apos;?&amp;apos; matches one character.">
				<param name="patternName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.PatternMatcher.isEmpty()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.filter.PatternMatcher.accept(String)" access="pub" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.PatternMatcher.match(String, String, boolean)" access="priv" jdoc="Matches a string against a pattern. The pattern contains two special characters: &amp;apos; &amp;apos; which means zero or more characters, &amp;apos;?&amp;apos; which means one and only one character. @param pattern the (non-null) pattern to match against @param str the (non-null) string that must be matched against the pattern @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; when the string matches against the pattern, &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; otherwise.">
				<comm cntt="Following pattern matching code taken from the Apache Ant project."/>
				<comm cntt="No &amp;apos; &amp;apos;s, so we make a shortcut"/>
				<comm cntt="Pattern and string do not have the same size"/>
				<comm cntt="Character mismatch"/>
				<comm cntt="Character mismatch"/>
				<comm cntt="String matches against pattern"/>
				<comm cntt="Pattern contains only &amp;apos; &amp;apos;, which matches anything"/>
				<comm cntt="Process characters before first star"/>
				<comm cntt="Character mismatch"/>
				<comm cntt="Character mismatch"/>
				<comm cntt="All characters in the string are used. Check if only &amp;apos; &amp;apos;s are"/>
				<comm cntt="left in the pattern. If so, we succeeded. Otherwise failure."/>
				<comm cntt="Process characters after last star"/>
				<comm cntt="Character mismatch"/>
				<comm cntt="Character mismatch"/>
				<comm cntt="All characters in the string are used. Check if only &amp;apos; &amp;apos;s are"/>
				<comm cntt="left in the pattern. If so, we succeeded. Otherwise failure."/>
				<comm cntt="process pattern between stars. padIdxStart and patIdxEnd point"/>
				<comm cntt="always to a &amp;apos; &amp;apos;."/>
				<comm cntt="Two stars next to each other, skip the first one."/>
				<comm cntt="Find the pattern between padIdxStart &amp; padIdxTmp in str between"/>
				<comm cntt="strIdxStart &amp; strIdxEnd"/>
				<comm cntt="All characters in the string are used. Check if only &amp;apos; &amp;apos;s are left"/>
				<comm cntt="in the pattern. If so, we succeeded. Otherwise failure."/>
				<param name="pattern"/>
				<param name="str"/>
				<param name="isCaseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.dataset.filter.PatternMatcher.toString()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.sqlloader">
		<class name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl" intfc="n" abs="n" inn="n" sloc="207" jdoc="Parser which parses Oracle SQLLoader files. @author Stephan Strittmatter (stritti AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 819 $ $Date: 2008-09-29 18:10:49 -0300 (Seg, 29 Set 2008) $ @since 2.4.0">
			<comm cntt="private String fieldTerminator;"/>
			<comm cntt=""/>
			<comm cntt="private String fieldEnclosure;"/>
			<const name="SEPARATOR_CHAR" access="pub" jdoc=""/>
			<field name="pipeline" access="priv" jdoc="The pipeline."/>
			<field name="tableName" access="priv" jdoc=""/>
			<field name="hasTrailingNullCols" access="priv" jdoc=""/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.SqlLoaderControlParserImpl()" access="pub" jdoc="The Constructor.">
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.resetThePipeline()" access="priv" jdoc="Reset the pipeline.">
				<comm cntt="TODO add this.fieldEnclosure"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.parse(String)" access="pub" jdoc="Parse. @param csv the csv @return the list @throws IllegalInputCharacterException the illegal input character exception @throws PipelineException the pipeline exception @see org.dbunit.dataset.sqlloader.SqlLoaderControlParser#parse(java.lang.String)">
				<param name="csv"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.parse(URL)" access="pub" jdoc="Parse. @param url the URL @return the list @throws IOException the IO exception @throws SqlLoaderControlParserException the oracle control parser exception @see org.dbunit.dataset.sqlloader.SqlLoaderControlParser#parse(java.net.URL)">
				<param name="url"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.parse(File)" access="pub" jdoc="Parse. @param controlFile the source @return the list of column names as Strings @throws IOException the IO exception @throws SqlLoaderControlParserException the oracle control parser exception @see org.dbunit.dataset.sqlloader.SqlLoaderControlParser#parse(java.io.File)">
				<comm cntt="one big string"/>
				<comm cntt="unify to UNIX style to have easier regexp transformations."/>
				<comm cntt="this.fieldTerminator = parseForRegexp(lines, &amp;quot;. TERMINATED BY [\&amp;quot;|&amp;apos;](. ?)[\&amp;quot;|&amp;apos;]. &amp;quot;);"/>
				<comm cntt=""/>
				<comm cntt="this.fieldEnclosure = parseForRegexp(lines, &amp;quot;. OPTIONALLY ENCLOSED BY &amp;apos;(. ?)&amp;apos;. &amp;quot;);"/>
				<param name="controlFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.resolveFile(File, String)" access="priv" jdoc="">
				<comm cntt="Initially assume that we have an absolute fileName"/>
				<comm cntt="If fileName was not absolute build it using the given parent"/>
				<comm cntt="remove &amp;quot;. &amp;quot; characters from name at the beginning if needed"/>
				<comm cntt="remove &amp;quot;.&amp;quot; character from name at the beginning if needed"/>
				<param name="parentDir"/>
				<param name="fileName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.parseForRegexp(String, String)" access="prot" jdoc="">
				<param name="controlFileContent"/>
				<param name="regexp"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.parseColumns(String, List)" access="priv" jdoc="parse the first line of data from the given source. @param rows the rows @param lineNumberReader the line number reader @param controlFile the source @return the list of column names as Strings @throws IOException the IO exception @throws SqlLoaderControlParserException the oracle control parser exception">
				<comm cntt="firstLine = firstLine.replaceAll(&amp;quot;(\n|\r)&amp;quot;, &amp;quot;&amp;quot;);"/>
				<comm cntt="column is the first part."/>
				<comm cntt="columnsInFirstLine = parse(firstLine);"/>
				<param name="controlFileContent"/>
				<param name="rows"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.parseTheData(List, LineNumberReader, List)" access="priv" jdoc="Parses the the data. @param rows the rows @param columnList the columns in first line @param lineNumberReader the line number reader @throws IOException the IO exception @throws SqlLoaderControlParserException the oracle control parser exception">
				<param name="columnList"/>
				<param name="lineNumberReader"/>
				<param name="rows"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.collectExpectedNumberOfColumns(int, LineNumberReader)" access="priv" jdoc="Collect expected number of columns. @param expectedNumberOfColumns the expected number of columns @param lineNumberReader the line number reader @return the list @throws IOException the IO exception @throws SqlLoaderControlParserException the oracle control parser exception">
				<param name="expectedNumberOfColumns"/>
				<param name="lineNumberReader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.getPipeline()" access="pub" jdoc="Gets the pipeline. @return the pipeline">
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.setPipeline(Pipeline)" access="pub" jdoc="Sets the pipeline. @param pipeline the pipeline">
				<param name="pipeline"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserImpl.getTableName()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlDataSet" intfc="n" abs="n" inn="n" sloc="17" jdoc="This class constructs an {@link IDataSet} given a directory containing control files. It handles translations of &amp;quot;null&amp;quot;(the string), into null. &amp;lt;p&amp;gt; Example usage: &amp;lt;code&amp;gt;&amp;lt;pre&amp;gt; File ctlDir = new File(&amp;quot;src sqlloader&amp;quot;); File orderedTablesFile = new File(&amp;quot;src sqlloader tables.lst&amp;quot;); IDataSet dataSet = new SqlLoaderControlDataSet(ctlDir, orderedTablesFile); &amp;lt; pre&amp;gt;&amp;lt; code&amp;gt; The file &amp;lt;code&amp;gt;orderedTablesFile&amp;lt; code&amp;gt; must contain the names of the tables to be imported. As a convention the .ctl file must have the same name as the table names file. Here an example of the &amp;quot;tables.lst&amp;quot; file: &amp;lt;br&amp;gt; &amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;LANGUAGE&amp;lt;br&amp;gt;COUNTRY&amp;lt; td&amp;gt;&amp;lt; tr&amp;gt; &amp;lt; table&amp;gt; The &amp;lt;code&amp;gt;ctlDir&amp;lt; code&amp;gt; directory must then contain the files &amp;lt;code&amp;gt;COUNTRY.ctl&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;LANGUAGE.ctl&amp;lt; code&amp;gt;. &amp;lt; p&amp;gt; @author Stephan Strittmatter (stritti AT users.sourceforge.net), gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 817 $ $Date: 2008-09-29 17:23:35 -0300 (Seg, 29 Set 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlDataSet.SqlLoaderControlDataSet(String, String)" access="pub" jdoc="The Constructor. @param ctlDir the control files directory @param orderedTablesFile the table order file @throws DataSetException the data set exception">
				<param name="ctlDir"/>
				<param name="orderedTablesFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlDataSet.SqlLoaderControlDataSet(File, File)" access="pub" jdoc="The Constructor. @param ctlDir the control files directory @param orderedTablesFile the table order file @throws DataSetException the data set exception">
				<param name="ctlDir"/>
				<param name="orderedTablesFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlDataSet.SqlLoaderControlDataSet(File, List)" access="pub" jdoc="The Constructor. @param ctlDir the control files directory @param orderedTableNames a list of strings that contains the ordered table names @throws DataSetException the data set exception">
				<param name="ctlDir"/>
				<param name="orderedTableNames"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer" intfc="n" abs="n" inn="n" sloc="107" jdoc="Producer that creates an {@link IDataSet} using SQLLoader style &amp;apos;.ctl&amp;apos; files. @author Stephan Strittmatter (stritti AT users.sourceforge.net), gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 855 $ $Date: 2008-11-01 12:23:09 -0200 (SÃ¡b, 01 Nov 2008) $ @since 2.4.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="TMP_TABLE_LIST_FILENAME" access="priv" jdoc=""/>
			<const name="NULL" access="pub" jdoc="The Constant NULL."/>
			<const name="EMPTY_CONSUMER" access="priv" jdoc="The Constant EMPTY_CONSUMER."/>
			<field name="consumer" access="priv" jdoc="The consumer."/>
			<const name="controlFilesDir" access="priv" jdoc="The control files directory"/>
			<field name="orderedTableNames" access="priv" jdoc="String list of the ordered table names"/>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer.SqlLoaderControlProducer(String, String)" access="pub" jdoc="The Constructor. @param controlFilesDir the control files directory @param tableOrderFile the table order file @throws DataSetException">
				<param name="controlFilesDir"/>
				<param name="tableOrderFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer.SqlLoaderControlProducer(File, File)" access="pub" jdoc="The Constructor. @param controlFilesDir the control files directory @param tableOrderFile the table order file @throws DataSetException">
				<param name="controlFilesDir"/>
				<param name="tableOrderFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer.SqlLoaderControlProducer(File, List)" access="pub" jdoc="The Constructor. @param controlFilesDir the control files directory @param orderedTableNames a list of strings that contains the ordered table names">
				<param name="controlFilesDir"/>
				<param name="orderedTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer.setConsumer(IDataSetConsumer)" access="pub" jdoc="@see org.dbunit.dataset.stream.IDataSetProducer#setConsumer(org.dbunit.dataset.stream.IDataSetConsumer)">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer.produce()" access="pub" jdoc="@see org.dbunit.dataset.stream.IDataSetProducer#produce()">
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer.produceFromControlFile(File)" access="priv" jdoc="Produce from control file. @param controlFile the control file @throws DataSetException the data set exception @throws SqlLoaderControlParserException the oracle control parser exception">
				<param name="controlFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlProducer.getTables(File, File)" access="pub" jdoc="Get a list of tables that this producer will create. @param controlFilesDir the base directory @param tableList the table list @return a list of Strings, where each item is a CSV file relative to the base URL @throws IOException when IO on the base URL has issues.">
				<comm cntt="Copy file into the control directory"/>
				<param name="controlFilesDir"/>
				<param name="tableList"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserException" intfc="n" abs="n" inn="n" sloc="5" jdoc="@author Stephan Strittmatter (stritti AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 817 $ $Date: 2008-09-29 17:23:35 -0300 (Seg, 29 Set 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParserException.SqlLoaderControlParserException(String)" access="pub" jdoc="The Constructor. @param message the message">
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParser" intfc="y" abs="n" inn="n" sloc="6" jdoc="Interface of Parser which parses Oracle SQLLoader files. @author Stephan Strittmatter (stritti AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 817 $ $Date: 2008-09-29 17:23:35 -0300 (Seg, 29 Set 2008) $ @since 2.4.0">
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParser.parse(File)" access="pub" jdoc="Parse. @param file the file @return the list @throws IOException @throws SqlLoaderControlParserException">
				<param name="file"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParser.parse(URL)" access="pub" jdoc="Parse. @param url the URL @return the list @throws IOException @throws SqlLoaderControlParserException">
				<param name="url"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParser.parse(String)" access="pub" jdoc="Parse. @param csv the CSV data @return the list @throws IllegalInputCharacterException @throws PipelineException">
				<param name="csv"/>
			</mth>
			<mth name="/:org.dbunit.dataset.sqlloader.SqlLoaderControlParser.getTableName()" access="pub" jdoc="">
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.stream">
		<class name="/:org.dbunit.dataset.stream.StreamingIterator" intfc="n" abs="n" inn="n" sloc="78" jdoc="Asynchronous table iterator that uses a new Thread for asynchronous processing. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 780 $ $Date: 2008-08-10 18:00:11 -0300 (Dom, 10 Ago 2008) $ @since Apr 17, 2003">
			<comm cntt="end of dataset marker"/>
			<comm cntt=""/>
			<comm cntt="ITableIterator interface"/>
			<comm cntt=""/>
			<comm cntt="StreamingTable class"/>
			<comm cntt=""/>
			<comm cntt="AsynchronousConsumer class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EOD" access="priv" jdoc=""/>
			<const name="_channel" access="priv" jdoc=""/>
			<field name="_activeTable" access="priv" jdoc=""/>
			<field name="_taken" access="priv" jdoc=""/>
			<field name="_eod" access="priv" jdoc=""/>
			<field name="_asyncException" access="priv" jdoc="Variable to store an exception that might occur in the asynchronous consumer"/>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator.StreamingIterator(IDataSetProducer)" access="pub" jdoc="Iterator that creates a table iterator by reading the input from the given source in an asynchronous way. Therefore a Thread is created. @param source The source of the data @throws DataSetException">
				<comm cntt="Take first element from asynchronous handler"/>
				<param name="source"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator.resolveException(InterruptedException)" access="priv" jdoc="">
				<param name="cause"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator.next()" access="pub" jdoc="">
				<comm cntt="End of dataset has previously been reach"/>
				<comm cntt="Iterate to the end of current table."/>
				<comm cntt="End of dataset is reach"/>
				<comm cntt="New table"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator.getTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator.handleException(Exception)" access="priv" jdoc="">
				<comm cntt="Is invoked when the asynchronous thread reports an exception"/>
				<param name="e"/>
			</mth>
		<class name="/:org.dbunit.dataset.stream.StreamingIterator$StreamingTable" intfc="n" abs="n" inn="y" sloc="64" jdoc="">
			<comm cntt=""/>
			<comm cntt="ITable interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_metaData" access="priv" jdoc=""/>
			<field name="_lastRow" access="priv" jdoc=""/>
			<field name="_eot" access="priv" jdoc=""/>
			<field name="_rowValues" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$StreamingTable.StreamingTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$StreamingTable.next()" access="pub" jdoc="">
				<comm cntt="End of table has previously been reach"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$StreamingTable.getTableMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$StreamingTable.getRowCount()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$StreamingTable.getValue(int, String)" access="pub" jdoc="">
				<comm cntt="Iterate up to specified row"/>
				<param name="row"/>
				<param name="columnName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer" intfc="n" abs="n" inn="y" sloc="72" jdoc="">
			<comm cntt=""/>
			<comm cntt="Runnable interface"/>
			<comm cntt=""/>
			<comm cntt="IDataSetConsumer interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_producer" access="priv" jdoc=""/>
			<const name="_channel" access="priv" jdoc=""/>
			<const name="_exceptionHandler" access="priv" jdoc=""/>
			<const name="_invokerThread" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer.AsynchronousConsumer(IDataSetProducer, Puttable, StreamingIterator)" access="pub" jdoc="">
				<param name="source"/>
				<param name="channel"/>
				<param name="exceptionHandler"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer.run()" access="pub" jdoc="">
				<comm cntt="Since the invoker thread probably waits tell it that we have finished here"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer.startDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer.endDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer.startTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer.endTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingIterator$AsynchronousConsumer.row(Object[])" access="pub" jdoc="">
				<param name="values"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.stream.BufferedConsumer" intfc="n" abs="n" inn="n" sloc="69" jdoc="Implementation of {@link IDataSetConsumer} which buffers all data until the {@link #endDataSet()} event occurs. This provides the possibility to append new {@link Column}s on the fly which is needed for the column sensing feature in{@link FlatXmlDataSet}. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 941 $ $Date: 2009-01-16 13:42:11 -0200 (Sex, 16 Jan 2009) $ @since 2.3.0">
			<field name="_wrappedConsumer" access="priv" jdoc=""/>
			<field name="_activeTable" access="priv" jdoc="The table which is currently active"/>
			<field name="_tableBuffers" access="priv" jdoc="List that stores all {@link TableBuffer}s in a sorted fashion so that the table that was added first will also be flushed first when the {@link IDataSetConsumer}is finally invoked."/>
			<field name="_tableNames" access="priv" jdoc="Map that stores the table names as key and the {@link TableBuffer} as value"/>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer.BufferedConsumer(IDataSetConsumer)" access="pub" jdoc="@param wrappedConsumer The consumer that is wrapped">
				<param name="wrappedConsumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer.startDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer.endDataSet()" access="pub" jdoc="">
				<comm cntt="Flush out the whole collected dataset"/>
				<comm cntt="Start the table with the final metadata"/>
				<comm cntt="Clear the row data for this table finally"/>
				<comm cntt="Finally notify consumer of the end of this DataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer.row(Object[])" access="pub" jdoc="">
				<comm cntt="Just collect buffer the row"/>
				<param name="values"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer.startTable(ITableMetaData)" access="pub" jdoc="">
				<comm cntt="Do nothing here - we will buffer all data in the &amp;quot;row&amp;quot; method in order to write"/>
				<comm cntt="them in the &amp;quot;endTable&amp;quot; method"/>
				<comm cntt="overwrite the metadata with the new one which potentially contains new columns"/>
				<comm cntt="add to the sorted list"/>
				<comm cntt="add to the name map"/>
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer.endTable()" access="pub" jdoc="">
				<comm cntt="Fill up columns that were potentially missing in this row"/>
				<comm cntt="Note that this only works when new columns are always added at the end to the _activeMetaData"/>
				<comm cntt="If this row has less columns than final metaData, fill it up with &amp;quot;null&amp;quot;s so that it matches the length"/>
				<comm cntt="Put in original values and leave all missing columns on &amp;quot;null&amp;quot;"/>
			</mth>
		<class name="/:org.dbunit.dataset.stream.BufferedConsumer$TableBuffer" intfc="n" abs="n" inn="y" sloc="22" jdoc="">
			<field name="metaData" access="priv" jdoc=""/>
			<const name="dataRows" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer$TableBuffer.TableBuffer(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer$TableBuffer.TableBuffer(ITableMetaData, ArrayList)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="dataRows"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer$TableBuffer.getMetaData()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer$TableBuffer.setMetaData(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.BufferedConsumer$TableBuffer.getDataRows()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.stream.IDataSetConsumer" intfc="y" abs="n" inn="n" sloc="8" jdoc="Receive notification of the content of a dataset. @author Manuel Laflamme @since Apr 17, 2003 @version $Revision: 398 $">
			<mth name="/:org.dbunit.dataset.stream.IDataSetConsumer.startDataSet()" access="pub" jdoc="Receive notification of the beginning of a dataset. This method is invoked only once, before any other methods in this interface.">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.IDataSetConsumer.endDataSet()" access="pub" jdoc="Receive notification of the end of a dataset. This method is invoked only once, and it will be the last method invoked in this interface.">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.IDataSetConsumer.startTable(ITableMetaData)" access="pub" jdoc="Receive notification of the beginning of a table. This method is invoked at the beginning of every table in the dataset; there will be a corresponding {@link #endDataSet} event for every &amp;lt;code&amp;gt;startTable&amp;lt; code&amp;gt; event (even when the table is empty). @param metaData the table metadata">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.IDataSetConsumer.endTable()" access="pub" jdoc="Receive notification of the end of a table.">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.IDataSetConsumer.row(Object[])" access="pub" jdoc="Receive notification of a table row. This method is invoked to report each row of a table. @param values The row values.">
				<param name="values"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.stream.DefaultConsumer" intfc="n" abs="n" inn="n" sloc="18" jdoc="This class provides no op implementations for all of the callbacks in the{@link org.dbunit.dataset.stream.IDataSetConsumer} interface. @author Manuel Laflamme @since Apr 29, 2003 @version $Revision: 398 $">
			<mth name="/:org.dbunit.dataset.stream.DefaultConsumer.startDataSet()" access="pub" jdoc="">
				<comm cntt="no op"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.DefaultConsumer.endDataSet()" access="pub" jdoc="">
				<comm cntt="no op"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.DefaultConsumer.startTable(ITableMetaData)" access="pub" jdoc="">
				<comm cntt="no op"/>
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.DefaultConsumer.endTable()" access="pub" jdoc="">
				<comm cntt="no op"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.DefaultConsumer.row(Object[])" access="pub" jdoc="">
				<comm cntt="no op"/>
				<param name="values"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.stream.DataSetProducerAdapter" intfc="n" abs="n" inn="n" sloc="55" jdoc="Implementation of {@link IDataSetProducer} based on a given {@link IDataSet} or a{@link ITableIterator}. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 782 $ $Date: 2008-08-10 18:02:02 -0300 (Dom, 10 Ago 2008) $ @since Apr 17, 2003">
			<comm cntt=""/>
			<comm cntt="IDataSetProducer interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EMPTY_CONSUMER" access="priv" jdoc=""/>
			<const name="_iterator" access="priv" jdoc=""/>
			<field name="_consumer" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.stream.DataSetProducerAdapter.DataSetProducerAdapter(ITableIterator)" access="pub" jdoc="">
				<param name="iterator"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.DataSetProducerAdapter.DataSetProducerAdapter(IDataSet)" access="pub" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.DataSetProducerAdapter.setConsumer(IDataSetConsumer)" access="pub" jdoc="">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.DataSetProducerAdapter.produce()" access="pub" jdoc="">
				<comm cntt="This exception occurs when records are exhausted"/>
				<comm cntt="and we reach the end of the table. Ignore this error"/>
				<comm cntt="and close table."/>
				<comm cntt="end of table"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.stream.StreamingDataSet" intfc="n" abs="n" inn="n" sloc="41" jdoc="Dataset that consumes producer asynchronously. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 932 $ $Date: 2008-12-30 07:59:17 -0200 (Ter, 30 Dez 2008) $ @since Apr 18, 2003">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_source" access="priv" jdoc=""/>
			<field name="_iteratorCount" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.stream.StreamingDataSet.StreamingDataSet(IDataSetProducer)" access="pub" jdoc="">
				<param name="source"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingDataSet.createIterator(boolean)" access="prot" jdoc="">
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingDataSet.getTableNames()" access="pub" jdoc="Not supported. @throws UnsupportedOperationException">
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingDataSet.getTableMetaData(String)" access="pub" jdoc="Not supported. @throws UnsupportedOperationException">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.StreamingDataSet.getTable(String)" access="pub" jdoc="Not supported. @throws UnsupportedOperationException">
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.stream.IDataSetProducer" intfc="y" abs="n" inn="n" sloc="5" jdoc="Interface for reading a dataset using callback. @author Manuel Laflamme @since Apr 17, 2003 @version $Revision: 398 $">
			<mth name="/:org.dbunit.dataset.stream.IDataSetProducer.setConsumer(IDataSetConsumer)" access="pub" jdoc="">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.stream.IDataSetProducer.produce()" access="pub" jdoc="Process this dataset source. During the processing, the IDataSetProducer will provide information about the dataset through the specified event listener. &amp;lt;p&amp;gt; This method is synchronous: it will not return until processing has ended. If a client application wants to terminate parsing early, it should throw an exception from the listener.">
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.dataset.xml">
		<class name="/:org.dbunit.dataset.xml.FlatDtdWriter" intfc="n" abs="n" inn="n" sloc="59" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 863 $ $Date: 2008-11-07 07:35:46 -0200 (Sex, 07 Nov 2008) $ @since Jun 13, 2003">
			<comm cntt="implements IDataSetConsumer"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="SEQUENCE" access="pub" jdoc=""/>
			<const name="CHOICE" access="pub" jdoc=""/>
			<field name="_writer" access="priv" jdoc=""/>
			<field name="_contentModel" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter.FlatDtdWriter(Writer)" access="pub" jdoc="">
				<param name="writer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter.setContentModel(ContentModel)" access="pub" jdoc="">
				<param name="contentModel"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter.write(IDataSet)" access="pub" jdoc="">
				<comm cntt="dataset element"/>
				<comm cntt="tables"/>
				<comm cntt="table element"/>
				<comm cntt="column attributes"/>
				<comm cntt="Add the columns"/>
				<param name="dataSet"/>
			</mth>
		<class name="/:org.dbunit.dataset.xml.FlatDtdWriter$ContentModel" intfc="n" abs="y" inn="y" sloc="14" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 863 $ $Date: 2008-11-07 07:35:46 -0200 (Sex, 07 Nov 2008) $ @since Jun 13, 2003">
			<const name="_name" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter$ContentModel.ContentModel(String)" access="priv" jdoc="">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter$ContentModel.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter$ContentModel.write(PrintWriter, String, int, int)" access="pub" jdoc="">
				<param name="writer"/>
				<param name="tableName"/>
				<param name="tableIndex"/>
				<param name="tableCount"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatDtdWriter$SequenceModel" intfc="n" abs="n" inn="y" sloc="24" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 863 $ $Date: 2008-11-07 07:35:46 -0200 (Sex, 07 Nov 2008) $ @since Jun 13, 2003">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter$SequenceModel.SequenceModel()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter$SequenceModel.write(PrintWriter, String, int, int)" access="pub" jdoc="">
				<param name="writer"/>
				<param name="tableName"/>
				<param name="tableIndex"/>
				<param name="tableCount"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatDtdWriter$ChoiceModel" intfc="n" abs="n" inn="y" sloc="35" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 863 $ $Date: 2008-11-07 07:35:46 -0200 (Sex, 07 Nov 2008) $ @since Jun 13, 2003">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter$ChoiceModel.ChoiceModel()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdWriter$ChoiceModel.write(PrintWriter, String, int, int)" access="pub" jdoc="">
				<param name="writer"/>
				<param name="tableName"/>
				<param name="tableIndex"/>
				<param name="tableCount"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.xml.XmlDataSetWriter" intfc="n" abs="n" inn="n" sloc="198" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 947 $ $Date: 2009-01-20 15:34:50 -0200 (Ter, 20 Jan 2009) $ @since 1.5.5 (Jun 13, 2003)">
			<comm cntt="whitespace"/>
			<comm cntt="forbidden char"/>
			<comm cntt=""/>
			<comm cntt="IDataSetConsumer interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATASET" access="priv" jdoc=""/>
			<const name="TABLE" access="priv" jdoc=""/>
			<const name="NAME" access="priv" jdoc=""/>
			<const name="COLUMN" access="priv" jdoc=""/>
			<const name="ROW" access="priv" jdoc=""/>
			<const name="VALUE" access="priv" jdoc=""/>
			<const name="NULL" access="priv" jdoc=""/>
			<const name="NONE" access="priv" jdoc=""/>
			<field name="CDATA_DETECTION_CHARS" access="pub" jdoc=""/>
			<field name="_xmlWriter" access="priv" jdoc=""/>
			<field name="_activeMetaData" access="priv" jdoc=""/>
			<field name="includeColumnComments" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.XmlDataSetWriter(OutputStream, String)" access="pub" jdoc="@param outputStream The stream to which the XML will be written. @param encoding The encoding to be used for the {@link XmlWriter}. Can be null. See {@link XmlWriter#XmlWriter(OutputStream,String)}. @throws UnsupportedEncodingException">
				<param name="outputStream"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.XmlDataSetWriter(Writer)" access="pub" jdoc="">
				<param name="writer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.XmlDataSetWriter(Writer, String)" access="pub" jdoc="">
				<param name="writer"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.setPrettyPrint(boolean)" access="pub" jdoc="Enable or disable pretty print of the XML. @param enabled &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; to enable pretty print (which is the default). &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; otherwise. @since 2.4">
				<param name="enabled"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.setIncludeColumnComments(boolean)" access="pub" jdoc="Whether or not to write the column name as comment into the XML @param includeColumnComments Whether or not to write the column name as comment into the XML">
				<param name="includeColumnComments"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.write(IDataSet)" access="pub" jdoc="Writes the given {@link IDataSet} using this writer. @param dataSet The {@link IDataSet} to be written @throws DataSetException">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.needsCData(String)" access="pub" jdoc="">
				<param name="text"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.startDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.endDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.startTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.endTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.row(Object[])" access="pub" jdoc="">
				<comm cntt="null"/>
				<comm cntt="none"/>
				<comm cntt="values"/>
				<param name="values"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.writeValueCData(String)" access="prot" jdoc="Writes the given String as CDATA using the {@link XmlWriter}. Can be overridden to add custom behavior. This implementation just invokes {@link XmlWriter#writeCData(String)} @param stringValue The value to be written @throws IOException @since 2.4.4">
				<param name="stringValue"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.writeValue(String)" access="prot" jdoc="Writes the given String as normal text using the {@link XmlWriter}. Can be overridden to add custom behavior. This implementation just invokes {@link XmlWriter#writeText(String)}. @param stringValue The value to be written @throws IOException @since 2.4.4">
				<param name="stringValue"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSetWriter.getXmlWriter()" access="prot" jdoc="@return The {@link XmlWriter} that is used for writing out XML. @since 2.4.4">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.XmlProducer" intfc="n" abs="n" inn="n" sloc="240" jdoc="Parses an XML and produces a dataset from it. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 815 $ $Date: 2008-09-27 09:33:56 -0300 (SÃ¡b, 27 Set 2008) $ @since Apr 30, 2003">
			<comm cntt=""/>
			<comm cntt="IDataSetProducer interface"/>
			<comm cntt=""/>
			<comm cntt="EntityResolver interface"/>
			<comm cntt=""/>
			<comm cntt="ContentHandler interface"/>
			<comm cntt=""/>
			<comm cntt="ErrorHandler interface"/>
			<comm cntt="public void warning(SAXParseException e)"/>
			<comm cntt="throws SAXException"/>
			<comm cntt="{"/>
			<comm cntt="throw e;"/>
			<comm cntt="}"/>
			<comm cntt="public void fatalError(SAXParseException e)"/>
			<comm cntt="throws SAXException"/>
			<comm cntt="{"/>
			<comm cntt="throw e;"/>
			<comm cntt="}"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EMPTY_CONSUMER" access="priv" jdoc=""/>
			<const name="DATASET" access="priv" jdoc=""/>
			<const name="TABLE" access="priv" jdoc=""/>
			<const name="NAME" access="priv" jdoc=""/>
			<const name="COLUMN" access="priv" jdoc=""/>
			<const name="ROW" access="priv" jdoc=""/>
			<const name="VALUE" access="priv" jdoc=""/>
			<const name="NULL" access="priv" jdoc=""/>
			<const name="NONE" access="priv" jdoc=""/>
			<const name="_inputSource" access="priv" jdoc=""/>
			<field name="_validating" access="priv" jdoc=""/>
			<field name="_consumer" access="priv" jdoc=""/>
			<field name="_activeTableName" access="priv" jdoc=""/>
			<field name="_activeMetaData" access="priv" jdoc=""/>
			<field name="_activeColumnNames" access="priv" jdoc=""/>
			<field name="_activeCharacters" access="priv" jdoc=""/>
			<field name="_activeRowValues" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.XmlProducer(InputSource)" access="pub" jdoc="">
				<param name="inputSource"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.createMetaData(String, List)" access="priv" jdoc="">
				<param name="tableName"/>
				<param name="columnNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.setValidating(boolean)" access="pub" jdoc="">
				<param name="validating"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.setConsumer(IDataSetConsumer)" access="pub" jdoc="">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.produce()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.buildException(SAXException)" access="prot" jdoc="Wraps a {@link SAXException} into a {@link DataSetException} @param cause The cause to be wrapped into a {@link DataSetException} @return A {@link DataSetException} that wraps the given {@link SAXException}">
				<param name="cause"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.resolveEntity(String, String)" access="pub" jdoc="">
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.startElement(String, String, String, Attributes)" access="pub" jdoc="">
				<comm cntt="dataset"/>
				<comm cntt="table"/>
				<comm cntt="column"/>
				<comm cntt="row"/>
				<comm cntt="End of metadata at first row"/>
				<comm cntt="value"/>
				<comm cntt="null"/>
				<comm cntt="none"/>
				<param name="uri"/>
				<param name="localName"/>
				<param name="qName"/>
				<param name="attributes"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.endElement(String, String, String)" access="pub" jdoc="">
				<comm cntt="dataset"/>
				<comm cntt="table"/>
				<comm cntt="End of metadata"/>
				<comm cntt="column"/>
				<comm cntt="row"/>
				<comm cntt="value"/>
				<comm cntt="null"/>
				<comm cntt="Nothing to do, already processed in startElement()"/>
				<comm cntt="none"/>
				<comm cntt="Nothing to do, already processed in startElement()"/>
				<param name="uri"/>
				<param name="localName"/>
				<param name="qName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.characters(char, int, int)" access="pub" jdoc="">
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlProducer.error(SAXParseException)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatXmlDataSet" intfc="n" abs="n" inn="n" sloc="129" jdoc="Reads and writes flat XML dataset document. Each XML element corresponds to a table row. Each XML element name corresponds to a table name. The XML attributes correspond to table columns. &amp;lt;p&amp;gt; Flat XML dataset document sample: &amp;lt;p&amp;gt; &amp;lt;pre&amp;gt; &amp;lt;!DOCTYPE dataset SYSTEM &amp;quot;my-dataset.dtd&amp;quot;&amp;gt; &amp;lt;dataset&amp;gt; &amp;lt;TEST_TABLE COL0=&amp;quot;row 0 col 0&amp;quot; COL1=&amp;quot;row 0 col 1&amp;quot; COL2=&amp;quot;row 0 col 2&amp;quot; &amp;gt; &amp;lt;TEST_TABLE COL1=&amp;quot;row 1 col 1&amp;quot; &amp;gt; &amp;lt;SECOND_TABLE COL0=&amp;quot;row 0 col 0&amp;quot; COL1=&amp;quot;row 0 col 1&amp;quot; &amp;gt; &amp;lt;EMPTY_TABLE &amp;gt; &amp;lt; dataset&amp;gt;&amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; To specify null values, omit corresponding attribute. In the above example, missing COL0 and COL2 attributes of TEST_TABLE second row represents null values. &amp;lt;p&amp;gt; Table metadata is deduced from the first row of each table by default. &amp;lt;b&amp;gt;Beware that DbUnit may think a table misses some columns if the first row of that table has one or more null values.&amp;lt; b&amp;gt; You can do one of the following things to avoid this: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Use a DTD. DbUnit will use the columns declared in the DTD as table metadata. DbUnit only supports external system URI. The URI can be absolute or relative. &amp;lt; li&amp;gt; &amp;lt;li&amp;gt;Since DBUnit 2.3.0 there is a functionality called &amp;quot;column sensing&amp;quot; which basically reads in the whole XML into a buffer and dynamically adds new columns as they appear. It can be used as demonstrated in the following example: &amp;lt;pre&amp;gt; since dbunit 2.4.7 FlatXmlDataSetBuilder builder = new FlatXmlDataSetBuilder(); builder.setInputSource(new File(&amp;quot;src xml flatXmlTableTest.xml&amp;quot;)); builder.setColumnSensing(true); IDataSet dataSet = builder.build(); or dbunit release &amp;lt;= 2.4.6: boolean enableColumnSensing = true; IDataSet dataSet = new FlatXmlDataSet( new File(&amp;quot;src xml flatXmlTableTest.xml&amp;quot;), false, enableColumnSensing); &amp;lt; pre&amp;gt; &amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; &amp;lt; p&amp;gt; @author Manuel Laflamme @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1048 $ $Date: 2009-09-26 13:21:40 -0300 (SÃ¡b, 26 Set 2009) $ @since 1.0 (Mar 12, 2002)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(FlatXmlProducer)" access="pub" jdoc="Creates a new {@link FlatXmlDataSet} with the data of the given producer. @param flatXmlProducer The producer that provides the {@link FlatXmlDataSet} content @throws DataSetException @since 2.4.7">
				<param name="flatXmlProducer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(InputSource)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified InputSource. @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="source"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(File)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml file. Relative DOCTYPE uri are resolved from the xml file path. @param xmlFile the xml file @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(File, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml file. Relative DOCTYPE uri are resolved from the xml file path. @param xmlFile the xml file @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlFile"/>
				<param name="dtdMetadata"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(File, boolean, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml file. Relative DOCTYPE uri are resolved from the xml file path. @param xmlFile the xml file @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @param columnSensing Whether or not the columns should be sensed automatically. Every XML row is scanned for columns that have not been there in a previous column. @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlFile"/>
				<param name="dtdMetadata"/>
				<param name="columnSensing"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(File, boolean, boolean, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml file. Relative DOCTYPE uri are resolved from the xml file path. @param xmlFile the xml file @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @param columnSensing Whether or not the columns should be sensed automatically. Every XML row is scanned for columns that have not been there in a previous column. @param caseSensitiveTableNames Whether or not this dataset should use case sensitive table names @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlFile"/>
				<param name="dtdMetadata"/>
				<param name="columnSensing"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(URL)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml URL. Relative DOCTYPE uri are resolved from the xml file path. @param xmlUrl the xml URL @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlUrl"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(URL, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml URL. Relative DOCTYPE uri are resolved from the xml file path. @param xmlUrl the xml URL @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlUrl"/>
				<param name="dtdMetadata"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(URL, boolean, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml URL. Relative DOCTYPE uri are resolved from the xml file path. @param xmlUrl the xml URL @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @param columnSensing Whether or not the columns should be sensed automatically. Every XML row is scanned for columns that have not been there in a previous column. @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlUrl"/>
				<param name="dtdMetadata"/>
				<param name="columnSensing"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(URL, boolean, boolean, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml file. Relative DOCTYPE uri are resolved from the xml file path. @param xmlUrl the xml file @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @param columnSensing Whether or not the columns should be sensed automatically. Every XML row is scanned for columns that have not been there in a previous column. @param caseSensitiveTableNames Whether or not this dataset should use case sensitive table names @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlUrl"/>
				<param name="dtdMetadata"/>
				<param name="columnSensing"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(Reader)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml reader. Relative DOCTYPE uri are resolved from the current working directory. @param xmlReader the xml reader @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlReader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(Reader, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml reader. Relative DOCTYPE uri are resolved from the current working directory. @param xmlReader the xml reader @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlReader"/>
				<param name="dtdMetadata"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(Reader, boolean, boolean, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml file. Relative DOCTYPE uri are resolved from the xml file path. @param xmlReader the xml reader @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @param columnSensing Whether or not the columns should be sensed automatically. Every XML row is scanned for columns that have not been there in a previous column. @param caseSensitiveTableNames Whether or not this dataset should use case sensitive table names @since 2.4.3 @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlReader"/>
				<param name="dtdMetadata"/>
				<param name="columnSensing"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(Reader, Reader)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml and dtd readers. @param xmlReader the xml reader @param dtdReader the dtd reader @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlReader"/>
				<param name="dtdReader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(Reader, IDataSet)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml reader. @param xmlReader the xml reader @param metaDataSet the dataset used as metadata source. @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlReader"/>
				<param name="metaDataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(InputStream)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml input stream. Relative DOCTYPE uri are resolved from the current working directory. @param xmlStream the xml input stream @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlStream"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(InputStream, boolean)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml input stream. Relative DOCTYPE uri are resolved from the current working directory. @param xmlStream the xml input stream @param dtdMetadata if &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; do not use DTD as metadata @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlStream"/>
				<param name="dtdMetadata"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(InputStream, InputStream)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml and dtd input stream. @param xmlStream the xml input stream @param dtdStream the dtd input stream @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlStream"/>
				<param name="dtdStream"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.FlatXmlDataSet(InputStream, IDataSet)" access="pub" jdoc="Creates an FlatXmlDataSet object with the specified xml input stream. @param xmlStream the xml input stream @param metaDataSet the dataset used as metadata source. @deprecated since 2.4.7 - use {@link FlatXmlDataSetBuilder} to create a {@link FlatXmlDataSet}">
				<param name="xmlStream"/>
				<param name="metaDataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.write(IDataSet, OutputStream)" access="pub" jdoc="Write the specified dataset to the specified output stream as xml.">
				<param name="dataSet"/>
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.write(IDataSet, Writer)" access="pub" jdoc="Write the specified dataset to the specified writer as xml.">
				<param name="dataSet"/>
				<param name="writer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.write(IDataSet, Writer, String)" access="pub" jdoc="Write the specified dataset to the specified writer as xml.">
				<param name="dataSet"/>
				<param name="writer"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSet.writeDtd(IDataSet, OutputStream)" access="pub" jdoc="Write a DTD for the specified dataset to the specified output. @deprecated use {@link FlatDtdDataSet#write}">
				<param name="dataSet"/>
				<param name="out"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder" intfc="n" abs="n" inn="n" sloc="116" jdoc="Builder for the creation of {@link FlatXmlDataSet} instances. @see FlatXmlDataSet @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1048 $ $Date: 2009-09-26 13:21:40 -0300 (SÃ¡b, 26 Set 2009) $ @since 2.4.7">
			<comm cntt="TODO Think about this: should we use &amp;quot;columnSensing=true&amp;quot; by default if no DTD is specified? To avoid e.g. bug reports like #2812985 https: sourceforge.net tracker ?func=detail&amp;atid=449491&amp;aid=2812985&amp;group_id=47439"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="metaDataSet" access="priv" jdoc="The metadata (column information etc.) for the flat XML to be built. If this is set the builder properties &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;{@link #columnSensing}&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;{@link #caseSensitiveTableNames}&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;{@link #dtdMetadata}&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; are &amp;lt;b&amp;gt;not&amp;lt; b&amp;gt; regarded."/>
			<field name="dtdMetadata" access="priv" jdoc="Whether or not DTD metadata is available to parse via a DTD handler. Defaults to {@value}"/>
			<field name="columnSensing" access="priv" jdoc="Since DBUnit 2.3.0 there is a functionality called &amp;quot;column sensing&amp;quot; which basically reads in the whole XML into a buffer and dynamically adds new columns as they appear. Defaults to {@value}"/>
			<field name="caseSensitiveTableNames" access="priv" jdoc="Whether or not the created dataset should use case sensitive table names Defaults to {@value}"/>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.FlatXmlDataSetBuilder()" access="pub" jdoc="Default constructor">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.build(InputSource)" access="pub" jdoc="Sets the flat XML input source from which the {@link FlatXmlDataSet} is to be built @param inputSource The flat XML input as {@link InputSource} @return The created {@link FlatXmlDataSet} @throws DataSetException">
				<param name="inputSource"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.build(File)" access="pub" jdoc="Sets the flat XML input source from which the {@link FlatXmlDataSet} is to be built @param xmlInputFile The flat XML input as {@link File} @return The created {@link FlatXmlDataSet} @throws DataSetException">
				<param name="xmlInputFile"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.build(URL)" access="pub" jdoc="Sets the flat XML input source from which the {@link FlatXmlDataSet} is to be built @param xmlInputUrl The flat XML input as {@link URL} @return The created {@link FlatXmlDataSet} @throws DataSetException">
				<param name="xmlInputUrl"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.build(Reader)" access="pub" jdoc="Sets the flat XML input source from which the {@link FlatXmlDataSet} is to be built @param xmlReader The flat XML input as {@link Reader} @return The created {@link FlatXmlDataSet} @throws DataSetException">
				<param name="xmlReader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.build(InputStream)" access="pub" jdoc="Sets the flat XML input source from which the {@link FlatXmlDataSet} is to be built @param xmlInputStream The flat XML input as {@link InputStream} @return The created {@link FlatXmlDataSet} @throws DataSetException">
				<param name="xmlInputStream"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.createInputSourceFromUrl(URL)" access="priv" jdoc="Utility method to create an {@link InputSource} object from a URL @param xmlInputUrl @return">
				<param name="xmlInputUrl"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.setMetaDataSet(IDataSet)" access="pub" jdoc="Set the metadata information (column info etc.) to be used. May come from a DTD. This has precedence to the other builder&amp;apos;s properties. @param metaDataSet @return this">
				<param name="metaDataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.setMetaDataSetFromDtd(Reader)" access="pub" jdoc="Set the metadata information (column info etc.) to be used from the given DTD input. This has precedence to the other builder&amp;apos;s properties. @param dtdReader A reader that provides the DTD content @throws DataSetException @throws IOException @return this">
				<param name="dtdReader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.setMetaDataSetFromDtd(InputStream)" access="pub" jdoc="Set the metadata information (column info etc.) to be used from the given DTD input. This has precedence to the other builder&amp;apos;s properties. @param dtdStream @throws DataSetException @throws IOException @return this">
				<param name="dtdStream"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.isDtdMetadata()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.setDtdMetadata(boolean)" access="pub" jdoc="Whether or not DTD metadata is available to parse via a DTD handler. @param dtdMetadata @return this">
				<param name="dtdMetadata"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.isColumnSensing()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.setColumnSensing(boolean)" access="pub" jdoc="Since DBUnit 2.3.0 there is a functionality called &amp;quot;column sensing&amp;quot; which basically reads in the whole XML into a buffer and dynamically adds new columns as they appear. @param columnSensing @return this">
				<param name="columnSensing"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.isCaseSensitiveTableNames()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.setCaseSensitiveTableNames(boolean)" access="pub" jdoc="Whether or not the created dataset should use case sensitive table names @param caseSensitiveTableNames @return this">
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.buildInternal(InputSource)" access="priv" jdoc="Builds the {@link FlatXmlDataSet} from the parameters that are currently set on this builder @param inputSource The XML input to be built @return The {@link FlatXmlDataSet} built from the configuration of this builder. @throws DataSetException">
				<comm cntt="Validate required parameters"/>
				<comm cntt="Create the flat XML IDataSet"/>
				<param name="inputSource"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.createProducer(InputSource)" access="prot" jdoc="@param inputSource The XML input to be built @return The producer which is used to create the {@link FlatXmlDataSet}">
				<param name="inputSource"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlDataSetBuilder.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatDtdProducer" intfc="n" abs="n" inn="n" sloc="223" jdoc="Produces a DataSet from a flat DTD. Only external DTDs are supported and for the root element only the following declarations are supported. &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;ANY: like &amp;lt;!Element dataset ANY&amp;gt;&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;sequences: like &amp;lt;!Element dataset (first ,second,third?)gt;&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;choices: like &amp;lt;!Element dataset (first|second+|third)&amp;gt;&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; Combinations of sequences and choices are not support nor are #PCDATA or EMPTY declarations. @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 863 $ $Date: 2008-11-07 07:35:46 -0200 (Sex, 07 Nov 2008) $ @since Apr 27, 2003">
			<comm cntt=""/>
			<comm cntt="IDataSetProducer interface"/>
			<comm cntt=""/>
			<comm cntt="EntityResolver interface"/>
			<comm cntt=""/>
			<comm cntt="DeclHandler interface"/>
			<comm cntt=""/>
			<comm cntt="LexicalHandler interface"/>
			<const name="REQUIRED" access="pub" jdoc="Constant for the value {@value}"/>
			<const name="IMPLIED" access="pub" jdoc="Constant for the value {@value}"/>
			<const name="ANY" access="pub" jdoc="Constant for the value {@value}"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EMPTY_CONSUMER" access="priv" jdoc=""/>
			<const name="XML_CONTENT" access="priv" jdoc=""/>
			<const name="DECL_HANDLER_PROPERTY_NAME" access="priv" jdoc=""/>
			<const name="LEXICAL_HANDLER_PROPERTY_NAME" access="priv" jdoc=""/>
			<field name="_inputSource" access="priv" jdoc=""/>
			<field name="_consumer" access="priv" jdoc=""/>
			<field name="_rootName" access="priv" jdoc=""/>
			<field name="_rootModel" access="priv" jdoc=""/>
			<const name="_columnListMap" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.FlatDtdProducer()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.FlatDtdProducer(InputSource)" access="pub" jdoc="">
				<param name="inputSource"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.setDeclHandler(XMLReader, DeclHandler)" access="pub" jdoc="">
				<param name="xmlReader"/>
				<param name="handler"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.setLexicalHandler(XMLReader, LexicalHandler)" access="pub" jdoc="">
				<param name="xmlReader"/>
				<param name="handler"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.createColumnList()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.setConsumer(IDataSetConsumer)" access="pub" jdoc="">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.produce()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.resolveEntity(String, String)" access="pub" jdoc="">
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.elementDecl(String, String)" access="pub" jdoc="">
				<comm cntt="Root element"/>
				<comm cntt="The root model defines the table sequence. Keep it for later used!"/>
				<param name="name"/>
				<param name="model"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.attributeDecl(String, String, String, String, String)" access="pub" jdoc="">
				<comm cntt="Each element attribute represent a table column"/>
				<param name="elementName"/>
				<param name="attributeName"/>
				<param name="type"/>
				<param name="mode"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.internalEntityDecl(String, String)" access="pub" jdoc="">
				<comm cntt="Not used!"/>
				<param name="name"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.externalEntityDecl(String, String, String)" access="pub" jdoc="">
				<comm cntt="Not used!"/>
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.startDTD(String, String, String)" access="pub" jdoc="">
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.endDTD()" access="pub" jdoc="">
				<comm cntt="Remove enclosing model parenthesis"/>
				<comm cntt="Parse the root element model to determine the table sequence."/>
				<comm cntt="Support all sequence or choices model but not the mix of both."/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.addTable(String)" access="priv" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.getColumns(String)" access="priv" jdoc="">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.cleanupTableName(String)" access="prot" jdoc="">
				<comm cntt="Remove beginning parenthesis."/>
				<comm cntt="Remove ending parenthesis and occurrence operators"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.startEntity(String)" access="pub" jdoc="">
				<comm cntt="Not used!"/>
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.endEntity(String)" access="pub" jdoc="">
				<comm cntt="Not used!"/>
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.startCDATA()" access="pub" jdoc="">
				<comm cntt="Not used!"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.endCDATA()" access="pub" jdoc="">
				<comm cntt="Not used!"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdProducer.comment(char, int, int)" access="pub" jdoc="">
				<comm cntt="Not used!"/>
				<param name="ch"/>
				<param name="start"/>
				<param name="length"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatXmlProducer" intfc="n" abs="n" inn="n" sloc="295" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1048 $ $Date: 2009-09-26 13:21:40 -0300 (SÃ¡b, 26 Set 2009) $ @since 1.5 (Apr 18, 2003)">
			<comm cntt=""/>
			<comm cntt="IDataSetProducer interface"/>
			<comm cntt=""/>
			<comm cntt="EntityResolver interface"/>
			<comm cntt=""/>
			<comm cntt="ErrorHandler interface"/>
			<comm cntt=""/>
			<comm cntt="ContentHandler interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EMPTY_CONSUMER" access="priv" jdoc=""/>
			<const name="DATASET" access="priv" jdoc=""/>
			<const name="_inputSource" access="priv" jdoc=""/>
			<const name="_resolver" access="priv" jdoc=""/>
			<field name="_validating" access="priv" jdoc=""/>
			<field name="_metaDataSet" access="priv" jdoc="The dataset used to retrieve the metadata for the tables via {@link IDataSet#getTableMetaData(String)}. Can be null"/>
			<field name="_dtdHandler" access="priv" jdoc="The DTD handler which is used to parse a DTD if available. The result of the parsing is stored in{@link #_metaDataSet}."/>
			<field name="_lineNumber" access="priv" jdoc="The current line number in the current table"/>
			<field name="_lineNumberGlobal" access="priv" jdoc="The current line number"/>
			<field name="_columnSensing" access="priv" jdoc="Whether the column sensing feature should be used to dynamically recognize new columns during the parse process."/>
			<field name="_caseSensitiveTableNames" access="priv" jdoc=""/>
			<field name="_consumer" access="priv" jdoc="The consumer which is responsible for creating the datasets and tables"/>
			<field name="_orderedTableNameMap" access="priv" jdoc="The ordered table name map which also holds the currently active {@link ITableMetaData}"/>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.FlatXmlProducer(InputSource)" access="pub" jdoc="">
				<param name="xmlSource"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.FlatXmlProducer(InputSource, boolean)" access="pub" jdoc="">
				<param name="xmlSource"/>
				<param name="dtdMetadata"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.FlatXmlProducer(InputSource, IDataSet)" access="pub" jdoc="">
				<param name="xmlSource"/>
				<param name="metaDataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.FlatXmlProducer(InputSource, EntityResolver)" access="pub" jdoc="">
				<param name="xmlSource"/>
				<param name="resolver"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.FlatXmlProducer(InputSource, boolean, boolean)" access="pub" jdoc="@param xmlSource The input datasource @param dtdMetadata Whether or not DTD metadata is available to parse via a DTD handler @param columnSensing Whether or not the column sensing feature should be used (see FAQ)">
				<param name="xmlSource"/>
				<param name="dtdMetadata"/>
				<param name="columnSensing"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.FlatXmlProducer(InputSource, boolean, boolean, boolean)" access="pub" jdoc="@param xmlSource The input datasource @param dtdMetadata Whether or not DTD metadata is available to parse via a DTD handler @param columnSensing Whether or not the column sensing feature should be used (see FAQ) @param caseSensitiveTableNames Whether or not this dataset should use case sensitive table names @since 2.4.2">
				<param name="xmlSource"/>
				<param name="dtdMetadata"/>
				<param name="columnSensing"/>
				<param name="caseSensitiveTableNames"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.initialize(boolean)" access="priv" jdoc="">
				<param name="dtdMetadata"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.isCaseSensitiveTableNames()" access="pub" jdoc="@return Whether or not this producer works case sensitively @since 2.4.7">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.createTableMetaData(String, Attributes)" access="priv" jdoc="">
				<comm cntt="First try to find it in the DTD&amp;apos;s dataset"/>
				<comm cntt="Create metadata from attributes"/>
				<param name="tableName"/>
				<param name="attributes"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.mergeTableMetaData(List, ITableMetaData)" access="priv" jdoc="merges the existing columns with the potentially new ones. @param columnsToMerge List of extra columns found, which need to be merge back into the metadata. @return ITableMetaData The merged metadata object containing the new columns @throws DataSetException">
				<param name="columnsToMerge"/>
				<param name="originalMetaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.getActiveMetaData()" access="priv" jdoc="@return The currently active table metadata or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if no active metadata exists.">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.isNewTable(String)" access="priv" jdoc="@param tableName @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the given tableName is a new one which means that it differs from the last active table name.">
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.handleMissingColumns(Attributes)" access="prot" jdoc="parses the attributes in the current row, and checks whether a new column is found. &amp;lt;p&amp;gt;Depending on the value of the &amp;lt;code&amp;gt;columnSensing&amp;lt; code&amp;gt; flag, the appropriate action is taken:&amp;lt; p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;If it is true, the new column is merged back into the metadata;&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;If not, a warning message is displayed.&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; @param attributes Attributed for the current row. @throws DataSetException">
				<comm cntt="Search all columns that do not yet exist and collect them"/>
				<comm cntt="We also need to recreate the table, copying the data already collected from the old one to the new one"/>
				<param name="attributes"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.setColumnSensing(boolean)" access="pub" jdoc="">
				<param name="columnSensing"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.setValidating(boolean)" access="pub" jdoc="">
				<param name="validating"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.setConsumer(IDataSetConsumer)" access="pub" jdoc="">
				<param name="consumer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.produce()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.resolveEntity(String, String)" access="pub" jdoc="">
				<comm cntt="No DTD metadata wanted available"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.error(SAXParseException)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.startElement(String, String, String, Attributes)" access="pub" jdoc="">
				<comm cntt="Start of dataset"/>
				<comm cntt="New table"/>
				<comm cntt="If not first table, notify end of previous table to consumer"/>
				<comm cntt="In FlatXML the table might have appeared before already, so check for this"/>
				<comm cntt="Notify start of new table to consumer"/>
				<comm cntt="Row notification"/>
				<comm cntt="If we do not have a DTD"/>
				<comm cntt="Since a new MetaData object was created assign it to the local variable"/>
				<param name="uri"/>
				<param name="localName"/>
				<param name="qName"/>
				<param name="attributes"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer.endElement(String, String, String)" access="pub" jdoc="">
				<comm cntt="End of dataset"/>
				<comm cntt="Notify end of active table to consumer"/>
				<comm cntt="Notify end of dataset to consumer"/>
				<param name="uri"/>
				<param name="localName"/>
				<param name="qName"/>
			</mth>
		<class name="/:org.dbunit.dataset.xml.FlatXmlProducer$FlatDtdHandler" intfc="n" abs="n" inn="y" sloc="33" jdoc="">
			<comm cntt=""/>
			<comm cntt="LexicalHandler interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_dtdPresent" access="priv" jdoc=""/>
			<field name="xmlProducer" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer$FlatDtdHandler.FlatDtdHandler(FlatXmlProducer)" access="pub" jdoc="">
				<param name="xmlProducer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer$FlatDtdHandler.isDtdPresent()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlProducer$FlatDtdHandler.startDTD(String, String, String)" access="pub" jdoc="">
				<comm cntt="Cache the DTD content to use it as metadata"/>
				<comm cntt="Set the metaData on the xmlProducer"/>
				<param name="name"/>
				<param name="publicId"/>
				<param name="systemId"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatDtdDataSet" intfc="n" abs="n" inn="n" sloc="131" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 877 $ $Date: 2008-11-15 08:03:44 -0200 (SÃ¡b, 15 Nov 2008) $ @since 1.0 (Apr 4, 2002)">
			<comm cntt=""/>
			<comm cntt="AbstractDataSet class"/>
			<comm cntt=""/>
			<comm cntt="IDataSet interface"/>
			<comm cntt=""/>
			<comm cntt="IDataSetConsumer interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_tableMap" access="priv" jdoc=""/>
			<field name="_ready" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.FlatDtdDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.FlatDtdDataSet(InputStream)" access="pub" jdoc="">
				<param name="in"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.FlatDtdDataSet(Reader)" access="pub" jdoc="">
				<param name="reader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.FlatDtdDataSet(IDataSetProducer)" access="pub" jdoc="">
				<param name="producer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.initialize()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.write(IDataSet, OutputStream)" access="pub" jdoc="Write the specified dataset to the specified output stream as DTD. @see FlatDtdWriter">
				<param name="dataSet"/>
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.write(IDataSet, Writer)" access="pub" jdoc="Write the specified dataset to the specified writer as DTD. @see FlatDtdWriter">
				<param name="dataSet"/>
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.createIterator(boolean)" access="prot" jdoc="">
				<comm cntt="Verify producer notifications completed"/>
				<param name="reversed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.getTableNames()" access="pub" jdoc="">
				<comm cntt="Verify producer notifications completed"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.getTableMetaData(String)" access="pub" jdoc="">
				<comm cntt="Verify producer notifications completed"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.getTable(String)" access="pub" jdoc="">
				<comm cntt="Verify producer notifications completed"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.startDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.endDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.startTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.endTable()" access="pub" jdoc="">
				<comm cntt="no op"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.row(Object[])" access="pub" jdoc="">
				<comm cntt="no op"/>
				<param name="values"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatDtdDataSet.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.XmlDataSet" intfc="n" abs="n" inn="n" sloc="41" jdoc="Reads and writes original XML dataset document. This format is very verbose and must conform to the following DTD: &amp;lt;pre&amp;gt; &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;!ELEMENT dataset (table+)&amp;gt; &amp;lt;!ELEMENT table (column , row )&amp;gt; &amp;lt;!ATTLIST table name CDATA #REQUIRED&amp;gt; &amp;lt;!ELEMENT column (#PCDATA)&amp;gt; &amp;lt;!ELEMENT row (value | null | none) &amp;gt; &amp;lt;!ELEMENT value (#PCDATA)&amp;gt; &amp;lt;!ELEMENT null EMPTY&amp;gt; &amp;lt;!ELEMENT none EMPTY&amp;gt; &amp;lt; pre&amp;gt; @author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1043 $ $Date: 2009-09-24 05:26:51 -0300 (Qui, 24 Set 2009) $ @since 1.0 (Feb 17, 2002)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSet.XmlDataSet(Reader)" access="pub" jdoc="Creates an XmlDataSet with the specified xml reader.">
				<param name="reader"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSet.XmlDataSet(InputStream)" access="pub" jdoc="Creates an XmlDataSet with the specified xml input stream.">
				<param name="in"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSet.write(IDataSet, OutputStream)" access="pub" jdoc="Write the specified dataset to the specified output stream as xml.">
				<param name="dataSet"/>
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSet.write(IDataSet, OutputStream, String)" access="pub" jdoc="Write the specified dataset to the specified output stream as xml (using specified encoding).">
				<param name="dataSet"/>
				<param name="out"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSet.write(IDataSet, Writer)" access="pub" jdoc="Write the specified dataset to the specified writer as xml.">
				<param name="dataSet"/>
				<param name="writer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.XmlDataSet.write(IDataSet, Writer, String)" access="pub" jdoc="Write the specified dataset to the specified writer as xml.">
				<param name="dataSet"/>
				<param name="writer"/>
				<param name="encoding"/>
			</mth>
		</class>
		<class name="/:org.dbunit.dataset.xml.FlatXmlWriter" intfc="n" abs="n" inn="n" sloc="136" jdoc="@author Manuel Laflamme @author Last changed by: $Author: gommma $ @version $Revision: 859 $ $Date: 2008-11-02 09:50:23 -0200 (Dom, 02 Nov 2008) $ @since 1.5.5 (Apr 19, 2003)">
			<comm cntt=""/>
			<comm cntt="IDataSetConsumer interface"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATASET" access="priv" jdoc=""/>
			<field name="_xmlWriter" access="priv" jdoc=""/>
			<field name="_activeMetaData" access="priv" jdoc=""/>
			<field name="_activeRowCount" access="priv" jdoc=""/>
			<field name="_includeEmptyTable" access="priv" jdoc=""/>
			<field name="_systemId" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.FlatXmlWriter(OutputStream)" access="pub" jdoc="">
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.FlatXmlWriter(OutputStream, String)" access="pub" jdoc="@param outputStream The stream to which the XML will be written. @param encoding The encoding to be used for the {@link XmlWriter}. Can be null. See {@link XmlWriter#XmlWriter(OutputStream,String)}. @throws UnsupportedEncodingException">
				<param name="outputStream"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.FlatXmlWriter(Writer)" access="pub" jdoc="">
				<param name="writer"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.FlatXmlWriter(Writer, String)" access="pub" jdoc="">
				<param name="writer"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.setIncludeEmptyTable(boolean)" access="pub" jdoc="">
				<param name="includeEmptyTable"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.setDocType(String)" access="pub" jdoc="">
				<param name="systemId"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.setPrettyPrint(boolean)" access="pub" jdoc="Enable or disable pretty print of the XML. @param enabled &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; to enable pretty print (which is the default). &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt; otherwise. @since 2.4">
				<param name="enabled"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.write(IDataSet)" access="pub" jdoc="Writes the given {@link IDataSet} using this writer. @param dataSet The {@link IDataSet} to be written @throws DataSetException">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.startDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.endDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.startTable(ITableMetaData)" access="pub" jdoc="">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.endTable()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.dataset.xml.FlatXmlWriter.row(Object[])" access="pub" jdoc="">
				<comm cntt="Skip null value"/>
				<param name="values"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.db2">
		<class name="/:org.dbunit.ext.db2.Db2DataTypeFactory" intfc="n" abs="n" inn="n" sloc="36" jdoc="Specialized factory that recognizes DB2 data types. @author Federico Spinazzi @author Manuel Laflamme @since Jul 17, 2003 @version $Revision: 1031 $">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<const name="DB2XML_XMLVARCHAR" access="pub" jdoc=""/>
			<const name="DB2XML_XMLCLOB" access="pub" jdoc=""/>
			<const name="DB2XML_XMLFILE" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.ext.db2.Db2DataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.db2.Db2DataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.db2.Db2MetadataHandler" intfc="n" abs="n" inn="n" sloc="51" jdoc="Customized MetadataHandler for DB2 as match Columns of {@link DefaultMetadataHandler}fails with a RuntimeException. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1053 $ $Date: 2009-09-30 15:47:14 -0300 (Qua, 30 Set 2009) $ @since 2.4.7">
			<const name="logger" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ext.db2.Db2MetadataHandler.Db2MetadataHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.db2.Db2MetadataHandler.matches(ResultSet, String, String, String, String, boolean)" access="pub" jdoc="This method is overridden since - at least with DB2 driver db2jcc-9.5.jar - there is a problem that the {@link DatabaseMetaData} does not return the same values for catalog and schema like the columns {@link ResultSet} does. The debugging constellation is as follows &amp;lt;pre&amp;gt; catalog=&amp;quot;BLA&amp;quot;, catalogName=&amp;lt;null&amp;gt; schema=&amp;quot;BLA&amp;quot;, schemaName=&amp;quot;BLA&amp;quot; &amp;lt; pre&amp;gt; This problem is taken into account by this metadata handler.{@inheritDoc} @see org.dbunit.database.DefaultMetadataHandler#matches(java.sql.ResultSet,java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean)">
				<param name="columnsResultSet"/>
				<param name="catalog"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="column"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.db2.Db2MetadataHandler.areEqualIgnoreBothNull(String, String, boolean)" access="priv" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.db2.Db2MetadataHandler.areEqualIgnoreNull(String, String, boolean)" access="priv" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
				<param name="caseSensitive"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.db2.Db2Connection" intfc="n" abs="n" inn="n" sloc="11" jdoc="Database connection for DB2 that pre-configures all properties required to successfully use dbunit with DB2. @author Federico Spinazzi @author Last changed by: $Author: gommma $ @version $Revision: 1052 $ $Date: 2009-09-30 15:37:20 -0300 (Qua, 30 Set 2009) $ @since 1.5.5 (Jul 17, 2003)">
			<mth name="/:org.dbunit.ext.db2.Db2Connection.Db2Connection(Connection, String)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.h2">
		<class name="/:org.dbunit.ext.h2.H2Connection" intfc="n" abs="n" inn="n" sloc="9" jdoc="@author Felipe Leme @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since 2.2.1">
			<mth name="/:org.dbunit.ext.h2.H2Connection.H2Connection(Connection, String)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.h2.H2DataTypeFactory" intfc="n" abs="n" inn="n" sloc="19" jdoc="Specialized factory that recognizes H2 data types. @author Felipe Leme @author Last changed by: $Author: gommma $ @version $Revision: 1031 $ $Date: 2009-09-12 12:13:43 -0300 (SÃ¡b, 12 Set 2009) $ @since 2.2.1">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<mth name="/:org.dbunit.ext.h2.H2DataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.h2.H2DataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.hsqldb">
		<class name="/:org.dbunit.ext.hsqldb.HsqldbDataTypeFactory" intfc="n" abs="n" inn="n" sloc="19" jdoc="Specialized factory that recognizes HSQLDB data types. @author Klas Axell @author Last changed by: $Author: gommma $ @version $Revision: 1031 $ $Date: 2009-09-12 12:13:43 -0300 (SÃ¡b, 12 Set 2009) $ @since 2.2.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<mth name="/:org.dbunit.ext.hsqldb.HsqldbDataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.hsqldb.HsqldbDataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.hsqldb.HsqldbConnection" intfc="n" abs="n" inn="n" sloc="9" jdoc="@author Klas Axell @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since 2.2.0">
			<mth name="/:org.dbunit.ext.hsqldb.HsqldbConnection.HsqldbConnection(Connection, String)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.mckoi">
		<class name="/:org.dbunit.ext.mckoi.MckoiConnection" intfc="n" abs="n" inn="n" sloc="9" jdoc="Database connection for Mckoi that pre-configures all properties required to successfully use dbunit with Mckoi. @author Luigi Talamona (luigitalamona AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1181 $ $Date: 2010-04-17 12:25:46 -0300 (SÃ¡b, 17 Abr 2010) $ @since 2.4.8">
			<mth name="/:org.dbunit.ext.mckoi.MckoiConnection.MckoiConnection(Connection, String)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.mckoi.MckoiDataTypeFactory" intfc="n" abs="n" inn="n" sloc="43" jdoc="MckoiDataTypeFactory - This class is for the DBUnit data type factory for Mckoi database @author Luigi Talamona (luigitalamona AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1181 $ $Date: 2010-04-17 12:25:46 -0300 (SÃ¡b, 17 Abr 2010) $ @since 2.4.8">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<mth name="/:org.dbunit.ext.mckoi.MckoiDataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.mckoi.MckoiDataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.mssql">
		<class name="/:org.dbunit.ext.mssql.MsSqlDataTypeFactory" intfc="n" abs="n" inn="n" sloc="25" jdoc="Specialized factory that recognizes MS SQL Server data types. @author Manuel Laflamme @since May 19, 2003 @version $Revision: 1087 $">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<const name="NCHAR" access="pub" jdoc=""/>
			<const name="NVARCHAR" access="pub" jdoc=""/>
			<const name="NTEXT" access="pub" jdoc=""/>
			<const name="NTEXT_MSSQL_2005" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.ext.mssql.MsSqlDataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.mssql.MsSqlDataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<comm cntt="TODO : Process MS SQL Server custom datatype here"/>
				<comm cntt="nchar"/>
				<comm cntt="nvarchar"/>
				<comm cntt="ntext"/>
				<comm cntt="ntext"/>
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.mssql.MsSqlConnection" intfc="n" abs="n" inn="n" sloc="30" jdoc="@author Manuel Laflamme @since May 19, 2003 @version $Revision: 841 $">
			<comm cntt=""/>
			<comm cntt="IDatabaseConnection"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_filter" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ext.mssql.MsSqlConnection.MsSqlConnection(Connection, String)" access="pub" jdoc="Creates a new &amp;lt;code&amp;gt;MsSqlConnection&amp;lt; code&amp;gt;. @param connection the adapted JDBC connection @param schema the database schema @throws DatabaseUnitException">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.ext.mssql.MsSqlConnection.MsSqlConnection(Connection)" access="pub" jdoc="Creates a new &amp;lt;code&amp;gt;MsSqlConnection&amp;lt; code&amp;gt;. @param connection the adapted JDBC connection @throws DatabaseUnitException">
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ext.mssql.MsSqlConnection.createDataSet()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.mssql.MsSqlConnection.createDataSet(String[])" access="pub" jdoc="">
				<param name="tableNames"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.mssql.InsertIdentityOperation" intfc="n" abs="n" inn="n" sloc="121" jdoc="This class disable the MS SQL Server automatic identifier generation for the execution of inserts. &amp;lt;p&amp;gt; If you are using the Microsoft driver (i.e. &amp;lt;code&amp;gt;com.microsoft.jdbc.sqlserver.SQLServerDriver&amp;lt; code&amp;gt;), you&amp;apos;ll need to use the &amp;lt;code&amp;gt;SelectMethod=cursor&amp;lt; code&amp;gt; parameter in the JDBC connection string. Your databaseUrl would look something like the following: &amp;lt;p&amp;gt; &amp;lt;code&amp;gt;jdbc:microsoft:sqlserver: localhost:1433;DatabaseName=mydb;SelectMethod=cursor&amp;lt; code&amp;gt; &amp;lt;p&amp;gt; Thanks to Jeremy Stein who has submitted multiple patches. @author Manuel Laflamme @author Eric Pugh @author Last changed by: $Author: gommma $ @version $Revision: 934 $ $Date: 2008-12-31 20:29:25 -0200 (Qua, 31 Dez 2008) $ @since 1.4 (Apr 9, 2002)">
			<comm cntt="If &amp;quot;remarks&amp;quot; did not give the appropriate hint, check the auto-increment property"/>
			<comm cntt="TODO Should we ensure that the column is a PrimaryKey column?"/>
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="PROPERTY_IDENTITY_COLUMN_FILTER" access="pub" jdoc=""/>
			<const name="INSERT" access="pub" jdoc=""/>
			<const name="CLEAN_INSERT" access="pub" jdoc=""/>
			<const name="REFRESH" access="pub" jdoc=""/>
			<const name="DEFAULT_IDENTITY_FILTER" access="priv" jdoc=""/>
			<const name="IDENTITY_FILTER_EXTENDED" access="pub" jdoc="Accepts columns that have one of the remarks &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;GENERATED BY DEFAULT AS IDENTITY&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;GENERATED ALWAYS AS IDENTITY&amp;lt; li&amp;gt;&amp;lt; ul&amp;gt; set which is the SQL standard syntax to describe auto-generated key columns. Also accepts columns that have the auto-increment property set to &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; (note that it does not yet have the ability to check whether the column is a primary key col). @since 2.4.3"/>
			<const name="_operation" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ext.mssql.InsertIdentityOperation.InsertIdentityOperation(DatabaseOperation)" access="pub" jdoc="Creates a new InsertIdentityOperation object that decorates the specified operation.">
				<param name="operation"/>
			</mth>
			<mth name="/:org.dbunit.ext.mssql.InsertIdentityOperation.hasIdentityColumn(ITableMetaData, IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="Verify if there is at least one identity column"/>
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ext.mssql.InsertIdentityOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<comm cntt="Note that MSSQL has a different transaction strategy from oracle."/>
				<comm cntt="By default the transaction is always in &amp;quot;autocommit=true&amp;quot; so"/>
				<comm cntt="that every statement is immediately committed. If a dbunit"/>
				<comm cntt="user does not want this behavior dbunit takes it into account"/>
				<comm cntt="here."/>
				<comm cntt="INSERT_IDENTITY need to be enabled disabled inside the"/>
				<comm cntt="same transaction"/>
				<comm cntt="Execute decorated operation one table at a time"/>
				<comm cntt="enable identity insert"/>
				<comm cntt="disable identity insert"/>
				<comm cntt="Reset the autocommit property"/>
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.mysql">
		<class name="/:org.dbunit.ext.mysql.MySqlMetadataHandler" intfc="n" abs="n" inn="n" sloc="79" jdoc="Special metadata handler for MySQL.&amp;lt;br &amp;gt; Was introduced to fix &amp;quot;[ 2545095 ] Mysql FEATURE_QUALIFIED_TABLE_NAMES column SQLHelper.matches&amp;quot;. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 979 $ $Date: 2009-03-03 14:39:37 -0300 (Ter, 03 Mar 2009) $ @since 2.4.4">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.getColumns(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<comm cntt="Note that MySQL uses the catalogName instead of the schemaName, so"/>
				<comm cntt="pass in the given schema name as catalog name (first argument)."/>
				<param name="databaseMetaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.matches(ResultSet, String, String, boolean)" access="pub" jdoc="">
				<param name="resultSet"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.matches(ResultSet, String, String, String, String, boolean)" access="pub" jdoc="">
				<comm cntt="MYSQL provides only a catalog but no schema"/>
				<param name="columnsResultSet"/>
				<param name="catalog"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="column"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.areEqualIgnoreNull(String, String, boolean)" access="priv" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.getSchema(ResultSet)" access="pub" jdoc="">
				<comm cntt="Fix schema catalog for mysql. Normally the schema is not set but only the catalog is set"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.tableExists(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schema"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.getTables(DatabaseMetaData, String, String[])" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schemaName"/>
				<param name="tableType"/>
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlMetadataHandler.getPrimaryKeys(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.mysql.MySqlConnection" intfc="n" abs="n" inn="n" sloc="11" jdoc="@author manuel.laflamme @since Sep 4, 2003 @version $Revision: 953 $">
			<mth name="/:org.dbunit.ext.mysql.MySqlConnection.MySqlConnection(Connection, String)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.mysql.MySqlDataTypeFactory" intfc="n" abs="n" inn="n" sloc="40" jdoc="Specialized factory that recognizes MySql data types. @author manuel.laflamme @author Last changed by: $Author: gommma $ @version $Revision: 1031 $ $Date: 2009-09-12 12:13:43 -0300 (SÃ¡b, 12 Set 2009) $ @since 1.5 (Sep 3, 2003)">
			<const name="UNSIGNED_SUFFIX" access="pub" jdoc=""/>
			<const name="SQL_TYPE_NAME_TINYINT_UNSIGNED" access="pub" jdoc=""/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<mth name="/:org.dbunit.ext.mysql.MySqlDataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.mysql.MySqlDataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<comm cntt="CLOB"/>
				<comm cntt="MySQL 5.0 Boolean"/>
				<comm cntt="Special handling for &amp;quot;TINYINT UNSIGNED&amp;quot;"/>
				<comm cntt="It is a bit of a waste here - we could better use a &amp;quot;Short&amp;quot; instead of an &amp;quot;Integer&amp;quot; type"/>
				<comm cntt="If we have an unsigned datatype check for some specialties"/>
				<comm cntt="See http: dev.mysql.com doc refman 5.0 en connector-j-reference-type-conversions.html"/>
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.netezza">
		<class name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler" intfc="n" abs="n" inn="n" sloc="74" jdoc="Special metadata handler for Netezza. @author Ameet (amit3011 AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1035 $ $Date: 2009-09-15 14:56:59 -0300 (Ter, 15 Set 2009) $ @since 2.4.6">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.NetezzaMetadataHandler()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.getColumns(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<comm cntt="Note that Netezza uses the catalogName instead of the schemaName, so"/>
				<comm cntt="pass in the given schema name as catalog name (first argument)."/>
				<param name="databaseMetaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.matches(ResultSet, String, String, boolean)" access="pub" jdoc="">
				<param name="resultSet"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.matches(ResultSet, String, String, String, String, boolean)" access="pub" jdoc="">
				<comm cntt="Netezza provides only a catalog but no schema"/>
				<comm cntt="if (schema != null &amp;&amp; schemaName == null &amp;&amp; catalog == null &amp;&amp; catalogName != null)"/>
				<param name="columnsResultSet"/>
				<param name="catalog"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="column"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.areEqualIgnoreNull(String, String, boolean)" access="priv" jdoc="">
				<param name="value1"/>
				<param name="value2"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.getSchema(ResultSet)" access="pub" jdoc="">
				<comm cntt="Fix schema catalog for netezza. Normally the schema is not set but only the catalog is set"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.tableExists(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schema"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.getTables(DatabaseMetaData, String, String[])" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schemaName"/>
				<param name="tableType"/>
			</mth>
			<mth name="/:org.dbunit.ext.netezza.NetezzaMetadataHandler.getPrimaryKeys(DatabaseMetaData, String, String)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="schemaName"/>
				<param name="tableName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.netezza.NetezzaDataTypeFactory" intfc="n" abs="n" inn="n" sloc="77" jdoc="NetezzaDataTypeFactory - This class is for the DBUnit data type factory for Netezza database @author Ameet (amit3011 AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1035 $ $Date: 2009-09-15 14:56:59 -0300 (Ter, 15 Set 2009) $ @since 2.4.6">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="RECADDR" access="pub" jdoc=""/>
			<const name="NUMERIC" access="pub" jdoc=""/>
			<const name="DECIMAL" access="pub" jdoc=""/>
			<const name="INTEGER" access="pub" jdoc=""/>
			<const name="SMALLINT" access="pub" jdoc=""/>
			<const name="DOUBLE" access="pub" jdoc=""/>
			<const name="INTERVAL" access="pub" jdoc=""/>
			<const name="BOOLEAN" access="pub" jdoc=""/>
			<const name="CHAR" access="pub" jdoc=""/>
			<const name="FLOAT" access="pub" jdoc=""/>
			<const name="REAL" access="pub" jdoc=""/>
			<const name="VARCHAR" access="pub" jdoc=""/>
			<const name="DATE" access="pub" jdoc=""/>
			<const name="TIME" access="pub" jdoc=""/>
			<const name="TIMESTAMP" access="pub" jdoc=""/>
			<const name="TIMETZ" access="pub" jdoc=""/>
			<const name="UNKNOWN" access="pub" jdoc=""/>
			<const name="BYTEINT" access="pub" jdoc=""/>
			<const name="INT8" access="pub" jdoc=""/>
			<const name="VARFIXEDCHAR" access="pub" jdoc=""/>
			<const name="NUCL" access="pub" jdoc=""/>
			<const name="PROT" access="pub" jdoc=""/>
			<const name="BLOB" access="pub" jdoc=""/>
			<const name="BIGINT" access="pub" jdoc=""/>
			<const name="NCHAR" access="pub" jdoc=""/>
			<const name="NVARCHAR" access="pub" jdoc=""/>
			<const name="NTEXT" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.ext.netezza.NetezzaDataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.oracle">
		<class name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray" intfc="n" abs="n" inn="n" sloc="108" jdoc="This class was generated by oracle jpub. @see OracleSdoGeometryDataType @author clucas@e-miles.com @author Last changed by: $Author$ @version $Revision$ $Date$ @since ?">
			<comm cntt="constructors"/>
			<comm cntt="ORAData interface"/>
			<comm cntt="ORADataFactory interface"/>
			<comm cntt="array accessor methods"/>
			<const name="_SQL_NAME" access="pub" jdoc=""/>
			<const name="_SQL_TYPECODE" access="pub" jdoc=""/>
			<field name="_array" access="pub" jdoc=""/>
			<const name="_OracleSdoOrdinateArrayFactory" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.getORADataFactory()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.OracleSdoOrdinateArray()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.OracleSdoOrdinateArray(java.math.BigDecimal[])" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.toDatum(Connection)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.create(Datum, int)" access="pub" jdoc="">
				<param name="d"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.length()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.getBaseType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.getBaseTypeName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.getDescriptor()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.getArray()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.getArray(long, int)" access="pub" jdoc="">
				<param name="index"/>
				<param name="count"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.setArray(java.math.BigDecimal[])" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.setArray(java.math.BigDecimal[], long)" access="pub" jdoc="">
				<param name="a"/>
				<param name="index"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.getElement(long)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.setElement(java.math.BigDecimal, long)" access="pub" jdoc="">
				<param name="a"/>
				<param name="index"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoOrdinateArray.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleSdoPointType" intfc="n" abs="n" inn="n" sloc="97" jdoc="This class was generated by oracle jpub. @see OracleSdoGeometryDataType @author clucas@e-miles.com @author Last changed by: $Author$ @version $Revision$ $Date$ @since ?">
			<comm cntt="constructors"/>
			<comm cntt="ORAData interface"/>
			<comm cntt="ORADataFactory interface"/>
			<comm cntt="accessor methods"/>
			<const name="_SQL_NAME" access="pub" jdoc=""/>
			<const name="_SQL_TYPECODE" access="pub" jdoc=""/>
			<field name="_struct" access="prot" jdoc=""/>
			<field name="_sqlType" access="prot" jdoc=""/>
			<field name="_factory" access="prot" jdoc=""/>
			<const name="_OracleSdoPointTypeFactory" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.getORADataFactory()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType._init_struct(boolean)" access="prot" jdoc="">
				<param name="init"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.OracleSdoPointType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.OracleSdoPointType(java.math.BigDecimal, java.math.BigDecimal, java.math.BigDecimal)" access="pub" jdoc="">
				<param name="x"/>
				<param name="y"/>
				<param name="z"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.toDatum(Connection)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.create(Datum, int)" access="pub" jdoc="">
				<param name="d"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.create(OracleSdoPointType, Datum, int)" access="prot" jdoc="">
				<param name="o"/>
				<param name="d"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.getX()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.setX(java.math.BigDecimal)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.getY()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.setY(java.math.BigDecimal)" access="pub" jdoc="">
				<param name="y"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.getZ()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.setZ(java.math.BigDecimal)" access="pub" jdoc="">
				<param name="z"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoPointType.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleSdoGeometry" intfc="n" abs="n" inn="n" sloc="121" jdoc="This class was generated by oracle jpub. @see OracleSdoGeometryDataType @author clucas@e-miles.com @author Last changed by: $Author$ @version $Revision$ $Date$ @since ?">
			<comm cntt="constructors"/>
			<comm cntt="ORAData interface"/>
			<comm cntt="ORADataFactory interface"/>
			<comm cntt="accessor methods"/>
			<const name="_SQL_NAME" access="pub" jdoc=""/>
			<const name="_SQL_TYPECODE" access="pub" jdoc=""/>
			<field name="_struct" access="prot" jdoc=""/>
			<field name="_sqlType" access="prot" jdoc=""/>
			<field name="_factory" access="prot" jdoc=""/>
			<const name="_OracleSdoGeometryFactory" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.getORADataFactory()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry._init_struct(boolean)" access="prot" jdoc="">
				<param name="init"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.OracleSdoGeometry()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.OracleSdoGeometry(java.math.BigDecimal, java.math.BigDecimal, OracleSdoPointType, OracleSdoElemInfoArray, OracleSdoOrdinateArray)" access="pub" jdoc="">
				<param name="sdoGtype"/>
				<param name="sdoSrid"/>
				<param name="sdoPoint"/>
				<param name="sdoElemInfo"/>
				<param name="sdoOrdinates"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.toDatum(Connection)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.create(Datum, int)" access="pub" jdoc="">
				<param name="d"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.create(OracleSdoGeometry, Datum, int)" access="prot" jdoc="">
				<param name="o"/>
				<param name="d"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.getSdoGtype()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.setSdoGtype(java.math.BigDecimal)" access="pub" jdoc="">
				<param name="sdoGtype"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.getSdoSrid()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.setSdoSrid(java.math.BigDecimal)" access="pub" jdoc="">
				<param name="sdoSrid"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.getSdoPoint()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.setSdoPoint(OracleSdoPointType)" access="pub" jdoc="">
				<param name="sdoPoint"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.getSdoElemInfo()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.setSdoElemInfo(OracleSdoElemInfoArray)" access="pub" jdoc="">
				<param name="sdoElemInfo"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.getSdoOrdinates()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.setSdoOrdinates(OracleSdoOrdinateArray)" access="pub" jdoc="">
				<param name="sdoOrdinates"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometry.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleConnection" intfc="n" abs="n" inn="n" sloc="9" jdoc="@author manuel.laflamme @since Sep 3, 2003 @version $Revision: 694 $">
			<mth name="/:org.dbunit.ext.oracle.OracleConnection.OracleConnection(Connection, String)" access="pub" jdoc="Creates a oracle connection. Beware that the given schema is passed in to the parent class as &amp;quot;upper case&amp;quot; string. @param connection @param schema The schema name @throws DatabaseUnitException">
				<param name="connection"/>
				<param name="schema"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleClobDataType" intfc="n" abs="n" inn="n" sloc="61" jdoc="@author Manuel Laflamme @author Last changed by: $Author: jbhurst $ @version $Revision: 1072 $ $Date: 2009-10-12 14:46:45 -0300 (Seg, 12 Out 2009) $ @since Jan 12, 2004">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.oracle.OracleClobDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleClobDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleClobDataType.getClob(Object, Connection)" access="prot" jdoc="">
				<comm cntt="Write the data into the temporary CLOB"/>
				<comm cntt="Flush and close the stream"/>
				<comm cntt="Close the temporary CLOB"/>
				<comm cntt="JH_TODO: shouldn&amp;apos;t freeTemporary be called in finally {} ?"/>
				<comm cntt="It wasn&amp;apos;t done like that in the original reflection-styled DbUnit code."/>
				<param name="value"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleClobDataType.freeTemporaryClob(oracle.sql.CLOB)" access="prot" jdoc="">
				<param name="tempClob"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleDataTypeFactory" intfc="n" abs="n" inn="n" sloc="79" jdoc="Specialized factory that recognizes Oracle data types. @author manuel.laflamme @since Jul 17, 2003 @version $Revision: 1133 $">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<const name="ORACLE_BLOB" access="pub" jdoc=""/>
			<const name="ORACLE_CLOB" access="pub" jdoc=""/>
			<const name="ORACLE_NCLOB" access="pub" jdoc=""/>
			<const name="ORACLE_XMLTYPE" access="pub" jdoc=""/>
			<const name="ORACLE_SDO_GEOMETRY_TYPE" access="pub" jdoc=""/>
			<const name="LONG_RAW" access="pub" jdoc=""/>
			<const name="ROWID_TYPE" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.ext.oracle.OracleDataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleDataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<comm cntt="Map Oracle DATE to TIMESTAMP"/>
				<comm cntt="TIMESTAMP"/>
				<comm cntt="XMLTYPE"/>
				<comm cntt="BLOB"/>
				<comm cntt="CLOB"/>
				<comm cntt="NCLOB"/>
				<comm cntt="NVARCHAR2"/>
				<comm cntt="NCHAR"/>
				<comm cntt="FLOAT"/>
				<comm cntt="LONG RAW"/>
				<comm cntt="BINARY_DOUBLE BINARY_FLOAT"/>
				<comm cntt="Note that you have to configure your driver appropriate:"/>
				<comm cntt="Oracle-specific property to support IEEE floating-point is enabled setting the following property"/>
				<comm cntt="&amp;lt;value&amp;gt;SetFloatAndDoubleUseBinary=true&amp;lt; value&amp;gt;"/>
				<comm cntt="ROWID"/>
				<comm cntt="SDO_GEOMETRY"/>
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleXMLTypeDataType" intfc="n" abs="n" inn="n" sloc="21" jdoc="TODO UnitTests are completely missing @author Phil Barr @author Last changed by: $Author: jbhurst $ @version $Revision: 1072 $ $Date: 2009-10-12 14:46:45 -0300 (Seg, 12 Out 2009) $ @since 2.4.0">
			<mth name="/:org.dbunit.ext.oracle.OracleXMLTypeDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<comm cntt="return the byte data (using typeCast to cast it to Base64 notation)"/>
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleXMLTypeDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.Oracle10DataTypeFactory" intfc="n" abs="n" inn="n" sloc="20" jdoc="Specialized factory that recognizes Oracle data types for Oracle 10 and higher. &amp;lt;br&amp;gt; Handles the CLOBs and BLOBs as string and binary stream respectively which is supported since oracle 10. &amp;lt;br&amp;gt; This is recommended by oracle: &amp;lt;a href=&amp;quot;http: www.oracle.com technology sample_code tech java codesnippet jdbc clob10g handlingclobsinoraclejdbc10g.html&amp;quot;&amp;gt; Oracle technology sample code&amp;lt; a&amp;gt; @author gommma @since 2.3.0 @version $Revision: 730 $">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="CLOB_AS_STRING" access="prot" jdoc=""/>
			<const name="BLOB_AS_STREAM" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.ext.oracle.Oracle10DataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<comm cntt="BLOB"/>
				<comm cntt="CLOB"/>
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray" intfc="n" abs="n" inn="n" sloc="108" jdoc="This class was generated by oracle jpub. @see OracleSdoGeometryDataType @author clucas@e-miles.com @author Last changed by: $Author$ @version $Revision$ $Date$ @since ?">
			<comm cntt="constructors"/>
			<comm cntt="ORAData interface"/>
			<comm cntt="ORADataFactory interface"/>
			<comm cntt="array accessor methods"/>
			<const name="_SQL_NAME" access="pub" jdoc=""/>
			<const name="_SQL_TYPECODE" access="pub" jdoc=""/>
			<field name="_array" access="pub" jdoc=""/>
			<const name="_OracleSdoElemInfoArrayFactory" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.getORADataFactory()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.OracleSdoElemInfoArray()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.OracleSdoElemInfoArray(java.math.BigDecimal[])" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.toDatum(Connection)" access="pub" jdoc="">
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.create(Datum, int)" access="pub" jdoc="">
				<param name="d"/>
				<param name="sqlType"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.length()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.getBaseType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.getBaseTypeName()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.getDescriptor()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.getArray()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.getArray(long, int)" access="pub" jdoc="">
				<param name="index"/>
				<param name="count"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.setArray(java.math.BigDecimal[])" access="pub" jdoc="">
				<param name="a"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.setArray(java.math.BigDecimal[], long)" access="pub" jdoc="">
				<param name="a"/>
				<param name="index"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.getElement(long)" access="pub" jdoc="">
				<param name="index"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.setElement(java.math.BigDecimal, long)" access="pub" jdoc="">
				<param name="a"/>
				<param name="index"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoElemInfoArray.hashCode()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleBlobDataType" intfc="n" abs="n" inn="n" sloc="60" jdoc="@author Manuel Laflamme @author Last changed by: $Author: jbhurst $ @version $Revision: 1072 $ $Date: 2009-10-12 14:46:45 -0300 (Seg, 12 Out 2009) $ @since Feb 2, 2004">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.oracle.OracleBlobDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleBlobDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleBlobDataType.getBlob(Object, Connection)" access="priv" jdoc="">
				<comm cntt="Write the data into the temporary BLOB"/>
				<comm cntt="Flush and close the stream"/>
				<comm cntt="Close the temporary Blob"/>
				<comm cntt="JH_TODO: shouldn&amp;apos;t freeTemporary be called in finally {} ?"/>
				<comm cntt="It wasn&amp;apos;t done like that in the original reflection-styled DbUnit code."/>
				<param name="value"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleBlobDataType.freeTemporaryBlob(oracle.sql.BLOB)" access="priv" jdoc="">
				<param name="tempBlob"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleNClobDataType" intfc="n" abs="n" inn="n" sloc="13" jdoc="NCLOB handler @author cris.daniluk @author Last changed by: $Author: jbhurst $ @version $Revision: 1072 $ $Date: 2009-10-12 14:46:45 -0300 (Seg, 12 Out 2009) $ @since May 3, 2005">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.oracle.OracleNClobDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleSdoHelper" intfc="n" abs="n" inn="n" sloc="43" jdoc="This class provides some basic functionality shared among the OracleSdo objects. @author clucas@e-miles.com @author Last changed by: $Author$ @version $Revision$ $Date$ @since ?">
			<mth name="/:org.dbunit.ext.oracle.OracleSdoHelper.objectsEqual(Object, Object)" access="pub" jdoc="">
				<comm cntt="special case for BigDecimal support"/>
				<param name="object1"/>
				<param name="object2"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoHelper.objectArraysEquals(Object[], Object[])" access="pub" jdoc="">
				<param name="objects1"/>
				<param name="objects2"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoHelper.objectArrayHashCode(Object[])" access="pub" jdoc="">
				<param name="objects"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.oracle.OracleSdoGeometryDataType" intfc="n" abs="n" inn="n" sloc="216" jdoc="This class implements DataType for Oracle SDO_GEOMETRY type used in Oracle Spatial. See the Oracle Spatial Developer&amp;apos;s Guide for details on SDO_GEOMETRY. This class handles values similar to: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;SDO_GEOMETRY(NULL, NULL, NULL, NULL, NULL)&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;NULL&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;SDO_GEOMETRY(2001, 8307, SDO_POINT_TYPE(71.2988, 42.8052, NULL), NULL, NULL)&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;SDO_GEOMETRY(3302, NULL, SDO_POINT_TYPE(96.8233, 32.5261, NULL), SDO_ELEM_INFO_ARRAY(1, 2, 1), SDO_ORDINATE_ARRAY(2, 2, 0, 2, 4, 2, 8, 4, 8, 12, 4, 12, 12, 10, NULL, 8, 10, 22, 5, 14, 27))&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; &amp;lt;p&amp;gt; For more information on oracle spatial support go to http: tahiti.oracle.com and search for &amp;quot;spatial&amp;quot;. The developers guide is available at http: download.oracle.com docs cd B28359_01 appdev.111 b28400 toc.htm &amp;lt; p&amp;gt; &amp;lt;p&amp;gt; example table: &amp;lt;code&amp;gt; CREATE TABLE cola_markets ( mkt_id NUMBER PRIMARY KEY, name VARCHAR2(32), shape SDO_GEOMETRY); &amp;lt; code&amp;gt; &amp;lt; p&amp;gt; &amp;lt;p&amp;gt; example insert: &amp;lt;code&amp;gt; INSERT INTO cola_markets VALUES( 2, &amp;apos;cola_b&amp;apos;, SDO_GEOMETRY( 2003, -- two-dimensional polygon NULL, NULL, SDO_ELEM_INFO_ARRAY(1,1003,1), -- one polygon (exterior polygon ring) SDO_ORDINATE_ARRAY(5,1, 8,1, 8,6, 5,7, 5,1) ) ); &amp;lt; code&amp;gt; &amp;lt; p&amp;gt; &amp;lt;p&amp;gt; This class uses the following objects which were rendered using oracle jpub and then slightly customized to work with dbunit: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;OracleSdoGeometry - corresponds to oracle SDO_GEOMETRY data type&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;OracleSdoPointType - corresponds to oracle SDO_POINT_TYPE data type&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;OracleSdoElemInfoArray - corresponds to oracle SDO_ELEM_INFO_ARRAY data type&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;OracleSdoOridinateArray - corresponds to oracle SDO_ORDINATE_ARRAY data type&amp;lt; li&amp;gt; &amp;lt; ul&amp;gt; These classes were rendered via jpub (http: download.oracle.com otn utilities_drivers jdbc 10201 jpub_102.zip) with the following command syntax: &amp;lt;code&amp;gt; . jpub -user=YOUR_USER_ID YOUR_PASSWORD -url=YOUR_JDBC_URL -sql mdsys.sdo_geometry:OracleSdoGeometry, mdsys.sdo_point_type:OracleSdoPointType, mdsys.sdo_elem_info_array:OracleSdoElemInfoArray, mdsys.sdo_ordinate_array:OracleSdoOrdinateArray -dir=output_dir -methods=none -package=org.dbunit.ext.oracle -tostring=true &amp;lt; code&amp;gt; The equals and hashCode methods were then added so that the objects could be compared in test cases. Note that I did have to bash the jpub startup script (change classpath) because it assumes oracle 10g database but I ran it with 11g. Theoretically, this process can be repeated for other custom oracle object data types. &amp;lt; p&amp;gt; @author clucas@e-miles.com @author Last changed by: $Author$ @version $Revision$ $Date$ @since &amp;lt;dbunit-version&amp;gt;">
			<comm cntt="patterns for parsing out the various pieces of the string"/>
			<comm cntt="representation of an sdo_geometry object"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="NULL" access="priv" jdoc=""/>
			<const name="SDO_GEOMETRY" access="priv" jdoc=""/>
			<const name="sdoGeometryPattern" access="priv" jdoc=""/>
			<const name="sdoPointTypePattern" access="priv" jdoc=""/>
			<const name="sdoElemInfoArrayPattern" access="priv" jdoc=""/>
			<const name="sdoOrdinateArrayPattern" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometryDataType.OracleSdoGeometryDataType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometryDataType.typeCast(Object)" access="pub" jdoc="">
				<comm cntt="attempt to parse the SDO_GEOMETRY"/>
				<comm cntt="all upper case for parse purposes"/>
				<comm cntt="parse out sdo_geometry"/>
				<comm cntt="parse out sdo_point_type"/>
				<comm cntt="parse out sdo_elem_info_array"/>
				<comm cntt="parse out sdo_ordinate_array"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometryDataType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<comm cntt="It would be preferable to return the actual object, but there are"/>
				<comm cntt="a few dbunit issues with this:"/>
				<comm cntt=""/>
				<comm cntt="1. Dbunit does not support nulls for user defined types (at least"/>
				<comm cntt="with oracle.) PreparedStatement.setNull(int, int) is always used"/>
				<comm cntt="but PreparedStatement.setNull(int, int, String) is required"/>
				<comm cntt="for sdo_geometry (and other similar custom object types)."/>
				<comm cntt=""/>
				<comm cntt="2. Dbunit does not support rendering custom objects (such as"/>
				<comm cntt="OracleSdoGeometry) as strings."/>
				<comm cntt=""/>
				<comm cntt="So, instead we return the object as a String or &amp;quot;NULL&amp;quot;."/>
				<comm cntt="return data;"/>
				<comm cntt="return a string instead of null so that it can be interpreted"/>
				<comm cntt="in typeCast. DBUnit does not handle PreparedStatement.setNull"/>
				<comm cntt="for user defined types."/>
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometryDataType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="value"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.ext.oracle.OracleSdoGeometryDataType.compare(Object, Object)" access="pub" jdoc="This method is copied from AbstractDataType and customized to call equals after the typeCast because OracleSdoGeometry objects are not Comparables but can test for equality (via equals method.) It is needed for test cases that check for equality between data in xml files and data read from the database.">
				<comm cntt="New in 2.3: Object level check for equality - should give massive performance improvements"/>
				<comm cntt="in the most cases because the typecast can be avoided (null values and equal objects)"/>
				<comm cntt="Comparable check based on the results of method &amp;quot;typeCast&amp;quot;"/>
				<comm cntt="Check for &amp;quot;null&amp;quot;s again because typeCast can produce them"/>
				<param name="o1"/>
				<param name="o2"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.ext.postgresql">
		<class name="/:org.dbunit.ext.postgresql.PostgresqlDataTypeFactory" intfc="n" abs="n" inn="n" sloc="34" jdoc="Specialized factory that recognizes Postgresql data types. &amp;lt;p&amp;gt; Derived from work by manuel.laflamme&amp;lt; p&amp;gt; @author Jarvis Cochrane (jarvis@cochrane.com.au) @author manuel.laflamme @since 2.4.5 (Apr 27, 2009)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="DATABASE_PRODUCTS" access="priv" jdoc="Database product names supported."/>
			<mth name="/:org.dbunit.ext.postgresql.PostgresqlDataTypeFactory.getValidDbProducts()" access="pub" jdoc="@see org.dbunit.dataset.datatype.IDbProductRelatable#getValidDbProducts()">
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.PostgresqlDataTypeFactory.createDataType(int, String)" access="pub" jdoc="">
				<comm cntt="Treat Postgresql UUID types as VARCHARS"/>
				<comm cntt="Intervals are custom types"/>
				<comm cntt="Finally check whether the user defined a custom datatype"/>
				<param name="sqlType"/>
				<param name="sqlTypeName"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.PostgresqlDataTypeFactory.isEnumType(String)" access="pub" jdoc="Returns a data type for the given sql type name if the user wishes one. &amp;lt;b&amp;gt;Designed to be overridden by custom implementations extending this class.&amp;lt; b&amp;gt; Override this method if you have a custom enum type in the database and want to map it via dbunit. @param sqlTypeName The sql type name for which users can specify a custom data type. @return &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if the given type name is not a custom type which is the default implementation. @since 2.4.6">
				<param name="sqlTypeName"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.postgresql.UuidType" intfc="n" abs="n" inn="n" sloc="41" jdoc="Adapter to handle conversion between Postgresql native UUID type and Strings. @author Jarvis Cochrane (jarvis@cochrane.com.au) @author Last changed by: $Author: gommma $ @since Apr 27, 2009">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.postgresql.UuidType.UuidType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.UuidType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.UuidType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="uuid"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.UuidType.typeCast(Object)" access="pub" jdoc="">
				<param name="arg0"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.UuidType.getUUID(Object, Connection)" access="priv" jdoc="">
				<param name="value"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.postgresql.GenericEnumType" intfc="n" abs="n" inn="n" sloc="53" jdoc="Adapter to handle conversion between Postgresql native Enum type and Strings. @author Jarvis Cochrane (jarvis@cochrane.com.au) @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 1025 $ $Date: 2009-08-16 18:29:16 -0300 (Dom, 16 Ago 2009) $ @since 2.4.6">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="sqlTypeName" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.ext.postgresql.GenericEnumType.GenericEnumType(String)" access="pub" jdoc="@param sqlTypeName The name of the enum type needed to invoke the &amp;quot;setType()&amp;quot; method on the PGObject class.">
				<param name="sqlTypeName"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.GenericEnumType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.GenericEnumType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="enumObject"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.GenericEnumType.typeCast(Object)" access="pub" jdoc="">
				<param name="arg0"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.GenericEnumType.getEnum(Object, Connection)" access="priv" jdoc="">
				<param name="value"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.GenericEnumType.getSqlTypeName()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.ext.postgresql.IntervalType" intfc="n" abs="n" inn="n" sloc="36" jdoc="Adapter to handle conversion between Postgresql native Interval type and Strings. @author James A. Russo (jr@halo3.net) @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.6">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.postgresql.IntervalType.IntervalType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.IntervalType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.IntervalType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="interval"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.IntervalType.typeCast(Object)" access="pub" jdoc="">
				<param name="arg0"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.IntervalType.getInterval(Object, Connection)" access="priv" jdoc="">
				<param name="value"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.ext.postgresql.InetType" intfc="n" abs="n" inn="n" sloc="41" jdoc="Adapter to handle conversion between Postgresql native inet type and Strings. @author Angelo Dipierro (suCrabu@gmail.com)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.ext.postgresql.InetType.InetType()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.InetType.getSqlValue(int, ResultSet)" access="pub" jdoc="">
				<param name="column"/>
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.InetType.setSqlValue(Object, int, PreparedStatement)" access="pub" jdoc="">
				<param name="uuid"/>
				<param name="column"/>
				<param name="statement"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.InetType.typeCast(Object)" access="pub" jdoc="">
				<param name="arg0"/>
			</mth>
			<mth name="/:org.dbunit.ext.postgresql.InetType.getInet(Object, Connection)" access="priv" jdoc="">
				<param name="value"/>
				<param name="connection"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.operation">
		<class name="/:org.dbunit.operation.CloseConnectionOperation" intfc="n" abs="n" inn="n" sloc="22" jdoc="Decorates an operation and close the database connection after executing it. @author Manuel Laflamme @version $Revision: 675 $ @since Mar 6, 2002">
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_operation" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.operation.CloseConnectionOperation.CloseConnectionOperation(DatabaseOperation)" access="pub" jdoc="Creates a CloseConnectionOperation object that decorates the specified operation.">
				<param name="operation"/>
			</mth>
			<mth name="/:org.dbunit.operation.CloseConnectionOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.DeleteOperation" intfc="n" abs="n" inn="n" sloc="43" jdoc="Deletes only the dataset contents from the database. This operation does not delete the entire table contents but only data that are present in the dataset. @author Manuel Laflamme @version $Revision: 675 $ @since Feb 19, 2002">
			<comm cntt=""/>
			<comm cntt="AbstractBatchOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.operation.DeleteOperation.DeleteOperation()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.DeleteOperation.iterator(IDataSet)" access="prot" jdoc="">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.operation.DeleteOperation.getOperationData(ITableMetaData, BitSet, IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="cannot construct where clause if no primary key"/>
				<comm cntt="delete from"/>
				<comm cntt="where"/>
				<comm cntt="escape column name"/>
				<param name="metaData"/>
				<param name="ignoreMapping"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.CompositeOperation" intfc="n" abs="n" inn="n" sloc="31" jdoc="This class is a composite that combines multiple database operation in a single one. @author Manuel Laflamme @version $Revision: 720 $ @since Feb 18, 2002">
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_actions" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.operation.CompositeOperation.CompositeOperation(DatabaseOperation, DatabaseOperation)" access="pub" jdoc="Creates a new composite operation combining the two specified operations.">
				<param name="action1"/>
				<param name="action2"/>
			</mth>
			<mth name="/:org.dbunit.operation.CompositeOperation.CompositeOperation(DatabaseOperation[])" access="pub" jdoc="Creates a new composite operation combining the specified operations.">
				<param name="actions"/>
			</mth>
			<mth name="/:org.dbunit.operation.CompositeOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.operation.CompositeOperation.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.operation.TruncateTableOperation" intfc="n" abs="n" inn="n" sloc="27" jdoc="Truncate tables present in the specified dataset. If the dataset does not contains a particular table, but that table exists in the database, the database table is not affected. Table are truncated in reverse sequence. &amp;lt;p&amp;gt; This operation has the same effect of as {@link DeleteAllOperation}. TruncateTableOperation is faster, and it is non-logged, meaning it cannot be rollback. DeleteAllOperation is more portable because not all database vendor support TRUNCATE_TABLE TABLE statement. @author Manuel Laflamme @since Apr 10, 2003 @version $Revision: 675 $ @see DeleteAllOperation">
			<comm cntt=""/>
			<comm cntt="DeleteAllOperation class"/>
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.operation.TruncateTableOperation.TruncateTableOperation()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.TruncateTableOperation.getDeleteAllCommand()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.TruncateTableOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<comm cntt="Patch to make it work with MS SQL Server"/>
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.DeleteAllOperation" intfc="n" abs="n" inn="n" sloc="59" jdoc="Deletes all rows of tables present in the specified dataset. If the dataset does not contains a particular table, but that table exists in the database, the database table is not affected. Table are truncated in reverse sequence. &amp;lt;p &amp;gt; This operation has the same effect of as {@link TruncateTableOperation}. TruncateTableOperation is faster, and it is non-logged, meaning it cannot be rollback. DeleteAllOperation is more portable because not all database vendor support TRUNCATE_TABLE TABLE statement. @author Manuel Laflamme @version $Revision: 962 $ @see TruncateTableOperation @since Feb 18, 2002">
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.operation.DeleteAllOperation.DeleteAllOperation()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.DeleteAllOperation.getDeleteAllCommand()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.DeleteAllOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<comm cntt="delete tables once each in reverse order of seeing them."/>
				<comm cntt="Use database table name. Required to support case sensitive database."/>
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.AbstractOperation" intfc="n" abs="y" inn="n" sloc="35" jdoc="@author Manuel Laflamme @since Jan 17, 2004 @version $Revision: 953 $">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.operation.AbstractOperation.getQualifiedName(String, String, IDatabaseConnection)" access="prot" jdoc="">
				<param name="prefix"/>
				<param name="name"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.operation.AbstractOperation.getOperationMetaData(IDatabaseConnection, ITableMetaData)" access="pub" jdoc="Returns the metadata to use in this operation. It is retrieved from the database connection using the information from the physical database table. @param connection the database connection @param metaData the XML table metadata">
				<comm cntt="Check if column exists in database"/>
				<comm cntt="method &amp;quot;getColumnIndex()&amp;quot; throws NoSuchColumnsException when columns have not been found"/>
				<comm cntt="If we get here the column exists in the database"/>
				<param name="connection"/>
				<param name="metaData"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.UpdateOperation" intfc="n" abs="n" inn="n" sloc="59" jdoc="Updates the database from the dataset contents. This operation assumes that table data already exists in the database and fails if this is not the case. @author Manuel Laflamme @version $Revision: 964 $ @since Feb 19, 2002">
			<comm cntt=""/>
			<comm cntt="AbstractBatchOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.operation.UpdateOperation.UpdateOperation()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.UpdateOperation.getOperationData(ITableMetaData, BitSet, IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="cannot construct where clause if no primary key"/>
				<comm cntt="update table"/>
				<comm cntt="set"/>
				<comm cntt="set if not primary key"/>
				<comm cntt="escape column name"/>
				<comm cntt="where"/>
				<comm cntt="escape column name"/>
				<param name="metaData"/>
				<param name="ignoreMapping"/>
				<param name="connection"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.RefreshOperation" intfc="n" abs="n" inn="n" sloc="64" jdoc="This operation literally refreshes dataset contents into the database. This means that data of existing rows is updated and non-existing row get inserted. Any rows which exist in the database but not in dataset stay unaffected. @author Manuel Laflamme @version $Revision: 778 $ @since Feb 19, 2002">
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_insertOperation" access="priv" jdoc=""/>
			<const name="_updateOperation" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.operation.RefreshOperation.RefreshOperation()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation.isEmpty(ITable)" access="priv" jdoc="">
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<comm cntt="for each table"/>
				<comm cntt="Do not process empty table"/>
				<comm cntt="refresh all rows"/>
				<comm cntt="This exception occurs when records are exhausted"/>
				<comm cntt="and we reach the end of the table. Ignore this error."/>
				<comm cntt="end of table"/>
				<comm cntt="cleanup"/>
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation.createUpdateOperation(IDatabaseConnection, ITableMetaData)" access="priv" jdoc="">
				<comm cntt="update only if columns are not all primary keys"/>
				<comm cntt="otherwise, operation only verify if row exist"/>
				<param name="connection"/>
				<param name="metaData"/>
			</mth>
		<class name="/:org.dbunit.operation.RefreshOperation$RowOperation" intfc="n" abs="n" inn="y" sloc="33" jdoc="This class represents a operation executed on a single table row.">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_statement" access="prot" jdoc=""/>
			<field name="_operationData" access="prot" jdoc=""/>
			<field name="_ignoreMapping" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.operation.RefreshOperation$RowOperation.execute(ITable, int)" access="pub" jdoc="Execute this operation on the sepcified table row. @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if operation have been executed on the row.">
				<comm cntt="Bind value only if not in ignore mapping"/>
				<param name="table"/>
				<param name="row"/>
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation$RowOperation.close()" access="pub" jdoc="Cleanup this operation state.">
			</mth>
		</class>
		<class name="/:org.dbunit.operation.RefreshOperation$InsertRowOperation" intfc="n" abs="n" inn="y" sloc="32" jdoc="Insert row operation.">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_connection" access="priv" jdoc=""/>
			<field name="_metaData" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.operation.RefreshOperation$InsertRowOperation.InsertRowOperation(IDatabaseConnection, ITableMetaData)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation$InsertRowOperation.execute(ITable, int)" access="pub" jdoc="">
				<comm cntt="If current row has a different ignore value mapping than"/>
				<comm cntt="previous one, we generate a new statement"/>
				<comm cntt="Execute and close previous statement"/>
				<param name="table"/>
				<param name="row"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.RefreshOperation$UpdateRowOperation" intfc="n" abs="n" inn="y" sloc="13" jdoc="Update row operation.">
			<field name="_countStatement" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.operation.RefreshOperation$UpdateRowOperation.UpdateRowOperation(IDatabaseConnection, ITableMetaData)" access="pub" jdoc="">
				<comm cntt="setup update statement"/>
				<param name="connection"/>
				<param name="metaData"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.RefreshOperation$RowExistOperation" intfc="n" abs="n" inn="y" sloc="65" jdoc="This operation verify if a row exists in the database.">
			<comm cntt=""/>
			<comm cntt="RowOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="_countStatement" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.operation.RefreshOperation$RowExistOperation.RowExistOperation(IDatabaseConnection, ITableMetaData)" access="pub" jdoc="">
				<comm cntt="setup select count statement"/>
				<param name="connection"/>
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation$RowExistOperation.getSelectCountData(ITableMetaData, IDatabaseConnection)" access="priv" jdoc="">
				<comm cntt="cannot construct where clause if no primary key"/>
				<comm cntt="select count"/>
				<comm cntt="where"/>
				<param name="metaData"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation$RowExistOperation.execute(ITable, int)" access="pub" jdoc="Verify if the specified table row exists in the database. @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if row exists.">
				<param name="table"/>
				<param name="row"/>
			</mth>
			<mth name="/:org.dbunit.operation.RefreshOperation$RowExistOperation.close()" access="pub" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.operation.OperationData" intfc="n" abs="n" inn="n" sloc="27" jdoc="@author Manuel Laflamme @version $Revision: 770 $ @since Mar 16, 2002">
			<const name="_sql" access="priv" jdoc=""/>
			<const name="_columns" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.operation.OperationData.OperationData(String, Column[])" access="pub" jdoc="@param sql @param columns">
				<param name="sql"/>
				<param name="columns"/>
			</mth>
			<mth name="/:org.dbunit.operation.OperationData.getSql()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.OperationData.getColumns()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.OperationData.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.operation.ExclusiveTransactionException" intfc="n" abs="n" inn="n" sloc="19" jdoc="@author Manuel Laflamme @version $Revision: 676 $ @since Feb 21, 2002">
			<const name="serialVersionUID" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.operation.ExclusiveTransactionException.ExclusiveTransactionException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.ExclusiveTransactionException.ExclusiveTransactionException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.operation.ExclusiveTransactionException.ExclusiveTransactionException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.operation.ExclusiveTransactionException.ExclusiveTransactionException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.AbstractBatchOperation" intfc="n" abs="y" inn="n" sloc="122" jdoc="Base implementation for database operation that are executed in batch. @author Manuel Laflamme @version $Revision: 720 $ @since Feb 19, 2002">
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="EMPTY_BITSET" access="priv" jdoc=""/>
			<field name="_reverseRowOrder" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.operation.AbstractBatchOperation.isEmpty(ITable)" access="pub" jdoc="">
				<comm cntt="No columns = empty"/>
				<comm cntt="Try to fetch first table value"/>
				<comm cntt="Not able to access first row thus empty"/>
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.operation.AbstractBatchOperation.iterator(IDataSet)" access="prot" jdoc="Returns list of tables this operation is applied to. This method allow subclass to do filtering.">
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.operation.AbstractBatchOperation.getIgnoreMapping(ITable, int)" access="pub" jdoc="Returns mapping of columns to ignore by this operation. Each bit set represent a column to ignore.">
				<param name="table"/>
				<param name="row"/>
			</mth>
			<mth name="/:org.dbunit.operation.AbstractBatchOperation.equalsIgnoreMapping(BitSet, ITable, int)" access="pub" jdoc="Returns false if the specified table row have a different ignore mapping than the specified mapping.">
				<param name="ignoreMapping"/>
				<param name="table"/>
				<param name="row"/>
			</mth>
			<mth name="/:org.dbunit.operation.AbstractBatchOperation.getOperationData(ITableMetaData, BitSet, IDatabaseConnection)" access="pub" jdoc="">
				<param name="metaData"/>
				<param name="ignoreMapping"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.operation.AbstractBatchOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<comm cntt="for each table"/>
				<comm cntt="Do not process empty table"/>
				<comm cntt="For each row"/>
				<comm cntt="If current row have a different ignore value mapping than"/>
				<comm cntt="previous one, we generate a new statement"/>
				<comm cntt="Execute and close previous statement"/>
				<comm cntt="for each column"/>
				<comm cntt="Bind value only if not in ignore mapping"/>
				<comm cntt="This exception occurs when records are exhausted"/>
				<comm cntt="and we reach the end of the table. Ignore this error"/>
				<comm cntt="end of table"/>
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
			<mth name="/:org.dbunit.operation.AbstractBatchOperation.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.operation.DatabaseOperation" intfc="n" abs="y" inn="n" sloc="20" jdoc="Defines the interface contract for operations performed on the database. @author Manuel Laflamme @version $Revision: 810 $ @since Feb 18, 2002">
			<const name="NONE" access="pub" jdoc=""/>
			<const name="UPDATE" access="pub" jdoc=""/>
			<const name="INSERT" access="pub" jdoc=""/>
			<const name="REFRESH" access="pub" jdoc=""/>
			<const name="DELETE" access="pub" jdoc=""/>
			<const name="DELETE_ALL" access="pub" jdoc=""/>
			<const name="TRUNCATE_TABLE" access="pub" jdoc=""/>
			<const name="CLEAN_INSERT" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.operation.DatabaseOperation.TRANSACTION(DatabaseOperation)" access="pub" jdoc="">
				<param name="operation"/>
			</mth>
			<mth name="/:org.dbunit.operation.DatabaseOperation.CLOSE_CONNECTION(DatabaseOperation)" access="pub" jdoc="">
				<param name="operation"/>
			</mth>
			<mth name="/:org.dbunit.operation.DatabaseOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="Executes this operation on the specified database using the specified dataset contents. @param connection the database connection. @param dataSet the dataset to be used by this operation.">
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
		<class name="/:org.dbunit.operation.DatabaseOperation$DummyOperation" intfc="n" abs="n" inn="y" sloc="6" jdoc="">
			<mth name="/:org.dbunit.operation.DatabaseOperation$DummyOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.operation.TransactionOperation" intfc="n" abs="n" inn="n" sloc="45" jdoc="Decorates an operation and executes within the context of a transaction. @author Manuel Laflamme @version $Revision: 675 $ @since Feb 21, 2002">
			<comm cntt=""/>
			<comm cntt="DatabaseOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="_operation" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.operation.TransactionOperation.TransactionOperation(DatabaseOperation)" access="pub" jdoc="Creates a TransactionOperation that decorates the specified operation.">
				<param name="operation"/>
			</mth>
			<mth name="/:org.dbunit.operation.TransactionOperation.execute(IDatabaseConnection, IDataSet)" access="pub" jdoc="">
				<param name="connection"/>
				<param name="dataSet"/>
			</mth>
		</class>
		<class name="/:org.dbunit.operation.InsertOperation" intfc="n" abs="n" inn="n" sloc="83" jdoc="Inserts the dataset contents into the database. This operation assumes that table data does not exist in the database and fails if this is not the case. To prevent problems with foreign keys, tables must be sequenced appropriately in dataset. @author Manuel Laflamme @version $Revision: 727 $ @since Feb 18, 2002">
			<comm cntt=""/>
			<comm cntt="AbstractBatchOperation class"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.operation.InsertOperation.InsertOperation()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.operation.InsertOperation.getOperationData(ITableMetaData, BitSet, IDatabaseConnection)" access="pub" jdoc="">
				<comm cntt="insert"/>
				<comm cntt="columns"/>
				<comm cntt="escape column name"/>
				<comm cntt="values"/>
				<param name="metaData"/>
				<param name="ignoreMapping"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.operation.InsertOperation.getIgnoreMapping(ITable, int)" access="prot" jdoc="">
				<param name="table"/>
				<param name="row"/>
			</mth>
			<mth name="/:org.dbunit.operation.InsertOperation.equalsIgnoreMapping(BitSet, ITable, int)" access="prot" jdoc="">
				<param name="ignoreMapping"/>
				<param name="table"/>
				<param name="row"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.util">
		<class name="/:org.dbunit.util.QualifiedTableName" intfc="n" abs="n" inn="n" sloc="124" jdoc="Utility to parse a fully qualified table name into its components &amp;lt;i&amp;gt;schema&amp;lt; i&amp;gt; and &amp;lt;i&amp;gt;table&amp;lt; i&amp;gt;. @author gommma @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.3.0">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="schema" access="priv" jdoc=""/>
			<field name="table" access="priv" jdoc=""/>
			<field name="escapePattern" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.QualifiedTableName.QualifiedTableName(String, String)" access="pub" jdoc="Creates an object parsing the given tableName. @param tableName The table name, either qualified or unqualified. If it is qualified (like &amp;quot;MYSCHEMA.MYTABLE&amp;quot;) this schema name has precedence before the given &amp;lt;code&amp;gt;defaultSchema&amp;lt; code&amp;gt; parameter. @param defaultSchema The schema that is used when the given tableName is not fully qualified (i.e. it is not like &amp;quot;MYSCHEMA.MYTABLE&amp;quot;). Can be null">
				<param name="tableName"/>
				<param name="defaultSchema"/>
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.QualifiedTableName(String, String, String)" access="pub" jdoc="Creates an object parsing the given tableName. @param tableName The table name, either qualified or unqualified. If it is qualified (like &amp;quot;MYSCHEMA.MYTABLE&amp;quot;) this schema name has precedence before the given &amp;lt;code&amp;gt;defaultSchema&amp;lt; code&amp;gt; parameter. @param defaultSchema The schema that is used when the given tableName is not fully qualified (i.e. it is not like &amp;quot;MYSCHEMA.MYTABLE&amp;quot;). Can be null @param escapePattern The escape pattern to be applied on the prefix and the name. Can be null.">
				<param name="tableName"/>
				<param name="defaultSchema"/>
				<param name="escapePattern"/>
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.parseFullTableName(String, String)" access="priv" jdoc="Parses the given full table name into a schema name and a table name if available. If no schema is set the value of the {@link #getSchema()} is null. Sets the corresponding members of this class if found. @param fullTableName potentially fully qualified table name @param defaultSchema The schema that is used when the given tableName is not fully qualified (i.e. it is not like &amp;quot;MYSCHEMA.MYTABLE&amp;quot;). Can be null">
				<comm cntt="check if a schema is in front"/>
				<comm cntt="set schema"/>
				<comm cntt="set table name without schema"/>
				<comm cntt="No schema name found in table"/>
				<comm cntt="If the schema has not been found in the given table name"/>
				<comm cntt="(that means there is no &amp;quot;MYSCHEMA.MYTABLE&amp;quot; but only a &amp;quot;MYTABLE&amp;quot;)"/>
				<comm cntt="then set the schema to the given default schema"/>
				<param name="fullTableName"/>
				<param name="defaultSchema"/>
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.getSchema()" access="pub" jdoc="@return The schema name which can be null if no schema has been given in the constructor">
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.getTable()" access="pub" jdoc="@return The name of the plain, unqualified table">
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.getQualifiedName()" access="pub" jdoc="@return The qualified table name with the prepended schema if a schema is available">
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.getQualifiedNameIfEnabled(DatabaseConfig)" access="pub" jdoc="Returns the qualified name using the values given in the constructor. The qualified table name is &amp;lt;b&amp;gt;only&amp;lt; b&amp;gt; returned if the feature{@link DatabaseConfig#FEATURE_QUALIFIED_TABLE_NAMES} is set. Otherwise the given name is returned unqualified (i.e. without prepending the prefix schema). @return The qualified table name with the prepended schema if a schema is available. The qualified table name is &amp;lt;b&amp;gt;only&amp;lt; b&amp;gt; returned if the feature {@link DatabaseConfig#FEATURE_QUALIFIED_TABLE_NAMES} is set in the given &amp;lt;code&amp;gt;config&amp;lt; code&amp;gt;.">
				<comm cntt="return this.table;"/>
				<param name="config"/>
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.getQualifiedName(String, String, String)" access="priv" jdoc="Returns the specified name qualified with the specified prefix. The name is not modified if the prefix is &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; or if the name is already qualified. &amp;lt;p&amp;gt; Example: &amp;lt;br&amp;gt; &amp;lt;code&amp;gt;getQualifiedName(null, &amp;quot;NAME&amp;quot;)&amp;lt; code&amp;gt; returns &amp;lt;code&amp;gt;&amp;quot;NAME&amp;quot;&amp;lt; code&amp;gt;. &amp;lt;code&amp;gt;getQualifiedName(&amp;quot;PREFIX&amp;quot;, &amp;quot;NAME&amp;quot;)&amp;lt; code&amp;gt; returns &amp;lt;code&amp;gt;&amp;quot;PREFIX.NAME&amp;quot;&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;getQualifiedName(&amp;quot;PREFIX2&amp;quot;, &amp;quot;PREFIX1.NAME&amp;quot;)&amp;lt; code&amp;gt; returns &amp;lt;code&amp;gt;&amp;quot;PREFIX1.NAME&amp;quot;&amp;lt; code&amp;gt;. @param prefix the prefix that qualifies the name and is prepended if the name is not qualified yet @param name the name The name to be qualified if it is not qualified already @param escapePattern The escape pattern to be applied on the prefix and the name. Can be null. @return The qualified name">
				<param name="prefix"/>
				<param name="name"/>
				<param name="escapePattern"/>
			</mth>
			<mth name="/:org.dbunit.util.QualifiedTableName.getEscapedName(String, String)" access="priv" jdoc="@param name @param escapePattern @return">
				<comm cntt="No &amp;quot;?&amp;quot; in the escape pattern and only one character."/>
				<comm cntt="use the given escapePattern to surround the given name"/>
				<param name="name"/>
				<param name="escapePattern"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.CollectionsHelper" intfc="n" abs="n" inn="n" sloc="34" jdoc="Helper for collections-related methods. &amp;lt;br&amp;gt; @author Felipe Leme (dbunit@felipeal.net) @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 797 $ $Date: 2008-08-29 05:38:12 -0300 (Sex, 29 Ago 2008) $ @since Nov 5, 2005">
			<comm cntt="class is &amp;quot;static&amp;quot;"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.util.CollectionsHelper.CollectionsHelper()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.CollectionsHelper.objectsToSet(Object[])" access="pub" jdoc="Returns a Set from an array of objects. Note the Iterator returned by this Set preserves the order of the array. @param objects array of objects @return Set with the elements of the array or null if entry is null">
				<param name="objects"/>
			</mth>
			<mth name="/:org.dbunit.util.CollectionsHelper.setToObjects(Set)" access="pub" jdoc="Returns an array of Objects from a Set. @param set a Set @return array of Objects with the elements of the Set or null if set is null">
				<param name="set"/>
			</mth>
			<mth name="/:org.dbunit.util.CollectionsHelper.setToStrings(Set)" access="pub" jdoc="Returns an array of Strings from a Set. @param set a Set of Strings @return array of Strings with the elements of the Set or null if set is null">
				<param name="set"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.Base64" intfc="n" abs="n" inn="n" sloc="350" jdoc="&amp;lt;p&amp;gt; I am placing this code in the Public Domain. Do with it as you will. This software comes with no guarantees or warranties but with plenty of well-wishing instead! Please visit &amp;lt;a href=&amp;quot;http: iharder.net base64&amp;quot;&amp;gt;http: iharder.net base64&amp;lt; a&amp;gt; periodically to check for updates or to contribute improvements. &amp;lt; p&amp;gt; @author Robert Harder (rharder@usa.net) @author Last changed by: $Author: gommma $ @version $Revision: 769 $ $Date: 2008-08-02 04:31:15 -0300 (SÃ¡b, 02 Ago 2008) $ @since 1.3">
			<comm cntt="Decimal 0 - 8"/>
			<comm cntt="Whitespace: Tab and Linefeed"/>
			<comm cntt="Decimal 11 - 12"/>
			<comm cntt="Whitespace: Carriage Return"/>
			<comm cntt="Decimal 14 - 26"/>
			<comm cntt="Decimal 27 - 31"/>
			<comm cntt="Whitespace: Space"/>
			<comm cntt="Decimal 33 - 42"/>
			<comm cntt="Plus sign at decimal 43"/>
			<comm cntt="Decimal 44 - 46"/>
			<comm cntt="Slash at decimal 47"/>
			<comm cntt="Numbers zero through nine"/>
			<comm cntt="Decimal 58 - 60"/>
			<comm cntt="Equals sign at decimal 61"/>
			<comm cntt="Decimal 62 - 64"/>
			<comm cntt="Letters &amp;apos;A&amp;apos; through &amp;apos;N&amp;apos;"/>
			<comm cntt="Letters &amp;apos;O&amp;apos; through &amp;apos;Z&amp;apos;"/>
			<comm cntt="Decimal 91 - 96"/>
			<comm cntt="Letters &amp;apos;a&amp;apos; through &amp;apos;m&amp;apos;"/>
			<comm cntt="Letters &amp;apos;n&amp;apos; through &amp;apos;z&amp;apos;"/>
			<comm cntt="Decimal 123 - 126"/>
			<comm cntt=",-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 179 - 191 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 Decimal 244 - 255"/>
			<comm cntt="Indicates error in encoding"/>
			<comm cntt="Indicates white space in encoding"/>
			<comm cntt="Indicates equals sign in encoding"/>
			<comm cntt="E N C O D I N G M E T H O D S"/>
			<comm cntt="end encodeToBytes"/>
			<comm cntt="end encode3to4"/>
			<comm cntt="end encode"/>
			<comm cntt="end encodeBytes"/>
			<comm cntt="end encodeBytes"/>
			<comm cntt="end encodeString"/>
			<comm cntt="D E C O D I N G M E T H O D S"/>
			<comm cntt="end decodeToBytes"/>
			<comm cntt="end decode"/>
			<comm cntt="end decodeToString"/>
			<comm cntt="end decodeObject"/>
			<comm cntt="end decode"/>
			<comm cntt="I N N E R C L A S S I N P U T S T R E A M"/>
			<comm cntt="end inner class InputStream"/>
			<comm cntt="I N N E R C L A S S O U T P U T S T R E A M"/>
			<comm cntt="end inner class OutputStream"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="ENCODE" access="pub" jdoc="Specify encoding (value is &amp;lt;tt&amp;gt;true&amp;lt; tt&amp;gt;)."/>
			<const name="DECODE" access="pub" jdoc="Specify decoding (value is &amp;lt;tt&amp;gt;false&amp;lt; tt&amp;gt;)."/>
			<const name="MAX_LINE_LENGTH" access="priv" jdoc="Maximum line length (76) of Base64 output."/>
			<const name="EQUALS_SIGN" access="priv" jdoc="The equals sign (=) as a byte."/>
			<const name="NEW_LINE" access="priv" jdoc="The new line character (\n) as a byte."/>
			<const name="ALPHABET" access="priv" jdoc="The 64 valid Base64 values."/>
			<const name="DECODABET" access="priv" jdoc="Translates a Base64 value to either its 6-bit reconstruction value or a negative number indicating some other meaning."/>
			<const name="BAD_ENCODING" access="priv" jdoc=""/>
			<const name="WHITE_SPACE_ENC" access="priv" jdoc=""/>
			<const name="EQUALS_SIGN_ENC" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.Base64.Base64()" access="priv" jdoc="Defeats instantiation.">
			</mth>
			<mth name="/:org.dbunit.util.Base64.main(String[])" access="pub" jdoc="Testing.">
				<comm cntt="s = System.getProperties().toString();"/>
				<comm cntt="System.out.println( s + &amp;quot;: \n [&amp;quot; + encode( s ) + &amp;quot;]\n [&amp;quot; + decode(encode(s)) + &amp;quot;]&amp;quot; );"/>
				<comm cntt="System.out.print( new String( &amp;quot;&amp;quot;+(char)ib ) );"/>
				<comm cntt="end try"/>
				<param name="args"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.encode3to4(byte[])" access="priv" jdoc="Encodes the first three bytes of array &amp;lt;var&amp;gt;threeBytes&amp;lt; var&amp;gt; and returns a four-byte array in Base64 notation. @param threeBytes the array to convert @return four byte array in Base64 notation. @since 1.3">
				<param name="threeBytes"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.encode3to4(byte[], int)" access="priv" jdoc="Encodes up to the first three bytes of array &amp;lt;var&amp;gt;threeBytes&amp;lt; var&amp;gt; and returns a four-byte array in Base64 notation. The actual number of significant bytes in your array is given by &amp;lt;var&amp;gt;numSigBytes&amp;lt; var&amp;gt;. The array &amp;lt;var&amp;gt;threeBytes&amp;lt; var&amp;gt; needs only be as big as &amp;lt;var&amp;gt;numSigBytes&amp;lt; var&amp;gt;. @param threeBytes the array to convert @param numSigBytes the number of significant bytes in your array @return four byte array in Base64 notation. @since 1.3">
				<param name="threeBytes"/>
				<param name="numSigBytes"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.encode3to4(byte[], int, int, byte[], int)" access="priv" jdoc="Encodes up to three bytes of the array &amp;lt;var&amp;gt;source&amp;lt; var&amp;gt; and writes the resulting four Base64 bytes to &amp;lt;var&amp;gt;destination&amp;lt; var&amp;gt;. The source and destination arrays can be manipulated anywhere along their length by specifying &amp;lt;var&amp;gt;srcOffset&amp;lt; var&amp;gt; and &amp;lt;var&amp;gt;destOffset&amp;lt; var&amp;gt;. This method does not check to make sure your arrays are large enough to accomodate &amp;lt;var&amp;gt;srcOffset&amp;lt; var&amp;gt; + 3 for the &amp;lt;var&amp;gt;source&amp;lt; var&amp;gt; array or &amp;lt;var&amp;gt;destOffset&amp;lt; var&amp;gt; + 4 for the &amp;lt;var&amp;gt;destination&amp;lt; var&amp;gt; array. The actual number of significant bytes in your array is given by &amp;lt;var&amp;gt;numSigBytes&amp;lt; var&amp;gt;. @param source the array to convert @param srcOffset the index where conversion begins @param numSigBytes the number of significant bytes in your array @param destination the array to hold the conversion @param destOffset the index where output will be put @return the &amp;lt;var&amp;gt;destination&amp;lt; var&amp;gt; array @since 1.3">
				<comm cntt="1 2 3"/>
				<comm cntt="01234567890123456789012345678901 Bit position"/>
				<comm cntt="--------000000001111111122222222 Array position from threeBytes"/>
				<comm cntt="--------| || || || | Six bit groups to index ALPHABET"/>
				<comm cntt="&amp;gt;&amp;gt;18 &amp;gt;&amp;gt;12 &amp;gt;&amp;gt; 6 &amp;gt;&amp;gt; 0 Right shift necessary"/>
				<comm cntt="0x3f 0x3f 0x3f Additional AND"/>
				<comm cntt="Create buffer with zero-padding if there are only one or two"/>
				<comm cntt="significant bytes passed in the array."/>
				<comm cntt="We have to shift left 24 in order to flush out the 1&amp;apos;s that appear"/>
				<comm cntt="when Java treats a value as negative that is cast from a byte to an int."/>
				<comm cntt="end switch"/>
				<param name="source"/>
				<param name="srcOffset"/>
				<param name="numSigBytes"/>
				<param name="destination"/>
				<param name="destOffset"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.encodeObject(java.io.Serializable)" access="pub" jdoc="Serializes an object and returns the Base64-encoded version of that serialized object. If the object cannot be serialized or there is another error, the method will return &amp;lt;tt&amp;gt;null&amp;lt; tt&amp;gt;. @param serializableObject The object to encode @return The Base64-encoded object @since 1.4">
				<comm cntt="end try"/>
				<comm cntt="end catch"/>
				<comm cntt="end finally"/>
				<param name="serializableObject"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.encodeBytes(byte[])" access="pub" jdoc="Encodes a byte array into Base64 notation. Equivalen to calling &amp;lt;code&amp;gt;encodeBytes( source, 0, source.length )&amp;lt; code&amp;gt; @param source The data to convert @since 1.4">
				<param name="source"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.encodeBytes(byte[], int, int)" access="pub" jdoc="Encodes a byte array into Base64 notation. @param source The data to convert @param off Offset in array where conversion should begin @param len Length of data to convert @since 1.4">
				<comm cntt="Main 4:3"/>
				<comm cntt="Account for padding"/>
				<comm cntt="New lines"/>
				<comm cntt="end if: end of line"/>
				<comm cntt="en dfor: each piece of array"/>
				<comm cntt="end if: some padding needed"/>
				<param name="source"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.encodeString(String)" access="pub" jdoc="Encodes a string in Base64 notation with line breaks after every 75 Base64 characters. @param s the string to encode @return the encoded string @since 1.3">
				<param name="s"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.decode4to3(byte[])" access="priv" jdoc="Decodes the first four bytes of array &amp;lt;var&amp;gt;fourBytes&amp;lt; var&amp;gt; and returns an array up to three bytes long with the decoded values. @param fourBytes the array with Base64 content @return array with decoded values @since 1.3">
				<param name="fourBytes"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.decode4to3(byte[], int, byte[], int)" access="priv" jdoc="Decodes four bytes from array &amp;lt;var&amp;gt;source&amp;lt; var&amp;gt; and writes the resulting bytes (up to three of them) to &amp;lt;var&amp;gt;destination&amp;lt; var&amp;gt;. The source and destination arrays can be manipulated anywhere along their length by specifying &amp;lt;var&amp;gt;srcOffset&amp;lt; var&amp;gt; and &amp;lt;var&amp;gt;destOffset&amp;lt; var&amp;gt;. This method does not check to make sure your arrays are large enough to accomodate &amp;lt;var&amp;gt;srcOffset&amp;lt; var&amp;gt; + 4 for the &amp;lt;var&amp;gt;source&amp;lt; var&amp;gt; array or &amp;lt;var&amp;gt;destOffset&amp;lt; var&amp;gt; + 3 for the &amp;lt;var&amp;gt;destination&amp;lt; var&amp;gt; array. This method returns the actual number of bytes that were converted from the Base64 encoding. @param source the array to convert @param srcOffset the index where conversion begins @param destination the array to hold the conversion @param destOffset the index where output will be put @return the number of decoded bytes converted @since 1.3">
				<comm cntt="Example: Dk=="/>
				<comm cntt="Example: DkL="/>
				<comm cntt="Example: DkLE"/>
				<param name="source"/>
				<param name="srcOffset"/>
				<param name="destination"/>
				<param name="destOffset"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.decode(String)" access="pub" jdoc="Decodes data from Base64 notation. @param s the string to decode @return the decoded data @since 1.4">
				<param name="s"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.decodeToString(String)" access="pub" jdoc="Decodes data from Base64 notation and returns it as a string. Equivalent to calling &amp;lt;code&amp;gt;new String( decode( s ) )&amp;lt; code&amp;gt; @param s the string to decode @return The data as a string @since 1.4">
				<param name="s"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.decodeToObject(String)" access="pub" jdoc="Attempts to decode Base64 data and deserialize a Java Object within. Returns &amp;lt;tt&amp;gt;null&amp;lt; tt&amp;gt; if there was an error. @param encodedObject The Base64 data to decode @return The decoded and deserialized object @since 1.4">
				<comm cntt="end try"/>
				<comm cntt="end catch"/>
				<comm cntt="end catch"/>
				<comm cntt="end finally"/>
				<param name="encodedObject"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64.decode(byte[], int, int)" access="pub" jdoc="Decodes Base64 content in byte array format and returns the decoded byte array. @param source The Base64 encoded data @param off The offset of where to begin decoding @param len The length of characters to decode @return decoded data @since 1.3">
				<comm cntt="Upper limit on size of output"/>
				<comm cntt="Only the low seven bits"/>
				<comm cntt="White space, Equals sign or better"/>
				<comm cntt="If that was the equals sign, break out of &amp;apos;for&amp;apos; loop"/>
				<comm cntt="end if: quartet built"/>
				<comm cntt="end if: equals sign or better"/>
				<comm cntt="end if: white space, equals sign or better"/>
				<comm cntt="end else:"/>
				<comm cntt="each input character"/>
				<param name="source"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
		<class name="/:org.dbunit.util.Base64$InputStream" intfc="n" abs="n" inn="y" sloc="104" jdoc="A {@link Base64.InputStream} will read data from another{@link java.io.InputStream}, given in the constructor, and encode decode to from Base64 notation on the fly. @see Base64 @see java.io.FilterInputStream @since 1.3">
			<comm cntt="Encoding or decoding"/>
			<comm cntt="Current position in the buffer"/>
			<comm cntt="Small buffer holding converted data"/>
			<comm cntt="Length of buffer (3 or 4)"/>
			<comm cntt="Number of meaningful bytes in the buffer"/>
			<comm cntt="end constructor"/>
			<comm cntt="end constructor"/>
			<comm cntt="end read"/>
			<comm cntt="end read"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="encode" access="priv" jdoc=""/>
			<field name="position" access="priv" jdoc=""/>
			<field name="buffer" access="priv" jdoc=""/>
			<field name="bufferLength" access="priv" jdoc=""/>
			<field name="numSigBytes" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.Base64$InputStream.InputStream(java.io.InputStream)" access="pub" jdoc="Constructs a {@link Base64.InputStream} in DECODE mode. @param in the {@link java.io.InputStream} from which to read data. @since 1.3">
				<param name="in"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$InputStream.InputStream(java.io.InputStream, boolean)" access="pub" jdoc="Constructs a {@link Base64.InputStream} in either ENCODE or DECODE mode. @param in the {@link java.io.InputStream} from which to read data. @param encode Conversion direction @see Base64#ENCODE @see Base64#DECODE @since 1.3">
				<param name="in"/>
				<param name="encode"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$InputStream.read()" access="pub" jdoc="Reads enough of the input stream to convert to from Base64 and returns the next byte. @return next byte @since 1.3">
				<comm cntt="Do we need to get data?"/>
				<comm cntt="If end of stream, b is -1."/>
				<comm cntt="end if: not end of stream"/>
				<comm cntt="end try: read"/>
				<comm cntt="Only a problem if we got no data at all."/>
				<comm cntt="end catch"/>
				<comm cntt="end for: each needed input byte"/>
				<comm cntt="end if: got data"/>
				<comm cntt="end if: encoding"/>
				<comm cntt="Else decoding"/>
				<comm cntt="Reads a -1 if end of stream"/>
				<comm cntt="end for: each needed input byte"/>
				<comm cntt="end if: got four characters"/>
				<comm cntt="end else: decode"/>
				<comm cntt="end else: get data"/>
				<comm cntt="Got data?"/>
				<comm cntt="End of relevant data?"/>
				<comm cntt="end if: position &amp;gt;= 0"/>
				<comm cntt="Else error"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$InputStream.read(byte[], int, int)" access="pub" jdoc="Calls {@link #read} repeatedly until the end of stream is reached or &amp;lt;var&amp;gt;len&amp;lt; var&amp;gt; bytes are read. Returns number of bytes read into array or -1 if end of stream is encountered. @param dest array to hold values @param off offset for array @param len max number of bytes to read into array @return bytes read into array or -1 if end of stream is encountered. @since 1.3">
				<comm cntt="end for: each byte read"/>
				<param name="dest"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.Base64$OutputStream" intfc="n" abs="n" inn="y" sloc="79" jdoc="A {@link Base64.OutputStream} will write data to another{@link java.io.OutputStream}, given in the constructor, and encode decode to from Base64 notation on the fly. @see Base64 @see java.io.FilterOutputStream @since 1.3">
			<comm cntt="end constructor"/>
			<comm cntt="end constructor"/>
			<comm cntt="end write"/>
			<comm cntt="end write"/>
			<comm cntt="end flush"/>
			<comm cntt="end close"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="encode" access="priv" jdoc=""/>
			<field name="position" access="priv" jdoc=""/>
			<field name="buffer" access="priv" jdoc=""/>
			<field name="bufferLength" access="priv" jdoc=""/>
			<field name="lineLength" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.Base64$OutputStream.OutputStream(java.io.OutputStream)" access="pub" jdoc="Constructs a {@link Base64.OutputStream} in ENCODE mode. @param out the {@link java.io.OutputStream} to which data will be written. @since 1.3">
				<param name="out"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$OutputStream.OutputStream(java.io.OutputStream, boolean)" access="pub" jdoc="Constructs a {@link Base64.OutputStream} in either ENCODE or DECODE mode. @param out the {@link java.io.OutputStream} to which data will be written. @param encode Conversion direction @see Base64#ENCODE @see Base64#DECODE @since 1.3">
				<param name="out"/>
				<param name="encode"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$OutputStream.write(int)" access="pub" jdoc="Writes the byte to the output stream after converting to from Base64 notation. When encoding, bytes are buffered three at a time before the output stream actually gets a write() call. When decoding, bytes are buffered four at a time. @param theByte the byte to write @since 1.3">
				<comm cntt="end if: end o fline"/>
				<comm cntt="end if: encoding"/>
				<comm cntt="end if: convert and flush"/>
				<param name="theByte"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$OutputStream.write(byte[], int, int)" access="pub" jdoc="Calls {@link #write} repeatedly until &amp;lt;var&amp;gt;len&amp;lt; var&amp;gt; bytes are written. @param theBytes array from which to read bytes @param off offset for array @param len max number of bytes to read into array @since 1.3">
				<comm cntt="end for: each byte written"/>
				<param name="theBytes"/>
				<param name="off"/>
				<param name="len"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$OutputStream.flush()" access="pub" jdoc="Appropriately pads Base64 notation when encoding or throws an exception if Base64 input is not properly padded when decoding. @since 1.3">
				<comm cntt="end if: encoding"/>
				<comm cntt="end else: decoding"/>
				<comm cntt="end if: buffer partially full"/>
			</mth>
			<mth name="/:org.dbunit.util.Base64$OutputStream.close()" access="pub" jdoc="Flushes and closes stream. @since 1.3">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.util.SQLHelper" intfc="n" abs="n" inn="n" sloc="373" jdoc="Helper for SQL-related stuff. &amp;lt;br&amp;gt; TODO: testcases, also think about refactoring so that methods are not static anymore (for better extensibility) @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 1134 $ @since Nov 5, 2005">
			<comm cntt="class is &amp;quot;static&amp;quot;"/>
			<const name="DB_PRODUCT_SYBASE" access="pub" jdoc="The database product name reported by Sybase JDBC drivers."/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<mth name="/:org.dbunit.util.SQLHelper.SQLHelper()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.getPrimaryKeyColumn(Connection, String)" access="pub" jdoc="Gets the primary column for a table. @param conn connection with the database @param table table name @return name of primary column for a table (assuming it&amp;apos;s just 1 column). @throws SQLException raised while getting the meta data">
				<param name="conn"/>
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.close(ResultSet, Statement)" access="pub" jdoc="Close a result set and a prepared statement, checking for null references. @param rs result set to be closed @param stmt prepared statement to be closed @throws SQLException exception raised in either close() method">
				<param name="rs"/>
				<param name="stmt"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.close(Statement)" access="pub" jdoc="Close a SQL statement, checking for null references. @param stmt statement to be closed @throws SQLException exception raised while closing the statement">
				<param name="stmt"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.close(ResultSet)" access="pub" jdoc="Closes the given result set in a null-safe way @param resultSet @throws SQLException">
				<param name="resultSet"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.schemaExists(Connection, String)" access="pub" jdoc="Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the given schema exists for the given connection. @param connection The connection to a database @param schema The schema to be searched @return Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the given schema exists for the given connection. @throws SQLException @since 2.3.0">
				<comm cntt="null, schemaPattern);"/>
				<comm cntt="Especially for MySQL check the catalog"/>
				<param name="connection"/>
				<param name="schema"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.catalogExists(Connection, String)" access="priv" jdoc="Checks via {@link DatabaseMetaData#getCatalogs()} whether or not the given catalog exists. @param connection @param catalog @return @throws SQLException @since 2.4.4">
				<param name="connection"/>
				<param name="catalog"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.tableExists(DatabaseMetaData, String, String)" access="pub" jdoc="Checks if the given table exists. @param metaData The database meta data @param schema The schema in which the table should be searched. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; the schema is not used to narrow the table name. @param tableName The table name to be searched @return Returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the given table exists in the given schema. Else returns &amp;lt;code&amp;gt;false&amp;lt; code&amp;gt;. @throws SQLException @since 2.3.0 @deprecated since 2.4.5 - use {@link IMetadataHandler#tableExists(DatabaseMetaData,String,String)}">
				<param name="metaData"/>
				<param name="schema"/>
				<param name="tableName"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.printAllTables(DatabaseMetaData, PrintStream)" access="pub" jdoc="Utility method for debugging to print all tables of the given metadata on the given stream @param metaData @param outputStream @throws SQLException">
				<comm cntt="Print the info"/>
				<param name="metaData"/>
				<param name="outputStream"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.getDatabaseInfo(DatabaseMetaData)" access="pub" jdoc="Returns the database and JDBC driver information as pretty formatted string @param metaData The JDBC database metadata needed to retrieve database information @return The database information as formatted string">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.printDatabaseInfo(DatabaseMetaData, PrintStream)" access="pub" jdoc="Prints the database and JDBC driver information to the given output stream @param metaData The JDBC database metadata needed to retrieve database information @param outputStream The stream to which the information is printed @throws SQLException">
				<param name="metaData"/>
				<param name="outputStream"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.isSybaseDb(DatabaseMetaData)" access="pub" jdoc="Detects whether or not the given metadata describes the connection to a Sybase database or not. @param metaData The metadata to be checked whether it is a Sybase connection @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if and only if the given metadata belongs to a Sybase database. @throws SQLException">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.createColumn(ResultSet, IDataTypeFactory, boolean)" access="pub" jdoc="Utility method to create a {@link Column} object from a SQL {@link ResultSet} object. @param resultSet A result set produced via {@link DatabaseMetaData#getColumns(String,String,String,String)} @param dataTypeFactory The factory used to lookup the {@link DataType} for this column @param datatypeWarning Whether or not a warning should be printed if the column could not be created because of an unknown datatype. @return The {@link Column} or &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; if the column could not be initialized because of an unknown datatype. @throws SQLException @throws DataTypeException @since 2.4.0">
				<comm cntt="If Types.DISTINCT like SQL DOMAIN, then get Source Date Type of SQL-DOMAIN"/>
				<comm cntt="int columnSize = resultSet.getInt(7);"/>
				<comm cntt="This is only available since Java 5 - so we ca try it and if it does not work default it"/>
				<comm cntt="Ignore this one here"/>
				<comm cntt="Convert SQL type to DataType"/>
				<comm cntt="datatype unknown - column not created"/>
				<param name="resultSet"/>
				<param name="dataTypeFactory"/>
				<param name="datatypeWarning"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.matches(ResultSet, String, String, boolean)" access="pub" jdoc="Checks if the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table name. The comparison is &amp;lt;b&amp;gt;case sensitive&amp;lt; b&amp;gt;. @param resultSet A result set produced via {@link DatabaseMetaData#getColumns(String,String,String,String)} @param schema The name of the schema to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param table The name of the table to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param caseSensitive Whether or not the comparison should be case sensitive or not @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the column metadata of the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table parameters. @throws SQLException @since 2.4.0 @deprecated since 2.4.4 - use {@link IMetadataHandler#matches(ResultSet,String,String,String,String,boolean)}">
				<param name="resultSet"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.matches(ResultSet, String, String, String, String, boolean)" access="pub" jdoc="Checks if the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table name. The comparison is &amp;lt;b&amp;gt;case sensitive&amp;lt; b&amp;gt;. @param resultSet A result set produced via {@link DatabaseMetaData#getColumns(String,String,String,String)} @param catalog The name of the catalog to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param schema The name of the schema to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param table The name of the table to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param column The name of the column to check. If &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; it is ignored in the comparison @param caseSensitive Whether or not the comparison should be case sensitive or not @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the column metadata of the given &amp;lt;code&amp;gt;resultSet&amp;lt; code&amp;gt; matches the given schema and table parameters. @throws SQLException @since 2.4.0 @deprecated since 2.4.4 - use {@link IMetadataHandler#matches(ResultSet,String,String,String,String,boolean)}">
				<comm cntt="MYSQL provides only a catalog but no schema"/>
				<param name="resultSet"/>
				<param name="catalog"/>
				<param name="schema"/>
				<param name="table"/>
				<param name="column"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.areEqualIgnoreNull(String, String, boolean)" access="pub" jdoc="Compares the given values and returns true if they are equal. If the first value is &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; or empty String it always returns &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; which is the way of ignoring &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;s for this specific case. @param value1 The first value to compare. Is ignored if null or empty String @param value2 The second value to be compared @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if both values are equal or if the first value is &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; or empty string. @since 2.4.4">
				<param name="value1"/>
				<param name="value2"/>
				<param name="caseSensitive"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.correctCase(String, Connection)" access="pub" jdoc="Corrects the case of the given String according to the way in which the database stores metadata. @param databaseIdentifier A database identifier such as a table name or a schema name for which the case should be corrected. @param connection The connection used to lookup the database metadata. This is needed to determine the way in which the database stores its metadata. @return The database identifier in the correct case for the RDBMS @since 2.4.4">
				<param name="databaseIdentifier"/>
				<param name="connection"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.correctCase(String, DatabaseMetaData)" access="pub" jdoc="Corrects the case of the given String according to the way in which the database stores metadata. @param databaseIdentifier A database identifier such as a table name or a schema name for which the case should be corrected. @param databaseMetaData The database metadata needed to determine the way in which the database stores its metadata. @return The database identifier in the correct case for the RDBMS @since 2.4.4">
				<param name="databaseIdentifier"/>
				<param name="databaseMetaData"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.logInfoIfValueChanged(String, String, String, Class)" access="pub" jdoc="Checks whether two given values are unequal and if so print a log message (level DEBUG) @param oldValue The old value of a property @param newValue The new value of a property @param message The message to be logged @param source The class which invokes this method - used for enriching the log message @since 2.4.4">
				<param name="oldValue"/>
				<param name="newValue"/>
				<param name="message"/>
				<param name="source"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.logDebugIfValueChanged(String, String, String, Class)" access="pub" jdoc="Checks whether two given values are unequal and if so print a log message (level DEBUG) @param oldValue The old value of a property @param newValue The new value of a property @param message The message to be logged @param source The class which invokes this method - used for enriching the log message @since 2.4.8">
				<param name="oldValue"/>
				<param name="newValue"/>
				<param name="message"/>
				<param name="source"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper.isEscaped(String, String)" access="priv" jdoc="@param tableName @param dbIdentifierQuoteString @return @since 2.4.4">
				<param name="tableName"/>
				<param name="dbIdentifierQuoteString"/>
			</mth>
		<class name="/:org.dbunit.util.SQLHelper$ExceptionWrapper" intfc="n" abs="y" inn="y" sloc="17" jdoc="Performs a method invocation and catches all exceptions that occur during the invocation. Utility which works similar to a closure, just a bit less elegant. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: jbhurst $ @version $Revision: 1134 $ $Date: 2010-01-07 18:32:54 -0200 (Qui, 07 Jan 2010) $ @since 2.4.6">
			<const name="NOT_AVAILABLE_TEXT" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.util.SQLHelper$ExceptionWrapper.ExceptionWrapper()" access="pub" jdoc="Default constructor">
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper$ExceptionWrapper.executeWrappedCall(DatabaseMetaData)" access="pub" jdoc="Executes the call and catches all exception that might occur. @param metaData @return The result of the call">
				<param name="metaData"/>
			</mth>
			<mth name="/:org.dbunit.util.SQLHelper$ExceptionWrapper.wrappedCall(DatabaseMetaData)" access="pub" jdoc="Calls the method that might throw an exception to be handled @param metaData @return The result of the call as human readable string @throws Exception Any exception that might occur during the method invocation">
				<param name="metaData"/>
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.util.TableFormatter" intfc="n" abs="n" inn="n" sloc="82" jdoc="Simple formatter to print out {@link ITable} objects in a beautiful way, for example on a console. @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 902 $ $Date: 2008-12-02 18:28:54 -0200 (Ter, 02 Dez 2008) $ @since 2.4.1">
			<mth name="/:org.dbunit.util.TableFormatter.TableFormatter()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.TableFormatter.format(ITable)" access="pub" jdoc="Formats a table with all data in a beautiful way. Can be useful to print out the table data on a console. @param table The table to be formatted in a beautiful way @return The table data as a formatted String @throws DataSetException">
				<comm cntt="Title line"/>
				<comm cntt="Column headers"/>
				<comm cntt="Separator"/>
				<comm cntt="Values"/>
				<comm cntt="New row"/>
				<param name="table"/>
			</mth>
			<mth name="/:org.dbunit.util.TableFormatter.padLeft(String, int, char)" access="pub" jdoc="Pads the given String with the given &amp;lt;code&amp;gt;padChar&amp;lt; code&amp;gt; up to the given &amp;lt;code&amp;gt;length&amp;lt; code&amp;gt;. @param s @param length @param padChar @return The padded string">
				<param name="s"/>
				<param name="length"/>
				<param name="padChar"/>
			</mth>
			<mth name="/:org.dbunit.util.TableFormatter.padRight(String, int, char)" access="pub" jdoc="Pads the given String with the given &amp;lt;code&amp;gt;padChar&amp;lt; code&amp;gt; up to the given &amp;lt;code&amp;gt;length&amp;lt; code&amp;gt;. @param s @param length @param padChar @return The padded string">
				<param name="s"/>
				<param name="length"/>
				<param name="padChar"/>
			</mth>
			<mth name="/:org.dbunit.util.TableFormatter.getPadCharArray(String, int, char)" access="priv" jdoc="">
				<param name="s"/>
				<param name="length"/>
				<param name="padChar"/>
			</mth>
			<mth name="/:org.dbunit.util.TableFormatter.pad(String, char[], boolean)" access="priv" jdoc="">
				<param name="s"/>
				<param name="padArray"/>
				<param name="padLeft"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.FileHelper" intfc="n" abs="n" inn="n" sloc="76" jdoc="Utility that provides some general methods for working with {@link File} objects. @author gommma @version $Revision: 884 $ @since 2.3.0">
			<field name="logger" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.FileHelper.FileHelper()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.FileHelper.deleteDirectory(File, boolean)" access="pub" jdoc="Recursively deletes the given directory @param directory The directory to delete @param failOnError If an exception should be thrown in case the deletion did not work.">
				<param name="directory"/>
				<param name="failOnError"/>
			</mth>
			<mth name="/:org.dbunit.util.FileHelper.deleteDirectory(File)" access="pub" jdoc="Recursively deletes the given directory @param directory The directory to delete @return &amp;lt;code&amp;gt;true&amp;lt; code&amp;gt; if the deletion was successfully.">
				<comm cntt="First we must delete all files in the directory"/>
				<comm cntt="First delete children recursively"/>
				<comm cntt="Delete the file itself"/>
				<comm cntt="Finally delete the directory itself"/>
				<param name="directory"/>
			</mth>
			<mth name="/:org.dbunit.util.FileHelper.createInputSource(File)" access="pub" jdoc="">
				<comm cntt=".getAbsoluteFile()"/>
				<param name="file"/>
			</mth>
			<mth name="/:org.dbunit.util.FileHelper.copyFile(File, File)" access="pub" jdoc="Copy file. @param srcFile the src file @param destFile the dest file @throws IOException">
				<comm cntt="Create channel on the source"/>
				<comm cntt="Create channel on the destination"/>
				<comm cntt="Copy file contents from source to destination"/>
				<comm cntt="Close the channels"/>
				<param name="srcFile"/>
				<param name="destFile"/>
			</mth>
			<mth name="/:org.dbunit.util.FileHelper.readLines(File)" access="pub" jdoc="Get a list of Strings from a given file. Uses the default encoding of the current platform. @param theFile the file to be read @return a list of Strings, each one representing one line from the given file @throws IOException">
				<param name="theFile"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.util.concurrent">
		<class name="/:org.dbunit.util.concurrent.Sync" intfc="y" abs="n" inn="n" sloc="12" jdoc="Main interface for locks, gates, and conditions. &amp;lt;p&amp;gt; Sync objects isolate waiting and notification for particular logical states, resource availability, events, and the like that are shared across multiple threads. Use of Syncs sometimes (but by no means always) adds flexibility and efficiency compared to the use of plain java monitor methods and locking, and are sometimes (but by no means always) simpler to program with. &amp;lt;p&amp;gt; Most Syncs are intended to be used primarily (although not exclusively) in before after constructions such as: &amp;lt;pre&amp;gt; class X { Sync gate; ... public void m() { try { gate.acquire(); block until condition holds try { ... method body } finally { gate.release() } } catch (InterruptedException ex) { ... evasive action } } public void m2(Sync cond) { use supplied condition try { if (cond.attempt(10)) { try the condition for 10 ms try { ... method body } finally { cond.release() } } } catch (InterruptedException ex) { ... evasive action } } } &amp;lt; pre&amp;gt; Syncs may be used in somewhat tedious but more flexible replacements for built-in Java synchronized blocks. For example: &amp;lt;pre&amp;gt; class HandSynched { private double state_ = 0.0; private final Sync lock; use lock type supplied in constructor public HandSynched(Sync l) { lock = l; } public void changeState(double d) { try { lock.acquire(); try { state_ = updateFunction(d); } finally { lock.release(); } } catch(InterruptedException ex) { } } public double getState() { double d = 0.0; try { lock.acquire(); try { d = accessFunction(state_); } finally { lock.release(); } } catch(InterruptedException ex){} return d; } private double updateFunction(double d) { ... } private double accessFunction(double d) { ... } } &amp;lt; pre&amp;gt; If you have a lot of such methods, and they take a common form, you can standardize this using wrappers. Some of these wrappers are standardized in LockedExecutor, but you can make others. For example: &amp;lt;pre&amp;gt; class HandSynchedV2 { private double state_ = 0.0; private final Sync lock; use lock type supplied in constructor public HandSynchedV2(Sync l) { lock = l; } protected void runSafely(Runnable r) { try { lock.acquire(); try { r.run(); } finally { lock.release(); } } catch (InterruptedException ex) { propagate without throwing Thread.currentThread().interrupt(); } } public void changeState(double d) { runSafely(new Runnable() { public void run() { state_ = updateFunction(d); } }); } ... } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; One reason to bother with such constructions is to use deadlock- avoiding back-offs when dealing with locks involving multiple objects. For example, here is a Cell class that uses attempt to back-off and retry if two Cells are trying to swap values with each other at the same time. &amp;lt;pre&amp;gt; class Cell { long value; Sync lock = ... some sync implementation class void swapValue(Cell other) { for (;;) { try { lock.acquire(); try { if (other.lock.attempt(100)) { try { long t = value; value = other.value; other.value = t; return; } finally { other.lock.release(); } } } finally { lock.release(); } } catch (InterruptedException ex) { return; } } } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; Here is an even fancier version, that uses lock re-ordering upon conflict: &amp;lt;pre&amp;gt; class Cell { long value; Sync lock = ...; private static boolean trySwap(Cell a, Cell b) { a.lock.acquire(); try { if (!b.lock.attempt(0)) return false; try { long t = a.value; a.value = b.value; b.value = t; return true; } finally { other.lock.release(); } } finally { lock.release(); } return false; } void swapValue(Cell other) { try { while (!trySwap(this, other) &amp;&amp; !tryswap(other, this)) Thread.sleep(1); } catch (InterruptedException ex) { return; } } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; Interruptions are in general handled as early as possible. Normally, InterruptionExceptions are thrown in acquire and attempt(msec) if interruption is detected upon entry to the method, as well as in any later context surrounding waits. However, interruption status is ignored in release(); &amp;lt;p&amp;gt; Timed versions of attempt report failure via return value. If so desired, you can transform such constructions to use exception throws via &amp;lt;pre&amp;gt; if (!c.attempt(timeval)) throw new TimeoutException(timeval); &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; The TimoutSync wrapper class can be used to automate such usages. &amp;lt;p&amp;gt; All time values are expressed in milliseconds as longs, which have a maximum value of Long.MAX_VALUE, or almost 300,000 centuries. It is not known whether JVMs actually deal correctly with such extreme values. For convenience, some useful time values are defined as static constants. &amp;lt;p&amp;gt; All implementations of the three Sync methods guarantee to somehow employ Java &amp;lt;code&amp;gt;synchronized&amp;lt; code&amp;gt; methods or blocks, and so entail the memory operations described in JLS chapter 17 which ensure that variables are loaded and flushed within before after constructions. &amp;lt;p&amp;gt; Syncs may also be used in spinlock constructions. Although it is normally best to just use acquire(), various forms of busy waits can be implemented. For a simple example (but one that would probably never be preferable to using acquire()): &amp;lt;pre&amp;gt; class X { Sync lock = ... void spinUntilAcquired() throws InterruptedException { Two phase. First spin without pausing. int purespins = 10; for (int i = 0; i &amp;lt; purespins; ++i) { if (lock.attempt(0)) return true; } Second phase - use timed waits long waitTime = 1; 1 millisecond for (;;) { if (lock.attempt(waitTime)) return true; else waitTime = waitTime 3 2 + 1; increase 50% } } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; In addition pure synchronization control, Syncs may be useful in any context requiring before after methods. For example, you can use an ObservableSync (perhaps as part of a LayeredSync) in order to obtain callbacks before and after each method invocation for a given class. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;]&amp;lt; p&amp;gt; @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<comm cntt="Not that it matters, but there is some variation across"/>
			<comm cntt="standard sources about value at msec precision."/>
			<comm cntt="The value used is the same as in java.util.GregorianCalendar"/>
			<const name="ONE_SECOND" access="pub" jdoc="One second, in milliseconds; convenient as a time-out value"/>
			<const name="ONE_MINUTE" access="pub" jdoc="One minute, in milliseconds; convenient as a time-out value"/>
			<const name="ONE_HOUR" access="pub" jdoc="One hour, in milliseconds; convenient as a time-out value"/>
			<const name="ONE_DAY" access="pub" jdoc="One day, in milliseconds; convenient as a time-out value"/>
			<const name="ONE_WEEK" access="pub" jdoc="One week, in milliseconds; convenient as a time-out value"/>
			<const name="ONE_YEAR" access="pub" jdoc="One year in milliseconds; convenient as a time-out value"/>
			<const name="ONE_CENTURY" access="pub" jdoc="One century in milliseconds; convenient as a time-out value"/>
			<mth name="/:org.dbunit.util.concurrent.Sync.acquire()" access="pub" jdoc="Wait (possibly forever) until successful passage. Fail only upon interuption. Interruptions always result in `clean&amp;apos; failures. On failure, you can be sure that it has not been acquired, and that no corresponding release should be performed. Conversely, a normal return guarantees that the acquire was successful.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Sync.attempt(long)" access="pub" jdoc="Wait at most msecs to pass; report whether passed. &amp;lt;p&amp;gt; The method has best-effort semantics: The msecs bound cannot be guaranteed to be a precise upper bound on wait time in Java. Implementations generally can only attempt to return as soon as possible after the specified bound. Also, timers in Java do not stop during garbage collection, so timeouts can occur just because a GC intervened. So, msecs arguments should be used in a coarse-grained manner. Further, implementations cannot always guarantee that this method will return at all without blocking indefinitely when used in unintended ways. For example, deadlocks may be encountered when called in an unintended context. &amp;lt;p&amp;gt; @param msecs the number of milleseconds to wait. An argument less than or equal to zero means not to wait at all. However, this may still require access to a synchronization lock, which can impose unbounded delay if there is a lot of contention among threads. @return true if acquired">
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Sync.release()" access="pub" jdoc="Potentially enable others to pass. &amp;lt;p&amp;gt; Because release does not raise exceptions, it can be used in `finally&amp;apos; clauses without requiring extra embedded try catch blocks. But keep in mind that as with any java method, implementations may still throw unchecked exceptions such as Error or NullPointerException when faced with uncontinuable errors. However, these should normally only be caught by higher-level error handlers.">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.BoundedChannel" intfc="y" abs="n" inn="n" sloc="3" jdoc="A channel that is known to have a capacity, signifying that &amp;lt;code&amp;gt;put&amp;lt; code&amp;gt; operations may block when the capacity is reached. Various implementations may have intrinsically hard-wired capacities, capacities that are fixed upon construction, or dynamically adjustable capacities. @see DefaultChannelCapacity&amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] &amp;lt;p&amp;gt; @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<mth name="/:org.dbunit.util.concurrent.BoundedChannel.capacity()" access="pub" jdoc="Return the maximum number of elements that can be held. @return the capacity of this channel.">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.Semaphore" intfc="n" abs="n" inn="n" sloc="67" jdoc="Base class for counting semaphores. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release adds a permit. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. &amp;lt;p&amp;gt; A semaphore initialized to 1 can serve as a mutual exclusion lock. &amp;lt;p&amp;gt; Different implementation subclasses may provide different ordering guarantees (or lack thereof) surrounding which threads will be resumed upon a signal. &amp;lt;p&amp;gt; The default implementation makes NO guarantees about the order in which threads will acquire permits. It is often faster than other implementations. &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;Sample usage.&amp;lt; b&amp;gt; Here is a class that uses a semaphore to help manage access to a pool of items. &amp;lt;pre&amp;gt; class Pool { static final MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE); public Object getItem() throws InterruptedException { no synch available.acquire(); return getNextAvailableItem(); } public void putItem(Object x) { no synch if (markAsUnused(x)) available.release(); } Not a particularly efficient data structure; just for demo protected Object[] items = ... whatever kinds of items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() { for (int i = 0; i &amp;lt; MAX_AVAILABLE; ++i) { if (!used[i]) { used[i] = true; return items[i]; } } return null; not reached } protected synchronized boolean markAsUnused(Object item) { for (int i = 0; i &amp;lt; MAX_AVAILABLE; ++i) { if (item == items[i]) { if (used[i]) { used[i] = false; return true; } else return false; } } return false; } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="permits_" access="prot" jdoc="current number of available permits"/>
			<mth name="/:org.dbunit.util.concurrent.Semaphore.Semaphore(long)" access="pub" jdoc="Create a Semaphore with the given initial number of permits. Using a seed of one makes the semaphore act as a mutual exclusion lock. Negative seeds are also allowed, in which case no acquires will proceed until the number of releases has pushed the number of permits past 0.">
				<param name="initialPermits"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Semaphore.acquire()" access="pub" jdoc="Wait until a permit is available, and take one">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Semaphore.attempt(long)" access="pub" jdoc="Wait at most msecs millisconds for a permit.">
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Semaphore.release()" access="pub" jdoc="Release a permit">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Semaphore.release(long)" access="pub" jdoc="Release N permits. &amp;lt;code&amp;gt;release(n)&amp;lt; code&amp;gt; is equivalent in effect to: &amp;lt;pre&amp;gt; for (int i = 0; i &amp;lt; n; ++i) release(); &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; But may be more efficient in some semaphore implementations. @exception IllegalArgumentException if n is negative.">
				<param name="n"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Semaphore.permits()" access="pub" jdoc="Return the current number of available permits. Returns an accurate, but possibly unstable value, that may change immediately after returning.">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.DefaultChannelCapacity" intfc="n" abs="n" inn="n" sloc="14" jdoc="A utility class to set the default capacity of BoundedChannel implementations that otherwise require a capacity argument @see BoundedChannel[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] &amp;lt;p&amp;gt; @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="INITIAL_DEFAULT_CAPACITY" access="pub" jdoc="The initial value of the default capacity is 1024"/>
			<const name="defaultCapacity_" access="priv" jdoc="the current default capacity"/>
			<mth name="/:org.dbunit.util.concurrent.DefaultChannelCapacity.set(int)" access="pub" jdoc="Set the default capacity used in default (no-argument) constructor for BoundedChannels that otherwise require a capacity argument. @exception IllegalArgumentException if capacity less or equal to zero">
				<param name="capacity"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.DefaultChannelCapacity.get()" access="pub" jdoc="Get the default capacity used in default (no-argument) constructor for BoundedChannels that otherwise require a capacity argument. Initial value is &amp;lt;code&amp;gt;INITIAL_DEFAULT_CAPACITY&amp;lt; code&amp;gt; @see #INITIAL_DEFAULT_CAPACITY">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.LinkedQueue" intfc="n" abs="n" inn="n" sloc="126" jdoc="A linked list based channel implementation. The algorithm avoids contention between puts and takes when the queue is not empty. Normally a put and a take can proceed simultaneously. (Although it does not allow multiple concurrent puts or takes.) This class tends to perform more efficently than other Channel implementations in producer consumer applications. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="head_" access="prot" jdoc="Dummy header node of list. The first actual node, if it exists, is always at head_.next. After each take, the old first node becomes the head."/>
			<const name="putLock_" access="prot" jdoc="Helper monitor for managing access to last node."/>
			<field name="last_" access="prot" jdoc="The last node of list. Put() appends to list, so modifies last_"/>
			<field name="waitingForTake_" access="prot" jdoc="The number of threads waiting for a take. Notifications are provided in put only if greater than zero. The bookkeeping is worth it here since in reasonably balanced usages, the notifications will hardly ever be necessary, so the call overhead to notify can be eliminated."/>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.LinkedQueue()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.insert(Object)" access="prot" jdoc="Main mechanics for put offer">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.extract()" access="prot" jdoc="Main mechanics for take poll">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.put(Object)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.offer(Object, long)" access="pub" jdoc="">
				<param name="x"/>
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.take()" access="pub" jdoc="">
				<comm cntt="try to extract. If fail, then enter wait-based retry loop"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.peek()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.isEmpty()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedQueue.poll(long)" access="pub" jdoc="">
				<param name="msecs"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.LinkedNode" intfc="n" abs="n" inn="n" sloc="7" jdoc="A standard linked list node used in various queue classes @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<field name="value" access="pub" jdoc=""/>
			<field name="next" access="pub" jdoc=""/>
			<mth name="/:org.dbunit.util.concurrent.LinkedNode.LinkedNode()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedNode.LinkedNode(Object)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.LinkedNode.LinkedNode(Object, LinkedNode)" access="pub" jdoc="">
				<param name="x"/>
				<param name="n"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.TimeoutException" intfc="n" abs="n" inn="n" sloc="10" jdoc="Thrown by synchronization classes that report timeouts via exceptions. The exception is treated as a form (subclass) of InterruptedException. This both simplifies handling, and conceptually reflects the fact that timed-out operations are artificially interrupted by timers. @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="duration" access="pub" jdoc="The approximate time that the operation lasted before this timeout exception was thrown."/>
			<mth name="/:org.dbunit.util.concurrent.TimeoutException.TimeoutException(long)" access="pub" jdoc="Constructs a TimeoutException with given duration value.">
				<param name="time"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.TimeoutException.TimeoutException(long, String)" access="pub" jdoc="Constructs a TimeoutException with the specified duration value and detail message.">
				<param name="time"/>
				<param name="message"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.Channel" intfc="y" abs="n" inn="n" sloc="7" jdoc="Main interface for buffers, queues, pipes, conduits, etc. &amp;lt;p&amp;gt; A Channel represents anything that you can put items into and take them out of. As with the Sync interface, both blocking (put(x), take), and timeouts (offer(x, msecs), poll(msecs)) policies are provided. Using a zero timeout for offer and poll results in a pure balking policy. &amp;lt;p&amp;gt; To aid in efforts to use Channels in a more typesafe manner, this interface extends Puttable and Takable. You can restrict arguments of instance variables to this type as a way of guaranteeing that producers never try to take, or consumers put. for example: &amp;lt;pre&amp;gt; class Producer implements Runnable { final Puttable chan; Producer(Puttable channel) { chan = channel; } public void run() { try { for(;;) { chan.put(produce()); } } catch (InterruptedException ex) {} } Object produce() { ... } } class Consumer implements Runnable { final Takable chan; Consumer(Takable channel) { chan = channel; } public void run() { try { for(;;) { consume(chan.take()); } } catch (InterruptedException ex) {} } void consume(Object x) { ... } } class Setup { void main() { Channel chan = new SomeChannelImplementation(); Producer p = new Producer(chan); Consumer c = new Consumer(chan); new Thread(p).start(); new Thread(c).start(); } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; A given channel implementation might or might not have bounded capacity or other insertion constraints, so in general, you cannot tell if a given put will block. However, Channels that are designed to have an element capacity (and so always block when full) should implement the BoundedChannel subinterface. &amp;lt;p&amp;gt; Channels may hold any kind of item. However, insertion of null is not in general supported. Implementations may (all currently do) throw IllegalArgumentExceptions upon attempts to insert null. &amp;lt;p&amp;gt; By design, the Channel interface does not support any methods to determine the current number of elements being held in the channel. This decision reflects the fact that in concurrent programming, such methods are so rarely useful that including them invites misuse; at best they could provide a snapshot of current state, that could change immediately after being reported. It is better practice to instead use poll and offer to try to take and put elements without blocking. For example, to empty out the current contents of a channel, you could write: &amp;lt;pre&amp;gt; try { for (;;) { Object item = channel.poll(0); if (item != null) process(item); else break; } } catch(InterruptedException ex) { ... } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; However, it is possible to determine whether an item exists in a Channel via &amp;lt;code&amp;gt;peek&amp;lt; code&amp;gt;, which returns but does NOT remove the next item that can be taken (or null if there is no such item). The peek operation has a limited range of applicability, and must be used with care. Unless it is known that a given thread is the only possible consumer of a channel, and that no time-out-based &amp;lt;code&amp;gt;offer&amp;lt; code&amp;gt; operations are ever invoked, there is no guarantee that the item returned by peek will be available for a subsequent take. &amp;lt;p&amp;gt; When appropriate, you can define an isEmpty method to return whether &amp;lt;code&amp;gt;peek&amp;lt; code&amp;gt; returns null. &amp;lt;p&amp;gt; Also, as a compromise, even though it does not appear in interface, implementation classes that can readily compute the number of elements support a &amp;lt;code&amp;gt;size()&amp;lt; code&amp;gt; method. This allows careful use, for example in queue length monitors, appropriate to the particular implementation constraints and properties. &amp;lt;p&amp;gt; All channels allow multiple producers and or consumers. They do not support any kind of &amp;lt;em&amp;gt;close&amp;lt; em&amp;gt; method to shut down operation or indicate completion of particular producer or consumer threads. If you need to signal completion, one way to do it is to create a class such as &amp;lt;pre&amp;gt; class EndOfStream { Application-dependent field methods } &amp;lt; pre&amp;gt; And to have producers put an instance of this class into the channel when they are done. The consumer side can then check this via &amp;lt;pre&amp;gt; Object x = aChannel.take(); if (x instanceof EndOfStream) special actions; perhaps terminate else process normally &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; In time-out based methods (poll(msecs) and offer(x, msecs), time bounds are interpreted in a coarse-grained, best-effort fashion. Since there is no way in Java to escape out of a wait for a synchronized method block, time bounds can sometimes be exceeded when there is a lot contention for the channel. Additionally, some Channel semantics entail a ``point of no return&amp;apos;&amp;apos; where, once some parts of the operation have completed, others must follow, regardless of time bound. &amp;lt;p&amp;gt; Interruptions are in general handled as early as possible in all methods. Normally, InterruptionExceptions are thrown in put take and offer(msec) poll(msec) if interruption is detected upon entry to the method, as well as in any later context surrounding waits. &amp;lt;p&amp;gt; If a put returns normally, an offer returns true, or a put or poll returns non-null, the operation completed successfully. In all other cases, the operation fails cleanly -- the element is not put or taken. &amp;lt;p&amp;gt; As with Sync classes, spinloops are not directly supported, are not particularly recommended for routine use, but are not hard to construct. For example, here is an exponential backoff version: &amp;lt;pre&amp;gt; Object backOffTake(Channel q) throws InterruptedException { long waitTime = 0; for (;;) { Object x = q.poll(0); if (x != null) return x; else { Thread.sleep(waitTime); waitTime = 3 waitTime 2 + 1; } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;Sample Usage&amp;lt; b&amp;gt;. Here is a producer consumer design where the channel is used to hold Runnable commands representing background tasks. &amp;lt;pre&amp;gt; class Service { private final Channel channel = ... some Channel implementation; private void backgroundTask(int taskParam) { ... } public void action(final int arg) { Runnable command = new Runnable() { public void run() { backgroundTask(arg); } }; try { channel.put(command) } catch (InterruptedException ex) { Thread.currentThread().interrupt(); ignore but propagate } } public Service() { Runnable backgroundLoop = new Runnable() { public void run() { for (;;) { try { Runnable task = (Runnable)(channel.take()); task.run(); } catch (InterruptedException ex) { return; } } } }; new Thread(backgroundLoop).start(); } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1) @see Sync @see BoundedChannel">
			<mth name="/:org.dbunit.util.concurrent.Channel.put(Object)" access="pub" jdoc="Place item in the channel, possibly waiting indefinitely until it can be accepted. Channels implementing the BoundedChannel subinterface are generally guaranteed to block on puts upon reaching capacity, but other implementations may or may not block. @param item the element to be inserted. Should be non-null. @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case the element is guaranteed not to be inserted. Otherwise, on normal return, the element is guaranteed to have been inserted.">
				<param name="item"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Channel.offer(Object, long)" access="pub" jdoc="Place item in channel only if it can be accepted within msecs milliseconds. The time bound is interpreted in a coarse-grained, best-effort fashion. @param item the element to be inserted. Should be non-null. @param msecs the number of milliseconds to wait. If less than or equal to zero, the method does not perform any timed waits, but might still require access to a synchronization lock, which can impose unbounded delay if there is a lot of contention for the channel. @return true if accepted, else false @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case the element is guaranteed not to be inserted (i.e., is equivalent to a false return).">
				<param name="item"/>
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Channel.take()" access="pub" jdoc="Return and remove an item from channel, possibly waiting indefinitely until such an item exists. @return some item from the channel. Different implementations may guarantee various properties (such as FIFO) about that item @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case state of the channel is unchanged.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Channel.poll(long)" access="pub" jdoc="Return and remove an item from channel only if one is available within msecs milliseconds. The time bound is interpreted in a coarse grained, best-effort fashion. @param msecs the number of milliseconds to wait. If less than or equal to zero, the operation does not perform any timed waits, but might still require access to a synchronization lock, which can impose unbounded delay if there is a lot of contention for the channel. @return some item, or null if the channel is empty. @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case state of the channel is unchanged (i.e., equivalent to a null return).">
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Channel.peek()" access="pub" jdoc="Return, but do not remove object at head of Channel, or null if it is empty.">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.Executor" intfc="y" abs="n" inn="n" sloc="3" jdoc="Interface for objects that execute Runnables, as well as various objects that can be wrapped as Runnables. The main reason to use Executor throughout a program or subsystem is to provide flexibility: You can easily change from using thread-per-task to using pools or queuing, without needing to change most of your code that generates tasks. &amp;lt;p&amp;gt; The general intent is that execution be asynchronous, or at least independent of the caller. For example, one of the simplest implementations of &amp;lt;code&amp;gt;execute&amp;lt; code&amp;gt; (as performed in ThreadedExecutor) is &amp;lt;code&amp;gt;new Thread(command).start();&amp;lt; code&amp;gt;. However, this interface allows implementations that instead employ queueing or pooling, or perform additional bookkeeping. &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<mth name="/:org.dbunit.util.concurrent.Executor.execute(Runnable)" access="pub" jdoc="Execute the given command. This method is guaranteed only to arrange for execution, that may actually occur sometime later; for example in a new thread. However, in fully generic use, callers should be prepared for execution to occur in any fashion at all, including immediate direct execution. &amp;lt;p&amp;gt; The method is defined not to throw any checked exceptions during execution of the command. Generally, any problems encountered will be asynchronous and so must be dealt with via callbacks or error handler objects. If necessary, any context-dependent catastrophic errors encountered during actions that arrange for execution could be accompanied by throwing context-dependent unchecked exceptions. &amp;lt;p&amp;gt; However, the method does throw InterruptedException: It will fail to arrange for execution if the current thread is currently interrupted. Further, the general contract of the method is to avoid, suppress, or abort execution if interruption is detected in any controllable context surrounding execution.">
				<param name="command"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.SynchronousChannel" intfc="n" abs="n" inn="n" sloc="237" jdoc="A rendezvous channel, similar to those used in CSP and Ada. Each put must wait for a take, and vice versa. Synchronous channels are well suited for handoff designs, in which an object running in one thread must synch up with an object running in another thread in order to hand it some information, event, or task. &amp;lt;p&amp;gt; If you only need threads to synch up without exchanging information, consider using a Barrier. If you need bidirectional exchanges, consider using a Rendezvous. &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;Read the &amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt;introduction to this package&amp;lt; a&amp;gt; for more details. @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1) @see &amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent Rendezvous.html&amp;quot;&amp;gt;Rendezvous&amp;lt; a&amp;gt; @see &amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent CyclicBarrier.html&amp;quot;&amp;gt;CyclicBarrier&amp;lt; a&amp;gt;">
			<comm cntt="This implementation divides actions into two cases for puts: An arriving putter that does not already have a waiting taker creates a node holding item, and then waits for a taker to take it. An arriving putter that does already have a waiting taker fills the slot node created by the taker, and notifies it to continue. And symmetrically, two for takes: An arriving taker that does not already have a waiting putter creates an empty slot node, and then waits for a putter to fill it. An arriving taker that does already have a waiting putter takes item from the node created by the putter, and notifies it to continue. This requires keeping two simple queues: waitingPuts and waitingTakes. When a put or take waiting for the actions of its counterpart aborts due to interruption or timeout, it marks the node it created as &amp;quot;CANCELLED&amp;quot;, which causes its counterpart to retry the entire put or take sequence."/>
			<comm cntt="Offer and poll are just like put and take, except even messier."/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="CANCELLED" access="prot" jdoc="Special marker used in queue nodes to indicate that the thread waiting for a change in the node has timed out or been interrupted."/>
			<const name="waitingPuts" access="prot" jdoc=""/>
			<const name="waitingTakes" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel.capacity()" access="pub" jdoc="@return zero -- Synchronous channels have no internal capacity.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel.peek()" access="pub" jdoc="@return null -- Synchronous channels do not hold contents unless actively taken">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel.put(Object)" access="pub" jdoc="">
				<comm cntt="This code is conceptually straightforward, but messy"/>
				<comm cntt="because we need to intertwine handling of put-arrives first"/>
				<comm cntt="vs take-arrives first cases."/>
				<comm cntt="Outer loop is to handle retry due to canceled waiting taker"/>
				<comm cntt="Get out now if we are interrupted"/>
				<comm cntt="Exactly one of item or slot will be not-null at end of"/>
				<comm cntt="synchronized block, depending on whether a put or a take"/>
				<comm cntt="arrived first."/>
				<comm cntt="Try to match up with a waiting taker; fill and signal it below"/>
				<comm cntt="If no takers yet, create a node and wait below"/>
				<comm cntt="There is a waiting taker."/>
				<comm cntt="Fill in the slot created by the taker and signal taker to"/>
				<comm cntt="continue."/>
				<comm cntt="else the taker has canceled, so retry outer loop"/>
				<comm cntt="Wait for a taker to arrive and take the item."/>
				<comm cntt="If item was taken, return normally but set interrupt status"/>
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel.take()" access="pub" jdoc="">
				<comm cntt="Entirely symmetric to put()"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel.offer(Object, long)" access="pub" jdoc="">
				<comm cntt="lazily initialize below if needed"/>
				<param name="x"/>
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel.poll(long)" access="pub" jdoc="">
				<param name="msecs"/>
			</mth>
		<class name="/:org.dbunit.util.concurrent.SynchronousChannel$Queue" intfc="n" abs="n" inn="y" sloc="19" jdoc="Simple FIFO queue class to hold waiting puts takes.">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="head" access="prot" jdoc=""/>
			<field name="last" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel$Queue.enq(LinkedNode)" access="prot" jdoc="">
				<param name="p"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronousChannel$Queue.deq()" access="prot" jdoc="">
			</mth>
		</class>
		</class>
		<class name="/:org.dbunit.util.concurrent.Takable" intfc="y" abs="n" inn="n" sloc="4" jdoc="This interface exists to enable stricter type checking for channels. A method argument or instance variable in a consumer object can be declared as only a Takable rather than a Channel, in which case a Java compiler will disallow put operations. &amp;lt;p&amp;gt; Full method descriptions appear in the Channel interface. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;]&amp;lt; p&amp;gt; @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1) @see Channel @see Puttable">
			<mth name="/:org.dbunit.util.concurrent.Takable.take()" access="pub" jdoc="Return and remove an item from channel, possibly waiting indefinitely until such an item exists. @return some item from the channel. Different implementations may guarantee various properties (such as FIFO) about that item @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case state of the channel is unchanged.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Takable.poll(long)" access="pub" jdoc="Return and remove an item from channel only if one is available within msecs milliseconds. The time bound is interpreted in a coarse grained, best-effort fashion. @param msecs the number of milliseconds to wait. If less than or equal to zero, the operation does not perform any timed waits, but might still require access to a synchronization lock, which can impose unbounded delay if there is a lot of contention for the channel. @return some item, or null if the channel is empty. @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case state of the channel is unchanged (i.e., equivalent to a false return).">
				<param name="msecs"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.SynchronizedVariable" intfc="n" abs="n" inn="n" sloc="16" jdoc="Base class for simple, small classes maintaining single values that are always accessed and updated under synchronization. Since defining them for only some types seemed too arbitrary, they exist for all basic types, although it is hard to imagine uses for some. &amp;lt;p&amp;gt; These classes mainly exist so that you do not have to go to the trouble of writing your own miscellaneous classes and methods in situations including: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; When you need or want to offload an instance variable to use its own synchronization lock. When these objects are used to replace instance variables, they should almost always be declared as &amp;lt;code&amp;gt;final&amp;lt; code&amp;gt;. This helps avoid the need to synchronize just to obtain the reference to the synchronized variable itself. &amp;lt;li&amp;gt; When you need methods such as set, commit, or swap. Note however that the synchronization for these variables is &amp;lt;em&amp;gt;independent&amp;lt; em&amp;gt; of any other synchronization perfromed using other locks. So, they are not normally useful when accesses and updates among variables must be coordinated. For example, it would normally be a bad idea to make a Point class out of two SynchronizedInts, even those sharing a lock. &amp;lt;li&amp;gt; When defining &amp;lt;code&amp;gt;static&amp;lt; code&amp;gt; variables. It almost always works out better to rely on synchronization internal to these objects, rather than class locks. &amp;lt; ul&amp;gt; &amp;lt;p&amp;gt; While they cannot, by nature, share much code, all of these classes work in the same way. &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;Construction&amp;lt; b&amp;gt; &amp;lt;br&amp;gt; Synchronized variables are always constructed holding an initial value of the associated type. Constructors also establish the lock to use for all methods: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; By default, each variable uses itself as the synchronization lock. This is the most common choice in the most common usage contexts in which SynchronizedVariables are used to split off synchronization locks for independent attributes of a class. &amp;lt;li&amp;gt; You can specify any other Object to use as the synchronization lock. This allows you to use various forms of `slave synchronization&amp;apos;. For example, a variable that is always associated with a particular object can use that object&amp;apos;s lock. &amp;lt; ul&amp;gt; &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;Update methods&amp;lt; b&amp;gt;&amp;lt;br&amp;gt; Each class supports several kinds of update methods: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; A &amp;lt;code&amp;gt;set&amp;lt; code&amp;gt; method that sets to a new value and returns previous value. For example, for a SynchronizedBoolean b, &amp;lt;code&amp;gt;boolean old = b.set(true)&amp;lt; code&amp;gt; performs a test-and-set. &amp;lt;p&amp;gt; &amp;lt;li&amp;gt; A &amp;lt;code&amp;gt;commit&amp;lt; code&amp;gt; method that sets to new value only if currently holding a given value. For example, here is a class that uses an optimistic update loop to recompute a count variable represented as a SynchronizedInt. &amp;lt;pre&amp;gt; class X { private final SynchronizedInt count = new SynchronizedInt(0); static final int MAX_RETRIES = 1000; public boolean recomputeCount() throws InterruptedException { for (int i = 0; i &amp;lt; MAX_RETRIES; ++i) { int current = count.get(); int next = compute(current); if (count.commit(current, next)) return true; else if (Thread.interrupted()) throw new InterruptedException(); } return false; } int compute(int l) { ... some kind of computation ... } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt; &amp;lt;li&amp;gt;A &amp;lt;code&amp;gt;swap&amp;lt; code&amp;gt; method that atomically swaps with another object of the same class using a deadlock-avoidance strategy. &amp;lt;p&amp;gt; &amp;lt;li&amp;gt; Update-in-place methods appropriate to the type. All numerical types support: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; add(x) (equivalent to return value += x) &amp;lt;li&amp;gt; subtract(x) (equivalent to return value -= x) &amp;lt;li&amp;gt; multiply(x) (equivalent to return value = x) &amp;lt;li&amp;gt; divide(x) (equivalent to return value = x) &amp;lt; ul&amp;gt; Integral types also support: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; increment() (equivalent to return ++value) &amp;lt;li&amp;gt; decrement() (equivalent to return --value) &amp;lt; ul&amp;gt; Boolean types support: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; or(x) (equivalent to return value |= x) &amp;lt;li&amp;gt; and(x) (equivalent to return value &amp;amp;= x) &amp;lt;li&amp;gt; xor(x) (equivalent to return value ^= x) &amp;lt;li&amp;gt; complement() (equivalent to return x = !x) &amp;lt; ul&amp;gt; These cover most, but not all of the possible operators in Java. You can add more compute-and-set methods in subclasses. This is often a good way to avoid the need for ad-hoc synchronized blocks surrounding expressions. &amp;lt; ul&amp;gt; &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;Guarded methods&amp;lt; b&amp;gt; &amp;lt;br&amp;gt; All &amp;lt;code&amp;gt;Waitable&amp;lt; code&amp;gt; subclasses provide notifications on every value update, and support guarded methods of the form &amp;lt;code&amp;gt;when&amp;lt; code&amp;gt;&amp;lt;em&amp;gt;predicate&amp;lt; em&amp;gt;, that wait until the predicate hold, then optionally run any Runnable action within the lock, and then return. All types support: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; whenEqual(value, action) &amp;lt;li&amp;gt; whenNotEqual(value, action) &amp;lt; ul&amp;gt; (If the action argument is null, these return immediately after the predicate holds.) Numerical types also support &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; whenLess(value, action) &amp;lt;li&amp;gt; whenLessEqual(value, action) &amp;lt;li&amp;gt; whenGreater(value, action) &amp;lt;li&amp;gt; whenGreaterEqual(value, action) &amp;lt; ul&amp;gt; The Waitable classes are not always spectacularly efficient since they provide notifications on all value changes. They are designed for use in contexts where either performance is not an overriding issue, or where nearly every update releases guarded waits anyway. &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;Other methods&amp;lt; b&amp;gt; &amp;lt;br&amp;gt; This class implements Executor, and provides an &amp;lt;code&amp;gt;execute&amp;lt; code&amp;gt; method that runs the runnable within the lock. &amp;lt;p&amp;gt; All classes except SynchronizedRef and WaitableRef implement &amp;lt;code&amp;gt;Cloneable&amp;lt; code&amp;gt; and &amp;lt;code&amp;gt;Comparable&amp;lt; code&amp;gt;. Implementations of the corresponding methods either use default mechanics, or use methods that closely correspond to their java.lang analogs. SynchronizedRef does not implement any of these standard interfaces because there are many cases where it would not make sense. However, you can easily make simple subclasses that add the appropriate declarations. &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;]&amp;lt; p&amp;gt; @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="lock_" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedVariable.SynchronizedVariable(Object)" access="pub" jdoc="Create a SynchronizedVariable using the supplied lock">
				<param name="lock"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedVariable.SynchronizedVariable()" access="pub" jdoc="Create a SynchronizedVariable using itself as the lock">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedVariable.getLock()" access="pub" jdoc="Return the lock used for all synchronization for this object">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedVariable.execute(Runnable)" access="pub" jdoc="If current thread is not interrupted, execute the given command within this object&amp;apos;s lock">
				<param name="command"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.BoundedLinkedQueue" intfc="n" abs="n" inn="n" sloc="213" jdoc="A bounded variant of LinkedQueue class. This class may be preferable to BoundedBuffer because it allows a bit more concurency among puts and takes, because it does not pre-allocate fixed storage for elements, and allows capacity to be dynamically reset. On the other hand, since it allocates a node object on each put, it can be slow on systems with slow allocation and GC. Also, it may be preferable to LinkedQueue when you need to limit the capacity to prevent resource exhaustion. This protection normally does not hurt much performance-wise: When the queue is not empty or full, most puts and takes are still usually able to execute concurrently. @see LinkedQueue @see BoundedBuffer &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] &amp;lt;p&amp;gt; @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<comm cntt="It might be a bit nicer if this were declared as a subclass of LinkedQueue, or a sibling class of a common abstract class. It shares much of the basic design and bookkeeping fields. But too many details differ to make this worth doing."/>
			<comm cntt="put and offer(ms) differ only in policy before insert allowTake"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="head_" access="prot" jdoc="Dummy header node of list. The first actual node, if it exists, is always at head_.next. After each take, the old first node becomes the head."/>
			<field name="last_" access="prot" jdoc="The last node of list. Put() appends to list, so modifies last_"/>
			<const name="putGuard_" access="prot" jdoc="Helper monitor. Ensures that only one put at a time executes."/>
			<const name="takeGuard_" access="prot" jdoc="Helper monitor. Protects and provides wait queue for takes"/>
			<field name="capacity_" access="prot" jdoc="Number of elements allowed"/>
			<field name="putSidePutPermits_" access="prot" jdoc="One side of a split permit count. The counts represent permits to do a put. (The queue is full when zero). Invariant: putSidePutPermits_ + takeSidePutPermits_ = capacity_ - length. (The length is never separately recorded, so this cannot be checked explicitly.) To minimize contention between puts and takes, the put side uses up all of its permits before transfering them from the take side. The take side just increments the count upon each take. Thus, most puts and take can run independently of each other unless the queue is empty or full. Initial value is queue capacity."/>
			<field name="takeSidePutPermits_" access="prot" jdoc="Number of takes since last reconcile"/>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.BoundedLinkedQueue(int)" access="pub" jdoc="Create a queue with the given capacity @exception IllegalArgumentException if capacity less or equal to zero">
				<param name="capacity"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.BoundedLinkedQueue()" access="pub" jdoc="Create a queue with the current default capacity">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.reconcilePutPermits()" access="prot" jdoc="Move put permits from take side to put side; return the number of put side permits that are available. Call only under synch on puGuard_ AND this.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.capacity()" access="pub" jdoc="Return the current capacity of this queue">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.size()" access="pub" jdoc="Return the number of elements in the queue. This is only a snapshot value, that may be in the midst of changing. The returned value will be unreliable in the presence of active puts and takes, and should only be used as a heuristic estimate, for example for resource monitoring purposes.">
				<comm cntt="This should ideally synch on putGuard_, but doing so would cause it to block waiting for an in-progress put, which might be stuck. So we instead use whatever value of putSidePutPermits_ that we happen to read."/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.setCapacity(int)" access="pub" jdoc="Reset the capacity of this queue. If the new capacity is less than the old capacity, existing elements are NOT removed, but incoming puts will not proceed until the number of elements is less than the new capacity. @exception IllegalArgumentException if capacity less or equal to zero">
				<comm cntt="Force immediate reconcilation."/>
				<param name="newCapacity"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.extract()" access="prot" jdoc="Main mechanics for take poll">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.peek()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.take()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.poll(long)" access="pub" jdoc="">
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.allowTake()" access="prot" jdoc="Notify a waiting take if needed">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.insert(Object)" access="prot" jdoc="Create and insert a node. Call only under synch on putGuard_">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.put(Object)" access="pub" jdoc="">
				<comm cntt="wait for permit."/>
				<comm cntt="call outside of lock to loosen put take coupling"/>
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.offer(Object, long)" access="pub" jdoc="">
				<param name="x"/>
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedLinkedQueue.isEmpty()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel" intfc="n" abs="y" inn="n" sloc="100" jdoc="Abstract class for channels that use Semaphores to control puts and takes. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="putGuard_" access="prot" jdoc=""/>
			<const name="takeGuard_" access="prot" jdoc=""/>
			<field name="capacity_" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.SemaphoreControlledChannel(int)" access="pub" jdoc="Create a channel with the given capacity and default semaphore implementation @exception IllegalArgumentException if capacity less or equal to zero">
				<param name="capacity"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.SemaphoreControlledChannel(int, Class)" access="pub" jdoc="Create a channel with the given capacity and semaphore implementations instantiated from the supplied class @exception IllegalArgumentException if capacity less or equal to zero. @exception NoSuchMethodException If class does not have constructor that intializes permits @exception SecurityException if constructor information not accessible @exception InstantiationException if semaphore class is abstract @exception IllegalAccessException if constructor cannot be called @exception InvocationTargetException if semaphore constructor throws an exception">
				<param name="capacity"/>
				<param name="semaphoreClass"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.capacity()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.size()" access="pub" jdoc="Return the number of elements in the buffer. This is only a snapshot value, that may change immediately after returning.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.insert(Object)" access="prot" jdoc="Internal mechanics of put.">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.extract()" access="prot" jdoc="Internal mechanics of take.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.put(Object)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.offer(Object, long)" access="pub" jdoc="">
				<param name="x"/>
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.take()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SemaphoreControlledChannel.poll(long)" access="pub" jdoc="">
				<param name="msecs"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.Puttable" intfc="y" abs="n" inn="n" sloc="4" jdoc="This interface exists to enable stricter type checking for channels. A method argument or instance variable in a producer object can be declared as only a Puttable rather than a Channel, in which case a Java compiler will disallow take operations. &amp;lt;p&amp;gt; Full method descriptions appear in the Channel interface. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1) @see Channel @see Takable">
			<mth name="/:org.dbunit.util.concurrent.Puttable.put(Object)" access="pub" jdoc="Place item in the channel, possibly waiting indefinitely until it can be accepted. Channels implementing the BoundedChannel subinterface are generally guaranteed to block on puts upon reaching capacity, but other implementations may or may not block. @param item the element to be inserted. Should be non-null. @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case the element is guaranteed not to be inserted. Otherwise, on normal return, the element is guaranteed to have been inserted.">
				<param name="item"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Puttable.offer(Object, long)" access="pub" jdoc="Place item in channel only if it can be accepted within msecs milliseconds. The time bound is interpreted in a coarse-grained, best-effort fashion. @param item the element to be inserted. Should be non-null. @param msecs the number of milliseconds to wait. If less than or equal to zero, the method does not perform any timed waits, but might still require access to a synchronization lock, which can impose unbounded delay if there is a lot of contention for the channel. @return true if accepted, else false @exception InterruptedException if the current thread has been interrupted at a point at which interruption is detected, in which case the element is guaranteed not to be inserted (i.e., is equivalent to a false return).">
				<param name="item"/>
				<param name="msecs"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.BoundedBuffer" intfc="n" abs="n" inn="n" sloc="131" jdoc="Efficient array-based bounded buffer class. Adapted from CPJ, chapter 8, which describes design. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] &amp;lt;p&amp;gt; @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<comm cntt="the elements"/>
			<comm cntt="circular indices"/>
			<comm cntt="length"/>
			<comm cntt="capacity - length"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="array_" access="prot" jdoc=""/>
			<field name="takePtr_" access="prot" jdoc=""/>
			<field name="putPtr_" access="prot" jdoc=""/>
			<field name="usedSlots_" access="prot" jdoc=""/>
			<field name="emptySlots_" access="prot" jdoc=""/>
			<const name="putMonitor_" access="prot" jdoc="Helper monitor to handle puts."/>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.BoundedBuffer(int)" access="pub" jdoc="Create a BoundedBuffer with the given capacity. @exception IllegalArgumentException if capacity less or equal to zero">
				<param name="capacity"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.BoundedBuffer()" access="pub" jdoc="Create a buffer with the current default capacity">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.size()" access="pub" jdoc="Return the number of elements in the buffer. This is only a snapshot value, that may change immediately after returning.">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.capacity()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.incEmptySlots()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.incUsedSlots()" access="prot" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.insert(Object)" access="prot" jdoc="">
				<comm cntt="mechanics of put"/>
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.extract()" access="prot" jdoc="">
				<comm cntt="mechanics of take"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.peek()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.put(Object)" access="pub" jdoc="">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.offer(Object, long)" access="pub" jdoc="">
				<param name="x"/>
				<param name="msecs"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.take()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.BoundedBuffer.poll(long)" access="pub" jdoc="">
				<param name="msecs"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.Slot" intfc="n" abs="n" inn="n" sloc="27" jdoc="A one-slot buffer, using semaphores to control access. Slots are usually more efficient and controllable than using other bounded buffers implementations with capacity of 1. &amp;lt;p&amp;gt; Among other applications, Slots can be convenient in token-passing designs: Here. the Slot holds a some object serving as a token, that can be obtained and returned by various threads. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="item_" access="prot" jdoc="The slot"/>
			<mth name="/:org.dbunit.util.concurrent.Slot.Slot(Class)" access="pub" jdoc="Create a buffer with the given capacity, using the supplied Semaphore class for semaphores. @exception NoSuchMethodException If class does not have constructor that intializes permits @exception SecurityException if constructor information not accessible @exception InstantiationException if semaphore class is abstract @exception IllegalAccessException if constructor cannot be called @exception InvocationTargetException if semaphore constructor throws an exception">
				<param name="semaphoreClass"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Slot.Slot()" access="pub" jdoc="Create a new Slot using default Semaphore implementations">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Slot.insert(Object)" access="prot" jdoc="Set the item in preparation for a take">
				<param name="x"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Slot.extract()" access="prot" jdoc="Take item known to exist">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.Slot.peek()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.SynchronizedInt" intfc="n" abs="n" inn="n" sloc="133" jdoc="A class useful for offloading synch for int instance variables. &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="value_" access="prot" jdoc=""/>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.SynchronizedInt(int)" access="pub" jdoc="Make a new SynchronizedInt with the given initial value, and using its own internal lock.">
				<param name="initialValue"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.SynchronizedInt(int, Object)" access="pub" jdoc="Make a new SynchronizedInt with the given initial value, and using the supplied lock.">
				<param name="initialValue"/>
				<param name="lock"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.get()" access="pub" jdoc="Return the current value">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.set(int)" access="pub" jdoc="Set to newValue. @return the old value">
				<param name="newValue"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.commit(int, int)" access="pub" jdoc="Set value to newValue only if it is currently assumedValue. @return true if successful">
				<param name="assumedValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.swap(SynchronizedInt)" access="pub" jdoc="Atomically swap values with another SynchronizedInt. Uses identityHashCode to avoid deadlock when two SynchronizedInts attempt to simultaneously swap with each other. (Note: Ordering via identyHashCode is not strictly guaranteed by the language specification to return unique, orderable values, but in practice JVMs rely on them being unique.) @return the new value">
				<param name="other"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.increment()" access="pub" jdoc="Increment the value. @return the new value">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.decrement()" access="pub" jdoc="Decrement the value. @return the new value">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.add(int)" access="pub" jdoc="Add amount to value (i.e., set value += amount) @return the new value">
				<param name="amount"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.subtract(int)" access="pub" jdoc="Subtract amount from value (i.e., set value -= amount) @return the new value">
				<param name="amount"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.multiply(int)" access="pub" jdoc="Multiply value by factor (i.e., set value = factor) @return the new value">
				<param name="factor"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.divide(int)" access="pub" jdoc="Divide value by factor (i.e., set value = factor) @return the new value">
				<param name="factor"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.negate()" access="pub" jdoc="Set the value to the negative of its old value @return the new value">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.complement()" access="pub" jdoc="Set the value to its complement @return the new value">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.and(int)" access="pub" jdoc="Set value to value &amp;amp; b. @return the new value">
				<param name="b"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.or(int)" access="pub" jdoc="Set value to value | b. @return the new value">
				<param name="b"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.xor(int)" access="pub" jdoc="Set value to value ^ b. @return the new value">
				<param name="b"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.compareTo(int)" access="pub" jdoc="">
				<param name="other"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.compareTo(SynchronizedInt)" access="pub" jdoc="">
				<param name="other"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.compareTo(Object)" access="pub" jdoc="">
				<param name="other"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.equals(Object)" access="pub" jdoc="">
				<param name="other"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.concurrent.SynchronizedInt.toString()" access="pub" jdoc="">
			</mth>
		</class>
		<class name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster" intfc="n" abs="n" inn="n" sloc="195" jdoc="This class is interoperable with java.beans.PropertyChangeSupport, but relies on a streamlined copy-on-write scheme similar to that used in CopyOnWriteArrayList. This leads to much better performance in most event-intensive programs. It also adheres to clarified semantics of add and remove operations. &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;Sample usage.&amp;lt; b&amp;gt; &amp;lt;pre&amp;gt; class Thing { protected Color myColor = Color.red; an example property protected PropertyChangeMulticaster listeners = new PropertyChangeMulticaster(this); registration methods, including: void addListener(PropertyChangeListener l) { Use the `ifAbsent&amp;apos; version to avoid duplicate notifications listeners.addPropertyChangeListenerIfAbsent(l); } public synchronized Color getColor() { accessor return myColor; } internal synchronized state change method; returns old value protected synchronized Color assignColor(Color newColor) { Color oldColor = myColor; myColor = newColor; return oldColor; } public void setColor(Color newColor) { atomically change state Color oldColor = assignColor(newColor); broadcast change notification without holding synch lock listeners.firePropertyChange(&amp;quot;color&amp;quot;, oldColor, newColor); } } &amp;lt; pre&amp;gt; &amp;lt;p&amp;gt;[&amp;lt;a href=&amp;quot;http: gee.cs.oswego.edu dl classes EDU oswego cs dl util concurrent intro.html&amp;quot;&amp;gt; Introduction to this package. &amp;lt; a&amp;gt;] @author Doug Lea @author Last changed by: $Author: gommma $ @version $Revision: 766 $ $Date: 2008-08-01 08:05:20 -0300 (Sex, 01 Ago 2008) $ @since ? (pre 2.1)">
			<comm cntt="In order to allow this class to be lifted out without using"/>
			<comm cntt="the whole package, the basic mechanics of CopyOnWriteArrayList"/>
			<comm cntt="are used here, but not the class itself."/>
			<comm cntt="This also makes it barely faster."/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="listeners" access="prot" jdoc="The array of listeners. Copied on each update"/>
			<const name="source" access="prot" jdoc="The object to be provided as the &amp;quot;source&amp;quot; for any generated events. @serial"/>
			<field name="children" access="prot" jdoc="HashMap for managing listeners for specific properties. Maps property names to PropertyChangeMulticaster objects. @serial"/>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.getChild(String)" access="prot" jdoc="Return the child associated with property, or null if no such">
				<param name="propertyName"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.PropertyChangeMulticaster(Object)" access="pub" jdoc="Constructs a &amp;lt;code&amp;gt;PropertyChangeMulticaster&amp;lt; code&amp;gt; object. @param sourceBean The bean to be given as the source for any events. @exception NullPointerException if sourceBean is null">
				<param name="sourceBean"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.addPropertyChangeListener(PropertyChangeListener)" access="pub" jdoc="Add a VetoableChangeListener to the listener list. The listener is registered for all properties. If the listener is added multiple times, it will receive multiple change notifications upon any firePropertyChange @param listener The PropertyChangeListener to be added @exception NullPointerException If listener is null">
				<param name="listener"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.addPropertyChangeListenerIfAbsent(PropertyChangeListener)" access="pub" jdoc="Add a PropertyChangeListener to the listener list if it is not already present. The listener is registered for all properties. The operation maintains Set semantics: If the listener is already registered, the operation has no effect. @param listener The PropertyChangeListener to be added @exception NullPointerException If listener is null">
				<comm cntt="Copy while checking if already present."/>
				<comm cntt="already present -- throw away copy"/>
				<param name="listener"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.removePropertyChangeListener(PropertyChangeListener)" access="pub" jdoc="Remove a PropertyChangeListener from the listener list. It removes at most one occurrence of the given listener. If the listener was added multiple times it must be removed mulitple times. This removes a PropertyChangeListener that was registered for all properties, and has no effect if registered for only one or more specified properties. @param listener The PropertyChangeListener to be removed">
				<comm cntt="Copy while searching for element to remove"/>
				<comm cntt="copy remaining and exit"/>
				<comm cntt="special-case last cell"/>
				<param name="listener"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.addPropertyChangeListener(String, PropertyChangeListener)" access="pub" jdoc="Add a PropertyChangeListener for a specific property. The listener will be invoked only when a call on firePropertyChange names that specific property. However, if a listener is registered both for all properties and a specific property, it will receive multiple notifications upon changes to that property. @param propertyName The name of the property to listen on. @param listener The PropertyChangeListener to be added @exception NullPointerException If listener is null">
				<param name="propertyName"/>
				<param name="listener"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.addPropertyChangeListenerIfAbsent(String, PropertyChangeListener)" access="pub" jdoc="Add a PropertyChangeListener for a specific property, if it is not already registered. The listener will be invoked only when a call on firePropertyChange names that specific property. @param propertyName The name of the property to listen on. @param listener The PropertyChangeListener to be added @exception NullPointerException If listener is null">
				<param name="propertyName"/>
				<param name="listener"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.removePropertyChangeListener(String, PropertyChangeListener)" access="pub" jdoc="Remove a PropertyChangeListener for a specific property. Affects only the given property. If the listener is also registered for all properties, then it will continue to be registered for them. @param propertyName The name of the property that was listened on. @param listener The PropertyChangeListener to be removed">
				<param name="propertyName"/>
				<param name="listener"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.multicast(PropertyChangeEvent)" access="prot" jdoc="Helper method to relay evt to all listeners. Called by all public firePropertyChange methods.">
				<comm cntt="bind in synch block below"/>
				<param name="evt"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.firePropertyChange(String, Object, Object)" access="pub" jdoc="Report a bound property update to any registered listeners. No event is fired if old and new are equal and non-null. @param propertyName The programmatic name of the property that was changed. @param oldValue The old value of the property. @param newValue The new value of the property.">
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.firePropertyChange(String, int, int)" access="pub" jdoc="Report an int bound property update to any registered listeners. No event is fired if old and new are equal and non-null. &amp;lt;p&amp;gt; This is merely a convenience wrapper around the more general firePropertyChange method that takes Object values. @param propertyName The programmatic name of the property that was changed. @param oldValue The old value of the property. @param newValue The new value of the property.">
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.firePropertyChange(String, boolean, boolean)" access="pub" jdoc="Report a boolean bound property update to any registered listeners. No event is fired if old and new are equal and non-null. &amp;lt;p&amp;gt; This is merely a convenience wrapper around the more general firePropertyChange method that takes Object values. @param propertyName The programmatic name of the property that was changed. @param oldValue The old value of the property. @param newValue The new value of the property.">
				<param name="propertyName"/>
				<param name="oldValue"/>
				<param name="newValue"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.firePropertyChange(PropertyChangeEvent)" access="pub" jdoc="Fire an existing PropertyChangeEvent to any registered listeners. No event is fired if the given event&amp;apos;s old and new values are equal and non-null. @param evt The PropertyChangeEvent object.">
				<param name="evt"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.hasListeners(String)" access="pub" jdoc="Check if there are any listeners for a specific property. If propertyName is null, return whether there are any listeners at all. @param propertyName the property name. @return true if there are one or more listeners for the given property">
				<param name="propertyName"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.writeObject(ObjectOutputStream)" access="priv" jdoc="@serialData Null terminated list of &amp;lt;code&amp;gt;PropertyChangeListeners&amp;lt; code&amp;gt;. &amp;lt;p&amp;gt; At serialization time we skip non-serializable listeners and only serialize the serializable listeners.">
				<param name="s"/>
			</mth>
			<mth name="/:org.dbunit.util.concurrent.PropertyChangeMulticaster.readObject(ObjectInputStream)" access="priv" jdoc="">
				<comm cntt="paranoically reset"/>
				<param name="s"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.util.fileloader">
		<class name="/:org.dbunit.util.fileloader.CsvDataFileLoader" intfc="n" abs="n" inn="n" sloc="15" jdoc="@author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since &amp;lt;dbunit-version&amp;gt;">
			<mth name="/:org.dbunit.util.fileloader.CsvDataFileLoader.CsvDataFileLoader()" access="pub" jdoc="Create new instance.">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.CsvDataFileLoader.CsvDataFileLoader(Map)" access="pub" jdoc="Create new instance with replacement objects. @param replacementObjectsThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.CsvDataFileLoader.CsvDataFileLoader(Map, Map)" access="pub" jdoc="Create new instance with replacement objects and replacement substrings. @param roThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param rsThe replacement substrings for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
				<param name="rs"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.CsvDataFileLoader.loadDataSet(URL)" access="prot" jdoc="{@inheritDoc}">
				<param name="url"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.fileloader.XlsDataFileLoader" intfc="n" abs="n" inn="n" sloc="16" jdoc="@author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<mth name="/:org.dbunit.util.fileloader.XlsDataFileLoader.XlsDataFileLoader()" access="pub" jdoc="Create new instance.">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.XlsDataFileLoader.XlsDataFileLoader(Map)" access="pub" jdoc="Create new instance with replacement objects. @param replacementObjectsThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.XlsDataFileLoader.XlsDataFileLoader(Map, Map)" access="pub" jdoc="Create new instance with replacement objects and replacement substrings. @param roThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param rsThe replacement substrings for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
				<param name="rs"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.XlsDataFileLoader.loadDataSet(URL)" access="prot" jdoc="{@inheritDoc}">
				<param name="url"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.fileloader.FullXmlDataFileLoader" intfc="n" abs="n" inn="n" sloc="16" jdoc="@author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<mth name="/:org.dbunit.util.fileloader.FullXmlDataFileLoader.FullXmlDataFileLoader()" access="pub" jdoc="Create new instance.">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FullXmlDataFileLoader.FullXmlDataFileLoader(Map)" access="pub" jdoc="Create new instance with replacement objects. @param replacementObjectsThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FullXmlDataFileLoader.FullXmlDataFileLoader(Map, Map)" access="pub" jdoc="Create new instance with replacement objects and replacement substrings. @param roThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param rsThe replacement substrings for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
				<param name="rs"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FullXmlDataFileLoader.loadDataSet(URL)" access="prot" jdoc="{@inheritDoc}">
				<param name="url"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.fileloader.DataFileLoader" intfc="y" abs="n" inn="n" sloc="7" jdoc="Defines a dbUnit data file loader supporting replacement objects and substrings with {@link org.dbunit.dataset.ReplacementDataSet}. @author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<mth name="/:org.dbunit.util.fileloader.DataFileLoader.load(String)" access="pub" jdoc="Load the specified filename from the classpath into a dbUnit dataset. If filename == null or &amp;quot;&amp;quot;, then returns an empty{@link org.dbunit.dataset.DefaultDataSet}. @param filenameThe dbUnit file to load, in the format for the loader implementation and fully qualified name with package syntax. @return The dbUnit dataset of the specified file. @throws DatabaseUnitRuntimeExceptionDataSetException wrapped in a DatabaseUnitRuntimeException when file load errors occur.">
				<param name="fileName"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.DataFileLoader.addReplacementObjects(Map)" access="pub" jdoc="Add the specified replacement objects to existing ones for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param replacementObjectsThe replacement objects to include. @since 2.4.8">
				<param name="replacementObjects"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.DataFileLoader.addReplacementSubstrings(Map)" access="pub" jdoc="Add the specified replacement substrings to existing ones for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param replacementSubstringsThe replacement substrings to include. @since 2.4.8">
				<param name="replacementSubstrings"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.DataFileLoader.removeAllReplacementObjects()" access="pub" jdoc="Remove all existing replacement objects, resetting to none so no object replacements occur. @since 2.4.8">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.DataFileLoader.removeAllReplacementSubstrings()" access="pub" jdoc="Remove all existing replacement substring objects, resetting to none so no substring replacements occur. @since 2.4.8">
			</mth>
		</class>
		<class name="/:org.dbunit.util.fileloader.AbstractDataFileLoader" intfc="n" abs="y" inn="n" sloc="77" jdoc="Base class with common implementation for dbUnit data file loaders. @author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<const name="LOG" access="priv" jdoc=""/>
			<field name="replacementObjects" access="priv" jdoc=""/>
			<field name="replacementSubstrings" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.AbstractDataFileLoader()" access="pub" jdoc="Create new instance.">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.AbstractDataFileLoader(Map)" access="pub" jdoc="Create new instance with replacement objects. @param replacementObjectsThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.AbstractDataFileLoader(Map, Map)" access="pub" jdoc="Create new instance with replacement objects and replacement substrings. @param roThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param rsThe replacement substrings for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
				<param name="rs"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.load(String)" access="pub" jdoc="{@inheritDoc}">
				<param name="filename"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.loadDataSet(URL)" access="prot" jdoc="Make the dbUnit dataset ({@link org.dbunit.dataset.IDataSet}) from the input stream of a dbUnit data file. The type of dbUnit dataset created is delegated to the implementing subclass. @param urlThe dbUnit data file url. @return dbUnit dataset of the corresponding input file type. @throws DataSetExceptionOn data errors. @throws IOExceptionOn file errors. @since 2.4.8">
				<param name="url"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.processReplacementTokens(IDataSet)" access="prot" jdoc="Add the replacements in the maps (objects and substrings) to the specified dataset. @param dsThe dataset to wrap with a &amp;lt;code&amp;gt;ReplacementDataSet&amp;lt; code&amp;gt; and process replacement tokens on. @return The specified dataset decorated with &amp;lt;code&amp;gt;ReplacementDataSet&amp;lt; code&amp;gt; and processed with the tokens in the replacement maps. @since 2.4.8">
				<param name="ds"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.addReplacementObjects(Map)" access="pub" jdoc="{@inheritDoc}">
				<param name="ro"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.addReplacementSubstrings(Map)" access="pub" jdoc="{@inheritDoc}">
				<param name="rs"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.removeAllReplacementObjects()" access="pub" jdoc="{@inheritDoc}">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.AbstractDataFileLoader.removeAllReplacementSubstrings()" access="pub" jdoc="{@inheritDoc}">
			</mth>
		</class>
		<class name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader" intfc="n" abs="n" inn="n" sloc="29" jdoc="@author Jeff Jensen jeffjensen AT users.sourceforge.net @author Last changed by: $Author$ @version $Revision$ $Date$ @since 2.4.8">
			<field name="builder" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.FlatXmlDataFileLoader()" access="pub" jdoc="Create new instance.">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.FlatXmlDataFileLoader(Map)" access="pub" jdoc="Create new instance with replacement objects. @param replacementObjectsThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.FlatXmlDataFileLoader(Map, Map)" access="pub" jdoc="Create new instance with replacement objects and replacement substrings. @param roThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param rsThe replacement substrings for use with{@link org.dbunit.dataset.ReplacementDataSet}.">
				<param name="ro"/>
				<param name="rs"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.FlatXmlDataFileLoader(Map, Map, FlatXmlDataSetBuilder)" access="pub" jdoc="Create new instance with replacement objects, replacement substrings, and{@link org.dbunit.dataset.xml.FlatXmlDataSetBuilder}. @param roThe replacement objects for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param rsThe replacement substrings for use with{@link org.dbunit.dataset.ReplacementDataSet}. @param builderThe {@link org.dbunit.dataset.xml.FlatXmlDataSetBuilder} to use.">
				<param name="ro"/>
				<param name="rs"/>
				<param name="builder"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.FlatXmlDataFileLoader(FlatXmlDataSetBuilder)" access="pub" jdoc="Create new instance with a{@link org.dbunit.dataset.xml.FlatXmlDataSetBuilder}. @param builderThe {@link org.dbunit.dataset.xml.FlatXmlDataSetBuilder} to use.">
				<param name="builder"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.loadDataSet(URL)" access="prot" jdoc="{@inheritDoc}">
				<param name="url"/>
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.getBuilder()" access="pub" jdoc="Get the builder. @see {@link builder}. @return The builder.">
			</mth>
			<mth name="/:org.dbunit.util.fileloader.FlatXmlDataFileLoader.setBuilder(FlatXmlDataSetBuilder)" access="pub" jdoc="Set the builder. @see {@link builder}. @param builderThe builder to set.">
				<param name="builder"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.util.search">
		<class name="/:org.dbunit.util.search.IEdge" intfc="y" abs="n" inn="n" sloc="4" jdoc="A bidirectional edge on the graph to be searched.&amp;lt;br&amp;gt; It must implement &amp;lt;code&amp;gt;Comparable&amp;lt; code&amp;gt; so the &amp;lt;code&amp;gt;ISearchCallback&amp;lt; code&amp;gt; can properly order the dependencies of a node (so, typically, the implementations will compare the &amp;lt;code&amp;gt;getTo()&amp;lt; code&amp;gt; node). @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<mth name="/:org.dbunit.util.search.IEdge.getFrom()" access="pub" jdoc="Get the node this edge originates from. @return node this edge originates from.">
			</mth>
			<mth name="/:org.dbunit.util.search.IEdge.getTo()" access="pub" jdoc="Get the node this edge points to. @return node this edge points to.">
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.ISearchCallback" intfc="y" abs="n" inn="n" sloc="5" jdoc="Callback used by the search algorithms.&amp;lt;br&amp;gt; This interface is responsible for providing the edges of the graph and it can be notified of some events generated by the search. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<mth name="/:org.dbunit.util.search.ISearchCallback.getEdges(Object)" access="pub" jdoc="Get the edges originating from a node. @param fromNode node from @return all edges originating from this node. @throws Exceptionexception wrapper">
				<param name="fromNode"/>
			</mth>
			<mth name="/:org.dbunit.util.search.ISearchCallback.nodeAdded(Object)" access="pub" jdoc="Notifies the callback that a node has been added to the search result. @param fromNodenode that has been added. @throws Exceptionexception wrapper">
				<param name="fromNode"/>
			</mth>
			<mth name="/:org.dbunit.util.search.ISearchCallback.searchNode(Object)" access="pub" jdoc="Decides if a node should be searched or not @param nodenode to be filtered @return true if the node should be searched @throws Exceptionexception wrapper">
				<param name="node"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.DepthFirstSearch" intfc="n" abs="n" inn="n" sloc="144" jdoc="Search using depth-first algorithm.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; An instance of this class must be used only once, as it maintains the internal state of the search.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; @author gommma (gommma AT users.sourceforge.net) @author Last changed by: $Author: gommma $ @version $Revision: 843 $ $Date: 2008-10-26 09:06:28 -0200 (Dom, 26 Out 2008) $ @since 2.4.0">
			<comm cntt="nodes that were already scanned during the search"/>
			<comm cntt="result of the search"/>
			<comm cntt="input of the search"/>
			<comm cntt="callback used to help the search"/>
			<comm cntt="flag, as one instance cannot be used more than once"/>
			<field name="scannedNodes" access="priv" jdoc=""/>
			<field name="reverseScannedNodes" access="priv" jdoc=""/>
			<const name="logger" access="prot" jdoc=""/>
			<field name="result" access="priv" jdoc=""/>
			<field name="nodesFrom" access="priv" jdoc=""/>
			<field name="callback" access="priv" jdoc=""/>
			<field name="searching" access="priv" jdoc=""/>
			<field name="searchDepth" access="priv" jdoc="The search depth to be used when recursing through the child nodes"/>
			<mth name="/:org.dbunit.util.search.DepthFirstSearch.DepthFirstSearch()" access="pub" jdoc="Creates a new depth-first algorithm using the maximum search depth for recursing over the nodes.">
			</mth>
			<mth name="/:org.dbunit.util.search.DepthFirstSearch.DepthFirstSearch(int)" access="pub" jdoc="Creates a new depth-first algorithm @param searchDepth The search depth to be used when traversing the nodes recursively. Must be &amp;gt; 0. @since 2.4">
				<param name="searchDepth"/>
			</mth>
			<mth name="/:org.dbunit.util.search.DepthFirstSearch.search(Object[], ISearchCallback)" access="pub" jdoc="Alternative option to search() that takes an array of nodes as input (instead of a Set) @see ISearchAlgorithm">
				<param name="nodesFrom"/>
				<param name="callback"/>
			</mth>
			<mth name="/:org.dbunit.util.search.DepthFirstSearch.search(Set, ISearchCallback)" access="pub" jdoc="@see ISearchAlgorithm">
				<comm cntt="set of tables that will be returned (i.e, the declared tables and its"/>
				<comm cntt="dependencies)"/>
				<comm cntt="callback used to help the search"/>
				<comm cntt="In a traditional depth-first search, the getEdges() method should return only"/>
				<comm cntt="edges where this node is the &amp;apos;from&amp;apos; vertex, as the graph is known in advance."/>
				<comm cntt="But in our case, the graph is built &amp;apos;on the fly&amp;apos;, so it&amp;apos;s possible that the"/>
				<comm cntt="getEdges() also returns edges where the node is the &amp;apos;to&amp;apos; vertex."/>
				<comm cntt="So, before we do the &amp;quot;real&amp;quot; search, we need to do a reverse search to find out"/>
				<comm cntt="all the nodes that should be part of the input."/>
				<comm cntt="this.nodesFrom = nodesFrom;"/>
				<comm cntt="now that the input is adjusted, do the search"/>
				<comm cntt="decides if we continue searching"/>
				<param name="nodesFrom"/>
				<param name="callback"/>
			</mth>
			<mth name="/:org.dbunit.util.search.DepthFirstSearch.search(Object, int)" access="priv" jdoc="This is the real depth first search algorithm, which is called recursively. @param node node where the search starts @param currentSearchDepth the search depth in the recursion @return true if the node has been already searched before @throws Exception if an exception occurs while getting the edges">
				<comm cntt="first, search the nodes the node depends on"/>
				<comm cntt="and recursively search these nodes"/>
				<comm cntt="finally, add the node to the result"/>
				<comm cntt="notify the callback a node was added"/>
				<param name="node"/>
				<param name="currentSearchDepth"/>
			</mth>
			<mth name="/:org.dbunit.util.search.DepthFirstSearch.reverseSearch(Object, int)" access="priv" jdoc="Do a reverse search (i.e, searching the other way of the edges) in order to adjust the input before the real search. @param node node where the search starts @param currentSearchDepth the search depth in the recursion @return true if the node has been already reverse-searched before @throws Exception if an exception occurs while getting the edges">
				<comm cntt="first, search the nodes the node depends on"/>
				<comm cntt="and recursively search these nodes if we find a match"/>
				<comm cntt="finally, add the node to the input"/>
				<param name="node"/>
				<param name="currentSearchDepth"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback" intfc="n" abs="y" inn="n" sloc="61" jdoc="Super-class for ISearchCallback implementations that needs to filter which nodes should be included or excluded from the search.&amp;lt;br&amp;gt; This class implements the &amp;lt;code&amp;gt;searchNode()&amp;lt; code&amp;gt; based on its internal mode, which could be &amp;lt;code&amp;gt;ALLOW_MODE&amp;lt; code&amp;gt;, &amp;lt;code&amp;gt;DENY_MODE&amp;lt; code&amp;gt; or &amp;lt;code&amp;gt;NO_MODE&amp;lt; code&amp;gt;: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;NO_MODE&amp;lt; code&amp;gt; is the default mode and means &amp;lt;code&amp;gt;searchNode()&amp;lt; code&amp;gt; always return true&amp;lt; li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ALLOW_MODE&amp;lt; code&amp;gt; is set when &amp;lt;code&amp;gt;setAllowedNodes()&amp;lt; code&amp;gt; is called and it means &amp;lt;code&amp;gt;searchNode()&amp;lt; code&amp;gt; will return true only if the node is contained on the Set (or array) passed to &amp;lt;code&amp;gt;setAllowedNodes()&amp;lt; code&amp;gt; &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;DENY_MODE&amp;lt; code&amp;gt; is set when &amp;lt;code&amp;gt;setDeniedNodes()&amp;lt; code&amp;gt; is called and it means &amp;lt;code&amp;gt;searchNode()&amp;lt; code&amp;gt; will return true only if the node is not contained on the Set (or array) passed to &amp;lt;code&amp;gt;setDeniedNodes()&amp;lt; code&amp;gt; &amp;lt; ul&amp;gt; @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<comm cntt="internal modes"/>
			<const name="logger" access="prot" jdoc=""/>
			<const name="NO_MODE" access="prot" jdoc=""/>
			<const name="ALLOW_MODE" access="prot" jdoc=""/>
			<const name="DENY_MODE" access="prot" jdoc=""/>
			<field name="filteringMode" access="priv" jdoc=""/>
			<field name="filteredNodes" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.AbstractNodesFilterSearchCallback()" access="pub" jdoc="Default constructor.">
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.getFilteredNodes()" access="prot" jdoc="Get which modes are allowed denied, depending on the operation mode. @return which modes are allowed denied, depending on the operation mode.">
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.getFilteringMode()" access="prot" jdoc="Get the operation mode @return operation mode">
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.setAllowedNodes(Set)" access="prot" jdoc="Set which modes are allowed on the search. @param filteredNodes which modes are allowed on the search.">
				<param name="filteredNodes"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.setAllowedNodes(Object[])" access="prot" jdoc="Set which modes are allowed on the search. @param filteredNodes which modes are allowed on the search.">
				<param name="filteredNodes"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.setDeniedNodes(Set)" access="prot" jdoc="Set which modes are not allowed on the search. @param filteredNodes which modes are not allowed on the search.">
				<param name="filteredNodes"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.setDeniedNodes(Object[])" access="prot" jdoc="Set which modes are not allowed on the search. @param filteredNodes which modes are not allowed on the search.">
				<param name="filteredNodes"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.nodeAdded(Object)" access="pub" jdoc="Do nothing...">
				<comm cntt="do nothing"/>
				<param name="fromNode"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.searchNode(Object)" access="pub" jdoc="">
				<param name="node"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.setFilteredNodes(Set)" access="priv" jdoc="">
				<param name="filteredNodes"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractNodesFilterSearchCallback.setFilteredNodes(Object[])" access="priv" jdoc="">
				<param name="filteredNodes"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.AbstractIncludeNodesSearchCallback" intfc="n" abs="y" inn="n" sloc="11" jdoc="@author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<mth name="/:org.dbunit.util.search.AbstractIncludeNodesSearchCallback.AbstractIncludeNodesSearchCallback(Set)" access="pub" jdoc="">
				<param name="allowedNodes"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractIncludeNodesSearchCallback.AbstractIncludeNodesSearchCallback(Object[])" access="pub" jdoc="">
				<param name="allowedNodes"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.Edge" intfc="n" abs="n" inn="n" sloc="61" jdoc="Basic implementation of the {@link IEdge} interface. @author Felipe Leme (dbunit@felipeal.net) @author Last changed by: $Author: gommma $ @version $Revision: 826 $ $Date: 2008-10-05 14:42:03 -0300 (Dom, 05 Out 2008) $ @since 2.2.0 (Aug 25, 2005)">
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<const name="nodeFrom" access="priv" jdoc=""/>
			<const name="nodeTo" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.search.Edge.Edge(Comparable, Comparable)" access="pub" jdoc="@param nodeFrom @param nodeTo">
				<param name="nodeFrom"/>
				<param name="nodeTo"/>
			</mth>
			<mth name="/:org.dbunit.util.search.Edge.getFrom()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.search.Edge.getTo()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.search.Edge.toString()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.search.Edge.compareTo(Object)" access="pub" jdoc="Compares this edge to the given one using the &amp;lt;code&amp;gt;{@link #getFrom()}&amp;lt; code&amp;gt; nodes first. If those are equal the &amp;lt;code&amp;gt;{@link #getTo()}}&amp;lt; code&amp;gt; is used for comparison. @see java.lang.Comparable#compareTo(java.lang.Object)">
				<param name="o"/>
			</mth>
			<mth name="/:org.dbunit.util.search.Edge.hashCode()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.search.Edge.equals(Object)" access="pub" jdoc="">
				<param name="obj"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.AbstractExcludeNodesSearchCallback" intfc="n" abs="y" inn="n" sloc="11" jdoc="@author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<mth name="/:org.dbunit.util.search.AbstractExcludeNodesSearchCallback.AbstractExcludeNodesSearchCallback(Set)" access="pub" jdoc="">
				<param name="deniedNodes"/>
			</mth>
			<mth name="/:org.dbunit.util.search.AbstractExcludeNodesSearchCallback.AbstractExcludeNodesSearchCallback(Object[])" access="pub" jdoc="">
				<param name="deniedNodes"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.SearchException" intfc="n" abs="n" inn="n" sloc="14" jdoc="Base class for exceptions during the search. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 769 $ @since Aug 25, 2005">
			<const name="serialVersionUID" access="priv" jdoc=""/>
			<mth name="/:org.dbunit.util.search.SearchException.SearchException()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.search.SearchException.SearchException(String)" access="pub" jdoc="">
				<param name="msg"/>
			</mth>
			<mth name="/:org.dbunit.util.search.SearchException.SearchException(String, Throwable)" access="pub" jdoc="">
				<param name="msg"/>
				<param name="e"/>
			</mth>
			<mth name="/:org.dbunit.util.search.SearchException.SearchException(Throwable)" access="pub" jdoc="">
				<param name="e"/>
			</mth>
		</class>
		<class name="/:org.dbunit.util.search.ISearchAlgorithm" intfc="y" abs="n" inn="n" sloc="3" jdoc="Interface representing an algorithm that searches a graph. @author Felipe Leme (dbunit@felipeal.net) @version $Revision: 806 $ @since Aug 25, 2005">
			<mth name="/:org.dbunit.util.search.ISearchAlgorithm.search(Set, ISearchCallback)" access="pub" jdoc="Search all nodes that originates from a set of nodes. @param nodesFrom input nodes @param callback helper callback @return all nodes, in the right dependent order (like a LinkedHashSet) @throws Exception exception wrapper">
				<param name="nodesFrom"/>
				<param name="callback"/>
			</mth>
		</class>
	</pkg>
	<pkg name="/:org.dbunit.util.xml">
		<class name="/:org.dbunit.util.xml.XmlWriter" intfc="n" abs="n" inn="n" sloc="475" jdoc="Makes writing XML much much easier. Improved from &amp;lt;a href=&amp;quot;http: builder.com.com article.jhtml?id=u00220020318yan01.htm&amp;page=1&amp;vf=tt&amp;quot;&amp;gt;article&amp;lt; a&amp;gt; @author &amp;lt;a href=&amp;quot;mailto:bayard@apache.org&amp;quot;&amp;gt;Henri Yandell&amp;lt; a&amp;gt; @author &amp;lt;a href=&amp;quot;mailto:pete@fingertipsoft.com&amp;quot;&amp;gt;Peter Cassetta&amp;lt; a&amp;gt; @author Last changed by: $Author: gommma $ @version $Revision: 1054 $ $Date: 2009-10-09 19:50:13 -0300 (Sex, 09 Out 2009) $ @since 1.0">
			<comm cntt="underlying writer"/>
			<comm cntt="the encoding to be written into the XML header metatag"/>
			<comm cntt="of xml element names"/>
			<comm cntt="current attribute string"/>
			<comm cntt="is the current node empty"/>
			<comm cntt="is the current node closed..."/>
			<comm cntt="is pretty printing enabled?"/>
			<comm cntt="close off the opening tag"/>
			<comm cntt="write out all current attributes"/>
			<comm cntt="Two example methods. They should output the same XML:"/>
			<comm cntt="&amp;lt;person name=&amp;quot;fred&amp;quot; age=&amp;quot;12&amp;quot;&amp;gt;&amp;lt;phone&amp;gt;425343&amp;lt; phone&amp;gt;&amp;lt;bob &amp;gt;&amp;lt; person&amp;gt;"/>
			<comm cntt=""/>
			<comm cntt="Added for DbUnit"/>
			<const name="CDATA_START" access="pub" jdoc="CDATA start tag: {@value}"/>
			<const name="CDATA_END" access="pub" jdoc="CDATA end tag: {@value}"/>
			<const name="DEFAULT_ENCODING" access="pub" jdoc="Default encoding value which is {@value}"/>
			<const name="logger" access="priv" jdoc="Logger for this class"/>
			<field name="out" access="priv" jdoc=""/>
			<field name="encoding" access="priv" jdoc=""/>
			<field name="stack" access="priv" jdoc=""/>
			<field name="attrs" access="priv" jdoc=""/>
			<field name="empty" access="priv" jdoc=""/>
			<field name="closed" access="priv" jdoc=""/>
			<field name="pretty" access="priv" jdoc=""/>
			<field name="wroteText" access="priv" jdoc="was text the last thing output?"/>
			<field name="indent" access="priv" jdoc="output this to indent one level when pretty printing"/>
			<field name="newline" access="priv" jdoc="output this to end a line when pretty printing"/>
			<mth name="/:org.dbunit.util.xml.XmlWriter.XmlWriter(Writer)" access="pub" jdoc="Create an XmlWriter on top of an existing java.io.Writer.">
				<param name="writer"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.XmlWriter(Writer, String)" access="pub" jdoc="Create an XmlWriter on top of an existing java.io.Writer.">
				<param name="writer"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.XmlWriter(OutputStream, String)" access="pub" jdoc="Create an XmlWriter on top of an existing {@link java.io.OutputStream}. @param outputStream @param encoding The encoding to be used for writing to the given output stream. Can be &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt;. If it is &amp;lt;code&amp;gt;null&amp;lt; code&amp;gt; the {@link #DEFAULT_ENCODING} is used. @throws UnsupportedEncodingException @since 2.4">
				<param name="outputStream"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.enablePrettyPrint(boolean)" access="pub" jdoc="Turn pretty printing on or off. Pretty printing is enabled by default, but it can be turned off to generate more compact XML. @param enable true to enable, false to disable pretty printing.">
				<param name="enable"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.setIndent(String)" access="pub" jdoc="Specify the string to prepend to a line for each level of indent. It is 2 spaces (&amp;quot; &amp;quot;) by default. Some may prefer a single tab (&amp;quot;\t&amp;quot;) or a different number of spaces. Specifying an empty string will turn off indentation when pretty printing. @param indent representing one level of indentation while pretty printing.">
				<param name="indent"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.setNewline(String)" access="pub" jdoc="Specify the string used to terminate each line when pretty printing. It is a single newline (&amp;quot;\n&amp;quot;) by default. Users who need to read generated XML documents in Windows editors like Notepad may wish to set this to a carriage return newline sequence (&amp;quot;\r\n&amp;quot;). Specifying an empty string will turn off generation of line breaks when pretty printing. @param newline representing the newline sequence when pretty printing.">
				<param name="newline"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeElementWithText(String, String)" access="pub" jdoc="A helper method. It writes out an element which contains only text. @param name String name of tag @param text String of text to go inside the tag">
				<param name="name"/>
				<param name="text"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeEmptyElement(String)" access="pub" jdoc="A helper method. It writes out empty entities. @param name String name of tag">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeElement(String)" access="pub" jdoc="Begin to write out an element. Unlike the helper tags, this tag will need to be ended with the endElement method. @param name String name of tag">
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.openElement(String)" access="priv" jdoc="Begin to output an element. @param name name of element.">
				<comm cntt="! wasClosed separates adjacent opening tags by a newline."/>
				<comm cntt="this.wroteText makes sure an element embedded within the text of"/>
				<comm cntt="its parent element begins on a new line, indented to the proper"/>
				<comm cntt="level. This solves only part of the problem of pretty printing"/>
				<comm cntt="entities which contain both text and child entities."/>
				<comm cntt="Indent opening tag to proper level"/>
				<param name="name"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.closeOpeningTag()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeAttributes()" access="priv" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeAttribute(String, String)" access="pub" jdoc="Write an attribute out for the current element. Any XML characters in the value are escaped. Currently it does not actually throw the exception, but the API is set that way for future changes. @param attr name of attribute. @param value value of attribute. @see #writeAttribute(String,String,boolean)">
				<param name="attr"/>
				<param name="value"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeAttribute(String, String, boolean)" access="pub" jdoc="Write an attribute out for the current element. Any XML characters in the value are escaped. Currently it does not actually throw the exception, but the API is set that way for future changes. @param attr name of attribute. @param value value of attribute. @param literally If the writer should be literally on the given value which means that meta characters will also be preserved by escaping them. Mainly preserves newlines and tabs.">
				<comm cntt="maintain API"/>
				<param name="attr"/>
				<param name="value"/>
				<param name="literally"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.endElement()" access="pub" jdoc="End the current element. This will throw an exception if it is called when there is not a currently open element.">
				<comm cntt="Indent closing tag to proper level"/>
				<comm cntt="Add a newline after the closing tag"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.close()" access="pub" jdoc="Close this writer. It does not close the underlying writer, but does throw an exception if there are as yet unclosed tags.">
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeText(String)" access="pub" jdoc="Output body text. Any XML characters are escaped. @param text The text to be written @return This writer @throws IOException @see #writeText(String,boolean)">
				<param name="text"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeText(String, boolean)" access="pub" jdoc="Output body text. Any XML characters are escaped. @param text The text to be written @param literally If the writer should be literally on the given value which means that meta characters will also be preserved by escaping them. Mainly preserves newlines and tabs. @return This writer @throws IOException">
				<param name="text"/>
				<param name="literally"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeCData(String)" access="pub" jdoc="Write out a chunk of CDATA. This helper method surrounds the passed in data with the CDATA tag. @param cdata of CDATA text.">
				<comm cntt="There may already be CDATA sections inside the data."/>
				<comm cntt="But CDATA sections can&amp;apos;t be nested - can&amp;apos;t have ]]&amp;gt; inside a CDATA section."/>
				<comm cntt="(See http: www.w3.org TR REC-xml #NT-CDStart in the W3C specs)"/>
				<comm cntt="The solutions is to replace any occurrence of &amp;quot;]]&amp;gt;&amp;quot; by &amp;quot;]]]]&amp;gt;&amp;lt;![CDATA[&amp;gt;&amp;quot;,"/>
				<comm cntt="so that the top CDATA section is split into many valid CDATA sections (you"/>
				<comm cntt="can look at the &amp;quot;]]]]&amp;gt;&amp;quot; as if it was an escape sequence for &amp;quot;]]&amp;gt;&amp;quot;)."/>
				<param name="cdata"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeComment(String)" access="pub" jdoc="Write out a chunk of comment. This helper method surrounds the passed in data with the XML comment tag. @param comment of text to comment.">
				<param name="comment"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeChunk(String)" access="priv" jdoc="">
				<param name="data"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.main(String[])" access="pub" jdoc="">
				<param name="args"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.test1()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.test2()" access="pub" jdoc="">
				<comm cntt="xmlwriter.setDefaultNamespace(&amp;quot;test&amp;quot;);"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.escapeXml(String, boolean)" access="priv" jdoc="Escapes some meta characters like \n, \r that should be preserved in the XML so that a reader will not filter out those symbols. This code is modified from xmlrpc: https: svn.apache.org repos asf webservices xmlrpc branches XMLRPC_1_2_BRANCH src java org apache xmlrpc XmlWriter.java @param str The string to be escaped @param literally If the writer should be literally on the given value which means that meta characters will also be preserved by escaping them. Mainly preserves newlines and carriage returns. @return The escaped string">
				<comm cntt="If we found something to substitute, then copy over previous"/>
				<comm cntt="data then do the substitution."/>
				<comm cntt="nothing found, just return source"/>
				<param name="str"/>
				<param name="literally"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.isValidXmlChar(char)" access="priv" jdoc="Section 2.2 of the XML spec describes which Unicode code points are valid in XML: &amp;lt;blockquote&amp;gt;&amp;lt;code&amp;gt;#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]&amp;lt; code&amp;gt;&amp;lt; blockquote&amp;gt; Code points outside this set must be entity encoded to be represented in XML. @param c The character to inspect. @return Whether the specified character is valid in XML.">
				<comm cntt="line feed, &amp;apos;\n&amp;apos;"/>
				<comm cntt="carriage return, &amp;apos;\r&amp;apos;"/>
				<param name="c"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.replace(String, String, String)" access="priv" jdoc="">
				<param name="value"/>
				<param name="original"/>
				<param name="replacement"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.setEncoding(String)" access="priv" jdoc="">
				<comm cntt="Use official encoding names where we know them,"/>
				<comm cntt="avoiding the Java-only names. When using common"/>
				<comm cntt="encodings where we can easily tell if characters"/>
				<comm cntt="are out of range, we&amp;apos;ll escape out-of-range"/>
				<comm cntt="characters using character refs for safety."/>
				<comm cntt="I _think_ these are all the main synonyms for these!"/>
				<comm cntt="dangerMask = (short)0xff80;"/>
				<comm cntt="dangerMask = (short)0xff00;"/>
				<comm cntt="TODO: UTF-16BE, UTF-16LE ... no BOM; what"/>
				<comm cntt="release of JDK supports those Unicode names?"/>
				<comm cntt="if (dangerMask != 0)"/>
				<comm cntt="stringBuf = new StringBuffer();"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.setWriter(Writer, String)" access="pub" jdoc="Resets the handler to write a new text document. @param writer XML text is written to this writer. @param encoding if non-null, and an XML declaration is written, this is the name that will be used for the character encoding. @exception IllegalStateException if the current document hasn&amp;apos;t yet ended (i.e. the output stream {@link #out} is not null)">
				<comm cntt="if (!(this.out instanceof BufferedWriter))"/>
				<comm cntt="this.out = new BufferedWriter(this.out);"/>
				<param name="writer"/>
				<param name="encoding"/>
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeDeclaration()" access="pub" jdoc="">
			</mth>
			<mth name="/:org.dbunit.util.xml.XmlWriter.writeDoctype(String, String)" access="pub" jdoc="">
				<param name="systemId"/>
				<param name="publicId"/>
			</mth>
		</class>
	</pkg>
</java-project>